(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview  Axis component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    chartConst = require('../const'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    axisTemplate = require('./axisTemplate');

var Axis = tui.util.defineClass(/** @lends Axis.prototype */ {
    /**
     * Axis component.
     * @constructs Axis
     * @param {object} params parameters
     *      @param {{
     *          labels: Array.<string>,
     *          tickCount: number,
     *          isLabelAxis: boolean,
     *          isVertical: boolean
     *      }} params.data axis data
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     *      @param {object} params.options axis options
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * Axis view className
         */
        this.className = 'tui-chart-axis-area';
    },

    /**
     * Make height of x axis area.
     * @returns {number} height
     * @private
     */
    _makeXAxisHeight: function() {
        var title = this.options.title,
            titleAreaHeight = renderUtil.getRenderedLabelHeight(title, this.theme.title) + chartConst.TITLE_PADDING,
            height = renderUtil.getRenderedLabelHeight(chartConst.MAX_HEIGHT_WORLD, this.theme.label) + titleAreaHeight;
        return height;
    },

    /**
     * Make width of y axis area.
     * @param {Array.<string | number>} labels labels
     * @returns {number} width
     * @private
     */
    _makeYAxisWidth: function(labels) {
        var title = this.options.title || '',
            titleAreaWidth, width;

        titleAreaWidth = renderUtil.getRenderedLabelHeight(title, this.theme.title) + chartConst.TITLE_PADDING;
        width = renderUtil.getRenderedLabelsMaxWidth(labels, this.theme.label) + titleAreaWidth + chartConst.AXIS_LABEL_PADDING;

        return width;
    },

    /**
     * Whether valid axis or not.
     * @returns {boolean} whether valid axis or not.
     * @private
     */
    _isValidAxis: function() {
        var isInvalid = true,
            groupValues;

        if (this.name === 'rightYAxis') {
            groupValues = this.dataProcessor.getGroupValues();
            tui.util.forEach(groupValues, function(values) {
                if (!values.length) {
                    isInvalid = false;
                    return false;
                }
            });
        }

        return isInvalid;
    },

    /**
     * Register legend dimension to boundsMaker.
     */
    registerDimension: function() {
        var dimension = {};

        if (this._isValidAxis()) {
            if (this.componentType === 'xAxis') {
                dimension.height = this._makeXAxisHeight();
                this.boundsMaker.registerBaseDimension(this.name, dimension);
            } else if (this.isLabel) {
                dimension.width = this._makeYAxisWidth(this.dataProcessor.getCategories());
                this.boundsMaker.registerBaseDimension(this.name, dimension);
            }
        }
    },

    /**
     * Register legend additional dimension to boundsMaker.
     */
    registerAdditionalDimension: function() {
        var dimension,
            axesData = this.boundsMaker.axesData;

        if (this._isValidAxis()) {
            if (this.componentType === 'yAxis' && !this.isLabel) {
                dimension = {
                    width: this._makeYAxisWidth(axesData.yAxis.labels)
                };
                this.boundsMaker.registerBaseDimension(this.name, dimension);
            }
        }
    },

    /**
     * Render axis area.
     * @param {HTMLElement} axisContainer axis area element
     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data
     * @private
     */
    _renderAxisArea: function(axisContainer, data) {
        var theme = this.theme,
            isVertical = !!data.isVertical,
            isPositionRight = !!data.isPositionRight,
            options = this.options,
            dimension = this.boundsMaker.getDimension(this.name),
            size = isVertical ? dimension.height : dimension.width,
            elTitleArea = this._renderTitleArea({
                title: options.title,
                theme: theme.title,
                isVertical: isVertical,
                isPositionRight: isPositionRight,
                size: size
            }),
            elLabelArea = this._renderLabelArea(data, size, dimension.width),
            elTickArea;

        this.data = data;

        if (!isVertical || !data.aligned) {
            elTickArea = this._renderTickArea(size);
        }

        renderUtil.renderDimension(axisContainer, dimension);
        renderUtil.renderPosition(axisContainer, this.boundsMaker.getPosition(this.name));
        dom.addClass(axisContainer, isVertical ? 'vertical' : 'horizontal');
        dom.addClass(axisContainer, isPositionRight ? 'right' : '');
        dom.append(axisContainer, [elTitleArea, elTickArea, elLabelArea]);
    },

    /**
     * Render axis component.
     * @param {{isVertical: boolean, isPositionRight: boolean, aligned: aligned}} data rendering data
     * @returns {HTMLElement} axis area base element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);

        this._renderAxisArea(el, data);
        this.axisContainer = el;
        return el;
    },

    /**
     * Rerender axis component.
     * @param {object} data rendering data
     */
    rerender: function(data) {
        this.axisContainer.innerHTML = '';

        if (this._isValidAxis()) {
            if (data.options) {
                this.options = data.options;
            }
            this._renderAxisArea(this.axisContainer, data);
        }
    },

    /**
     * Resize axis component.
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound axis bound
     * @param {object} data rendering data
     */
    resize: function(bound, data) {
        this.rerender(bound, data);
    },

    /**
     * Render css style of title area
     * @param {HTMLElement} elTitleArea title element
     * @param {number} size (width or height)
     * @param {boolean} isPositionRight whether right position or not?
     * @private
     */
    _renderTitleAreaStyle: function(elTitleArea, size, isPositionRight) {
        var cssTexts = [
            renderUtil.concatStr('width:', size, 'px')
        ];

        if (isPositionRight) {
            if (renderUtil.isIE7()) {
                cssTexts.push(renderUtil.concatStr('right:', '0px'));
            } else {
                cssTexts.push(renderUtil.concatStr('right:', -size, 'px'));
            }
            cssTexts.push('top:0px');
        } else {
            cssTexts.push('left:0px');
            if (!renderUtil.isOldBrowser()) {
                cssTexts.push(renderUtil.concatStr('top:', size, 'px'));
            }
        }

        elTitleArea.style.cssText += ';' + cssTexts.join(';');
    },

    /**
     * Title area renderer
     * @param {object} params parameters
     *      @param {string} params.title axis title
     *      @param {object} params.theme title theme
     *      @param {boolean} params.isVertical whether vertical or not?
     *      @param {boolean} params.isPositionRight whether right position or not?
     *      @param {number} params.size (width or height)
     * @returns {HTMLElement} title element
     * @private
     */
    _renderTitleArea: function(params) {
        var elTitleArea = renderUtil.renderTitle(params.title, params.theme, 'tui-chart-title-area');

        if (elTitleArea && params.isVertical) {
            this._renderTitleAreaStyle(elTitleArea, params.size, params.isPositionRight);
        }

        return elTitleArea;
    },

    /**
     * Redner tick area.
     * @param {number} size size or height
     * @returns {HTMLElement} tick area element
     * @private
     */
    _renderTickArea: function(size) {
        var data = this.data,
            tickCount = data.tickCount,
            tickColor = this.theme.tickColor,
            positions = calculator.makeTickPixelPositions(size, tickCount),
            elTickArea = dom.create('DIV', 'tui-chart-tick-area'),
            posType = data.isVertical ? 'bottom' : 'left',
            verticalBorderColorType = data.isPositionRight ? 'borderLeftColor' : 'borderRightColor',
            borderColorType = data.isVertical ? verticalBorderColorType : 'borderTopColor',
            template = axisTemplate.tplAxisTick,
            ticksHtml = tui.util.map(positions, function(position, index) {
                var cssText;
                if (data.aligned && data.labels[index] === chartConst.EMPTY_AXIS_LABEL) {
                    return '';
                }
                cssText = [
                    renderUtil.concatStr('background-color:', tickColor),
                    renderUtil.concatStr(posType, ': ', position, 'px')
                ].join(';');
                return template({cssText: cssText});
            }, this).join('');

        elTickArea.innerHTML = ticksHtml;
        elTickArea.style[borderColorType] = tickColor;

        return elTickArea;
    },

    /**
     * Make cssText of vertical label.
     * @param {number} axisWidth axis width
     * @param {number} titleAreaWidth title area width
     * @returns {string} cssText
     * @private
     */
    _makeVerticalLabelCssText: function(axisWidth, titleAreaWidth) {
        return ';width:' + (axisWidth - titleAreaWidth + chartConst.V_LABEL_RIGHT_PADDING) + 'px';
    },

    /**
     * Render label area.
     * @param {object} data rendering data
     * @param {number} size label area size
     * @param {number} axisWidth axis area width
     * @returns {HTMLElement} label area element
     * @private
     */
    _renderLabelArea: function(data, size, axisWidth) {
        var tickPixelPositions = calculator.makeTickPixelPositions(size, data.tickCount),
            labelSize = tickPixelPositions[1] - tickPixelPositions[0],
            posType = 'left',
            cssTexts = this._makeLabelCssTexts({
                isVertical: data.isVertical,
                isLabelAxis: data.isLabelAxis,
                labelSize: labelSize
            }),
            elLabelArea = dom.create('DIV', 'tui-chart-label-area'),
            areaCssText = renderUtil.makeFontCssText(this.theme.label),
            categories = data.labels,
            labelsHtml, titleAreaWidth;

        if (data.isVertical) {
            posType = data.isLabelAxis ? 'top' : 'bottom';
            titleAreaWidth = this._getRenderedTitleHeight() + chartConst.TITLE_AREA_WIDTH_PADDING;
            areaCssText += this._makeVerticalLabelCssText(axisWidth, titleAreaWidth);
        } else if (data.isLabelAxis && this.options.rotation === false) {
            categories = this.dataProcessor.getMultilineCategories();
        }

        tickPixelPositions.length = categories.length;
        labelsHtml = this._makeLabelsHtml({
            positions: tickPixelPositions,
            labels: categories,
            posType: posType,
            cssTexts: cssTexts,
            labelSize: labelSize,
            theme: this.theme.label
        });

        elLabelArea.innerHTML = labelsHtml;
        elLabelArea.style.cssText = areaCssText;

        this._changeLabelAreaPosition({
            elLabelArea: elLabelArea,
            isVertical: data.isVertical,
            isLabelAxis: data.isLabelAxis,
            theme: this.theme.label,
            labelSize: labelSize,
            aligned: data.aligned
        });

        return elLabelArea;
    },

    /**
     * Get height of title area ;
     * @returns {number} height
     * @private
     */
    _getRenderedTitleHeight: function() {
        var title = this.options.title,
            theme = this.theme.title,
            result = title ? renderUtil.getRenderedLabelHeight(title, theme) : 0;

        return result;
    },

    /**
     * Make cssTexts of label.
     * @param {object} params parameter
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {boolean} params.isLabelAxis whether label axis or not
     *      @param {number} params.labelSize label size (width or height)
     * @returns {string[]} cssTexts
     * @private
     */
    _makeLabelCssTexts: function(params) {
        var cssTexts = [];

        if (params.isVertical && params.isLabelAxis) {
            cssTexts.push(renderUtil.concatStr('height:', params.labelSize, 'px'));
            cssTexts.push(renderUtil.concatStr('line-height:', params.labelSize, 'px'));
        } else if (!params.isVertical) {
            cssTexts.push(renderUtil.concatStr('width:', params.labelSize, 'px'));
        }

        return cssTexts;
    },

    /**
     * Calculate rotation moving position.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPosition: function(params) {
        var moveLeft = params.moveLeft;

        if (params.degree === chartConst.ANGLE_85) {
            moveLeft += calculator.calculateAdjacent(chartConst.ANGLE_90 - params.degree, params.labelHeight / 2);
        }

        return {
            top: params.top,
            left: params.left - moveLeft
        };
    },

    /**
     * Calculate rotation moving position for ie8.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {{top:number, left: number}} position
     * @private
     */
    _calculateRotationMovingPositionForIE8: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.label, params.theme),
            smallAreaWidth = calculator.calculateAdjacent(chartConst.ANGLE_90 - params.degree, params.labelHeight / 2),
            newLabelWidth = (calculator.calculateAdjacent(params.degree, labelWidth / 2) + smallAreaWidth) * 2,
            collectLeft = labelWidth - newLabelWidth,
            moveLeft = (params.labelWidth / 2) - (smallAreaWidth * 2);

        if (params.degree === chartConst.ANGLE_85) {
            moveLeft += smallAreaWidth;
        }

        return {
            top: chartConst.XAXIS_LABEL_TOP_MARGIN,
            left: params.left + collectLeft - moveLeft
        };
    },

    /**
     * Make cssText for rotation moving.
     * @param {object} params parameters
     *      @param {number} params.degree rotation degree
     *      @param {number} params.labelWidth label width
     *      @param {number} params.labelHeight label height
     *      @param {number} params.left normal left
     *      @param {number} params.moveLeft move left
     *      @param {number} params.top top
     *      @param {(string | number)} params.label label
     *      @param {object} theme label theme
     * @returns {string} cssText
     * @private
     */
    _makeCssTextForRotationMoving: function(params) {
        var position;

        if (renderUtil.isOldBrowser()) {
            position = this._calculateRotationMovingPositionForIE8(params);
        } else {
            position = this._calculateRotationMovingPosition(params);
        }

        return renderUtil.concatStr('left:', position.left, 'px', ';top:', position.top, 'px');
    },

    /**
     * Make html of rotation labels.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeRotationLabelsHtml: function(params) {
        var template = axisTemplate.tplAxisLabel,
            labelHeight = renderUtil.getRenderedLabelHeight(params.labels[0], params.theme),
            labelCssText = params.cssTexts.length ? params.cssTexts.join(';') + ';' : '',
            addClass = ' tui-chart-xaxis-rotation tui-chart-xaxis-rotation' + this.boundsMaker.xAxisDegree,
            halfWidth = params.labelSize / 2,
            moveLeft = calculator.calculateAdjacent(this.boundsMaker.xAxisDegree, halfWidth),
            top = calculator.calculateOpposite(this.boundsMaker.xAxisDegree, halfWidth) + chartConst.XAXIS_LABEL_TOP_MARGIN,
            labelsHtml = tui.util.map(params.positions, function(position, index) {
                var label = params.labels[index],
                    rotationCssText = this._makeCssTextForRotationMoving({
                        degree: params.degree,
                        labelHeight: labelHeight,
                        labelWidth: params.labelSize,
                        top: top,
                        left: position,
                        moveLeft: moveLeft,
                        label: label,
                        theme: params.theme
                    });

                return template({
                    addClass: addClass,
                    cssText: labelCssText + rotationCssText,
                    label: label
                });
            }, this).join('');

        return labelsHtml;
    },

    /**
     * Make html of normal labels.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeNormalLabelsHtml: function(params) {
        var template = axisTemplate.tplAxisLabel,
            labelCssText = params.cssTexts.length ? params.cssTexts.join(';') + ';' : '',
            labelsHtml = tui.util.map(params.positions, function(position, index) {
                var addCssText = renderUtil.concatStr(params.posType, ':', position, 'px');
                return template({
                    addClass: '',
                    cssText: labelCssText + addCssText,
                    label: params.labels[index]
                });
            }, this).join('');

        return labelsHtml;
    },

    /**
     * Make html of labels.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions label position array
     *      @param {string[]} params.labels label array
     *      @param {string} params.posType position type (left or bottom)
     *      @param {string[]} params.cssTexts css array
     * @returns {string} labels html
     * @private
     */
    _makeLabelsHtml: function(params) {
        var labelsHtml;

        if (this.name === 'xAxis' && this.boundsMaker.xAxisDegree) {
            labelsHtml = this._makeRotationLabelsHtml(params);
        } else {
            labelsHtml = this._makeNormalLabelsHtml(params);
        }

        return labelsHtml;
    },

    /**
     * Change position of label area.
     * @param {object} params parameter
     *      @param {HTMLElement} params.elLabelArea label area element
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {boolean} params.isLabelAxis whether label axis or not
     *      @param {{fontSize: number, fontFamily: string, color: string}} params.theme label theme
     *      @param {number} params.labelSize label size (width or height)
     * @private
     */
    _changeLabelAreaPosition: function(params) {
        var labelHeight;

        if (params.isLabelAxis && !params.aligned) {
            return;
        }

        if (params.isVertical) {
            labelHeight = renderUtil.getRenderedLabelHeight('ABC', params.theme);
            params.elLabelArea.style.top = renderUtil.concatStr(parseInt(labelHeight / 2, 10), 'px');
        } else {
            params.elLabelArea.style.left = renderUtil.concatStr('-', parseInt(params.labelSize / 2, 10), 'px');
        }
    }
});

module.exports = Axis;

},{"../const":19,"../helpers/calculator":35,"../helpers/domHandler":38,"../helpers/renderUtil":42,"./axisTemplate":2}],2:[function(require,module,exports){
/**
 * @fileoverview This is templates or axis view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_AXIS_TICK: '<div class="tui-chart-tick" style="{{ cssText }}"></div>',
    HTML_AXIS_LABEL: '<div class="tui-chart-label{{ addClass }}" style="{{ cssText }}"><span>{{ label }}</span></div>'
};

module.exports = {
    tplAxisTick: templateMaker.template(tags.HTML_AXIS_TICK),
    tplAxisLabel: templateMaker.template(tags.HTML_AXIS_LABEL)
};

},{"../helpers/templateMaker":43}],3:[function(require,module,exports){
/**
 * @fileoverview chart.js is entry point of Toast UI Chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    pluginFactory = require('./factories/pluginFactory'),
    themeFactory = require('./factories/themeFactory'),
    mapFactory = require('./factories/mapFactory');

var _createChart;

require('./polyfill');
require('./code-snippet-util');
require('./registerCharts');
require('./registerThemes');

/**
 * NHN Entertainment Toast UI Chart.
 * @namespace tui.chart
 */
tui.util.defineNamespace('tui.chart');

/**
 * Create chart.
 * @param {HTMLElement} container container
 * @param {Array.<Array>} data chart data
 * @param {{
 *   chart: {
 *     width: number,
 *     height: number,
 *     title: string,
 *     format: string
 *   },
 *   yAxis: {
 *     title: string,
 *     min: number
 *   },
 *   xAxis: {
 *     title: strig,
 *     min: number
 *   },
 *   tooltip: {
 *     suffix: string,
 *     template: function
 *   },
 *   theme: string
 * }} options chart options
 * @returns {object} chart instance.
 * @private
 * @ignore
 */
_createChart = function(container, data, options) {
    var themeName, theme, chart;
    options = options ? JSON.parse(JSON.stringify(options)) : {};
    themeName = options.theme || chartConst.DEFAULT_THEME_NAME;
    theme = themeFactory.get(themeName);

    chart = chartFactory.get(options.chartType, data, theme, options);
    container.appendChild(chart.render());
    chart.animateChart();

    return chart;
};

/**
 * Bar chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<string>} data.categories categories
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.labelInterval label interval of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.min minimal value of horizontal axis
 *          @param {number} options.xAxis.max maximum value of horizontal axis
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.diverging whether diverging or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Bar Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.barChart(container, data, options);
 */
tui.chart.barChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_BAR;
    return _createChart(container, data, options);
};

/**
 * Column chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<string>} data.categories categories
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {string} options.series.stacked stacked type
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {number} options.series.barWidth bar width
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.diverging whether diverging or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} column chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Column Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.columnChart(container, data, options);
 */
tui.chart.columnChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COLUMN;
    return _createChart(container, data, options);
};

/**
 * Line chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<string>} data.categories categories
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Line Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.lineChart(container, data, options);
 */
tui.chart.lineChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_LINE;
    return _createChart(container, data, options);
};

/**
 * Area chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<string>} data.categories categories
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.hasDot whether has dot or not
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *          @param {boolean} options.series.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: [20, 30, 50]
 *         },
 *         {
 *           name: 'Legend2',
 *           data: [40, 40, 60]
 *         },
 *         {
 *           name: 'Legend3',
 *           data: [60, 50, 10]
 *         },
 *         {
 *           name: 'Legend4',
 *           data: [80, 10, 70]
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Area Chart'
 *       },
 *       yAxis: {
 *         title: 'Y Axis'
 *       },
 *       xAxis: {
 *         title: 'X Axis'
 *       }
 *     };
 * tui.chart.areaChart(container, data, options);
 */
tui.chart.areaChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_AREA;
    return _createChart(container, data, options);
};

/**
 * Combo chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<string>} data.categories categories
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object|Array} options.yAxis options of vertical axis
 *          @param {string} options.yAxis.title title of vertical axis
 *          @param {number} options.yAxis.min minimal value of vertical axis
 *          @param {number} options.yAxis.max maximum value of vertical axis
 *      @param {object} options.xAxis options of horizontal axis
 *          @param {string} options.xAxis.title title of horizontal axis
 *          @param {number} options.xAxis.labelInterval label interval of horizontal axis
 *          @param {boolean} options.xAxis.rotation whether label rotation or not (default: true)
 *      @param {object} options.series options of series
 *          @param {object} options.series.column options of column series
 *              @param {string} options.series.column.stacked stacked type
 *              @param {boolean} options.series.column.showLabel whether show label or not
 *              @param {number} options.series.column.barWidth bar width
 *              @param {boolean} options.series.column.hasSelection whether has selection or not
 *          @param {object} options.series.line options of line series
 *              @param {boolean} options.series.line.hasDot whether has dot or not
 *              @param {boolean} options.series.line.showLabel whether show label or not
 *              @param {boolean} options.series.line.hasSelection whether has selection or not
 *              @param {boolean} options.series.line.spline whether spline or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {object} options.tooltip.column options of column tooltip
 *              @param {string} options.tooltip.column.suffix suffix of tooltip
 *              @param {function} [options.tooltip.column.template] template of tooltip
 *              @param {string} options.tooltip.column.align tooltip align option
 *              @param {object} options.tooltip.column.position relative position
 *                  @param {number} options.tooltip.column.position.left position left
 *                  @param {number} options.tooltip.column.position.top position top
 *          @param {boolean} options.tooltip.grouped whether group tooltip or not
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       categories: ['cate1', 'cate2', 'cate3'],
 *       series: {
 *         column: [
 *           {
 *             name: 'Legend1',
 *             data: [20, 30, 50]]
 *           },
 *           {
 *             name: 'Legend2',
 *             data: [40, 40, 60]
 *           },
 *           {
 *             name: 'Legend3',
 *             data: [60, 50, 10]
 *           },
 *           {
 *             name: 'Legend4',
 *             data: [80, 10, 70]
 *           }
 *         },
 *         line: [
 *           {
 *             name: 'Legend5',
 *             data: [1, 2, 3]
 *           }
 *         ]
 *       }
 *     },
 *     options = {
 *       chart: {
 *         title: 'Combo Chart'
 *       },
 *       yAxis:[
 *         {
 *           title: 'Y Axis',
 *           chartType: 'line'
 *         },
 *         {
 *           title: 'Y Right Axis'
 *         }
 *       ],
 *       xAxis: {
 *         title: 'X Axis'
 *       },
 *       series: {
 *         hasDot: true
 *       }
 *     };
 * tui.chart.comboChart(container, data, options);
 */
tui.chart.comboChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_COMBO;
    return _createChart(container, data, options);
};

/**
 * Pie chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *          @param {boolean} options.series.hasSelection whether has selection or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {string} options.tooltip.suffix suffix of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left|center|outer)
 *          @param {boolean} options.legend.hasCheckbox whether has checkbox or not (default: true)
 *          @param {boolean} options.legend.hidden whether hidden or not
 *      @param {string} options.theme theme name
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       series: [
 *         {
 *           name: 'Legend1',
 *           data: 20
 *         },
 *         {
 *           name: 'Legend2',
 *           data: 40
 *         },
 *         {
 *           name: 'Legend3',
 *           data: 60
 *         },
 *         {
 *           name: 'Legend4',
 *           data: 80
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Pie Chart'
 *       }
 *     };
 * tui.chart.pieChart(container, data, options);
 */
tui.chart.pieChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_PIE;
    return _createChart(container, data, options);
};

/**
 * Map chart creator.
 * @memberOf tui.chart
 * @param {HTMLElement} container chart container
 * @param {object} data chart data
 *      @param {Array.<Array>} data.series series data
 * @param {object} options chart options
 *      @param {object} options.chart chart options
 *          @param {number} options.chart.width chart width
 *          @param {number} options.chart.height chart height
 *          @param {string} options.chart.title chart title
 *          @param {string} options.chart.format value format
 *      @param {object} options.series options of series
 *          @param {boolean} options.series.showLabel whether show label or not
 *      @param {object} options.tooltip options of tooltip
 *          @param {function} [options.tooltip.template] template of tooltip
 *          @param {string} options.tooltip.align tooltip align option
 *          @param {object} options.tooltip.position relative position
 *              @param {number} options.tooltip.position.left position left
 *              @param {number} options.tooltip.position.top position top
 *      @param {object} options.legend options of legend
 *          @param {string} options.legend.align legend align (top|bottom|left|center|outer)
 *      @param {string} options.theme theme name
 *      @param {string} options.map map type
 *      @param {string} options.libType graph library type
 * @returns {object} bar chart
 * @api
 * @example
 * var container = document.getElementById('container-id'),
 *     data = {
 *       series: [
 *         {
 *           code: 'KR',
 *           data: 100,
 *           labelCoordinate: {
 *             x: 0.6,
 *             y: 0.7
 *           }
 *         },
 *         {
 *           code: 'JP',
 *           data: 50
 *         }
 *       ]
 *     },
 *     options = {
 *       chart: {
 *         title: 'Map Chart'
 *       },
 *       map: 'world'
 *     };
 * tui.chart.mapChart(container, data, options);
 */
tui.chart.mapChart = function(container, data, options) {
    options = options || {};
    options.chartType = chartConst.CHART_TYPE_MAP;
    options.map = mapFactory.get(options.map);

    return _createChart(container, data, options);
};

/**
 * Register theme.
 * @memberOf tui.chart
 * @param {string} themeName theme name
 * @param {object} theme application chart theme
 *      @param {object} theme.chart chart theme
 *          @param {string} theme.chart.fontFamily font family of chart
 *          @param {string} theme.chart.background background of chart
 *      @param {object} theme.title chart theme
 *          @param {number} theme.title.fontSize font size of chart title
 *          @param {string} theme.title.fontFamily font family of chart title
 *          @param {string} theme.title.color font color of chart title
 *          @param {string} theme.title.background background of chart title
 *      @param {object} theme.yAxis theme of vertical axis
 *          @param {object} theme.yAxis.title theme of vertical axis title
 *              @param {number} theme.yAxis.title.fontSize font size of vertical axis title
 *              @param {string} theme.yAxis.title.fontFamily font family of vertical axis title
 *              @param {string} theme.yAxis.title.color font color of vertical axis title
 *          @param {object} theme.yAxis.label theme of vertical axis label
 *              @param {number} theme.yAxis.label.fontSize font size of vertical axis label
 *              @param {string} theme.yAxis.label.fontFamily font family of vertical axis label
 *              @param {string} theme.yAxis.label.color font color of vertical axis label
 *          @param {string} theme.yAxis.tickcolor color of vertical axis tick
 *      @param {object} theme.xAxis theme of horizontal axis
 *          @param {object} theme.xAxis.title theme of horizontal axis title
 *              @param {number} theme.xAxis.title.fontSize font size of horizontal axis title
 *              @param {string} theme.xAxis.title.fontFamily font family of horizontal axis title
 *              @param {string} theme.xAxis.title.color font color of horizontal axis title
 *          @param {object} theme.xAxis.label theme of horizontal axis label
 *              @param {number} theme.xAxis.label.fontSize font size of horizontal axis label
 *              @param {string} theme.xAxis.label.fontFamily font family of horizontal axis label
 *              @param {string} theme.xAxis.label.color font color of horizontal axis label
 *          @param {string} theme.xAxis.tickcolor color of horizontal axis tick
 *      @param {object} theme.plot plot theme
 *          @param {string} theme.plot.lineColor plot line color
 *          @param {string} theme.plot.background plot background
 *      @param {object} theme.series series theme
 *          @param {Array.<string>} theme.series.colors series colors
 *          @param {string} theme.series.borderColor series border color
 *          @param {string} theme.series.selectionColor series selection color
 *          @param {string} theme.series.startColor start color for map chart
 *          @param {string} theme.series.endColor end color for map chart
 *          @param {string} theme.series.overColor end color for map chart
 *      @param {object} theme.legend legend theme
 *          @param {object} theme.legend.label theme of legend label
 *              @param {number} theme.legend.label.fontSize font size of legend label
 *              @param {string} theme.legend.label.fontFamily font family of legend label
 *              @param {string} theme.legend.label.color font color of legend label
 * @api
 * @example
 * var theme = {
 *   yAxis: {
 *     tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     xAxis: {
 *       tickColor: '#ccbd9a',
 *       title: {
 *         color: '#333333'
 *       },
 *       label: {
 *         color: '#6f491d'
 *       }
 *     },
 *     plot: {
 *       lineColor: '#e5dbc4',
 *       background: '#f6f1e5'
 *     },
 *     series: {
 *       colors: ['#40abb4', '#e78a31', '#c1c452', '#795224', '#f5f5f5'],
 *       borderColor: '#8e6535',
 *       selectionColor: '#cccccc',
 *       startColor: '#efefef',
 *       endColor: 'blue',
 *       overColor: 'yellow'
 *     },
 *     legend: {
 *       label: {
 *         color: '#6f491d'
 *       }
 *     }
 *   };
 * tui.chart.registerTheme('newTheme', theme);
 */
tui.chart.registerTheme = function(themeName, theme) {
    themeFactory.register(themeName, theme);
};

/**
 * Register map.
 * @param {string} mapName map name
 * @param {{width: number, height: number}} dimension map dimension
 * @param {Array.<{code: string, name: string, path: string}>} data map data
 * @api
 * @example
 * var data = [
 *   {
 *     code: 'KR',
 *     name: 'South Korea',
 *     path: 'M835.13,346.53L837.55,350.71...',
 *     labelCoordinate: {
 *       x: 0.6,
 *       y: 0.7
 *     }
 *   },
 *   //...
 * ];
 * tui.chart.registerMap('newMap', data);
 */
tui.chart.registerMap = function(mapName, data) {
    mapFactory.register(mapName, data);
};

/**
 * Register graph plugin.
 * @memberOf tui.chart
 * @param {string} libType type of graph library
 * @param {object} plugin plugin to control library
 * @example
 * var pluginRaphael = {
 *   bar: function() {} // Render class
 * };
 * tui.chart.registerPlugin('raphael', pluginRaphael);
 */
tui.chart.registerPlugin = function(libType, plugin) {
    pluginFactory.register(libType, plugin);
};

},{"./code-snippet-util":18,"./const":19,"./factories/chartFactory":29,"./factories/mapFactory":30,"./factories/pluginFactory":31,"./factories/themeFactory":32,"./polyfill":61,"./registerCharts":62,"./registerThemes":63}],4:[function(require,module,exports){
/**
 * @fileoverview Area chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    Series = require('../series/areaChartSeries');

var AreaChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-area-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Area chart.
     * @constructs AreaChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
    }
});

axisTypeMixer.mixin(AreaChart);
lineTypeMixer.mixin(AreaChart);

module.exports = AreaChart;

},{"../series/areaChartSeries":64,"./axisTypeMixer":5,"./chartBase":8,"./lineTypeMixer":13}],5:[function(require,module,exports){
/**
 * @fileoverview axisTypeMixer is mixer of axis type chart(bar, column, line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var renderUtil = require('../helpers/renderUtil'),
    ChartBase = require('./chartBase'),
    Axis = require('../axes/axis'),
    Plot = require('../plots/plot'),
    Legend = require('../legends/legend'),
    GroupTypeCustomEvent = require('../customEvents/groupTypeCustomEvent'),
    PointTypeCustomEvent = require('../customEvents/pointTypeCustomEvent'),
    Tooltip = require('../tooltips/tooltip'),
    GroupTooltip = require('../tooltips/groupTooltip');


/**
 * Axis limit value.
 * @typedef {{min: number, max: number}} axisLimit
 */

/**
 * axisTypeMixer is base class of axis type chart(bar, column, line, area).
 * @mixin
 */
var axisTypeMixer = {
    /**
     * Add axis components.
     * @param {Array.<object>} axes axes option
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addAxisComponents: function(axes, aligned) {
        tui.util.forEach(axes, function(axis) {
            var axisParams = {
                aligned: aligned,
                isLabel: !!axis.isLabel,
                chartType: axis.chartType
            };

            if (axis.name === 'rightYAxis') {
                axisParams.componentType = 'yAxis';
                axisParams.index = 1;
            }

            this.componentManager.register(axis.name, Axis, axisParams);
        }, this);
    },

    /**
     * Add series components
     * @param {Array<object>} serieses serieses
     * @param {object} options options
     * @param {boolean} aligned whether aligned or not
     * @private
     */
    _addSeriesComponents: function(serieses, options) {
        var seriesBaseParams = {
            libType: options.libType,
            chartType: options.chartType,
            userEvent: this.userEvent,
            componentType: 'series'
        };

        tui.util.forEach(serieses, function(series) {
            var seriesParams = tui.util.extend(seriesBaseParams, series.data);
            this.componentManager.register(series.name, series.SeriesClass, seriesParams);
        }, this);
    },

    /**
     * Add tooltip component
     * @private
     */
    _addTooltipComponent: function() {
        var TooltipClass = this.hasGroupTooltip ? GroupTooltip : Tooltip;
        this.componentManager.register('tooltip', TooltipClass, this._makeTooltipData());
    },

    /**
     * Add legend component.
     * @param {Array.<string>} chartTypes series chart types
     * @param {string} chartType chartType
     * @param {object} legendOptions legend options
     * @private
     */
    _addLegendComponent: function(chartTypes, chartType, legendOptions) {
        if (!legendOptions || !legendOptions.hidden) {
            this.componentManager.register('legend', Legend, {
                chartTypes: chartTypes,
                chartType: chartType,
                userEvent: this.userEvent
            });
        }
    },

    /**
     * Add components for axis type chart.
     * @param {object} params parameters
     *      @param {object} params.axes axes data
     *      @param {object} params.plotData plot data
     *      @param {function} params.serieses serieses
     * @private
     */
    _addComponentsForAxisType: function(params) {
        var options = this.options,
            aligned = !!params.aligned;

        this.componentManager.register('plot', Plot);
        this._addAxisComponents(params.axes, aligned);
        this._addLegendComponent(params.seriesChartTypes, params.chartType, this.options.legend);
        this._addSeriesComponents(params.serieses, options);
        this._addTooltipComponent(options.chartType);
    },

    /**
     * Get limit map.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @returns {{column: ?axisLimit, line: ?axisLimit}} limit map
     * @private
     */
    _getLimitMap: function(axesData, chartTypes) {
        var limitMap = {},
            yAxisLimit = axesData.yAxis ? axesData.yAxis.limit : axesData.rightYAxis.limit;

        limitMap[chartTypes[0]] = this.isVertical ? yAxisLimit : axesData.xAxis.limit;

        if (chartTypes.length > 1) {
            limitMap[chartTypes[1]] = axesData.rightYAxis ? axesData.rightYAxis.limit : yAxisLimit;
        }

        return limitMap;
    },

    /**
     * Make series data for rendering.
     * @param {{yAxis: object, xAxis: object}} axesData axes data
     * @param {Array.<string>} chartTypes chart types
     * @param {boolean} isVertical whether vertical or not
     * @returns {object} series data
     * @private
     */
    _makeSeriesDataForRendering: function(axesData, chartTypes) {
        var limitMap = this._getLimitMap(axesData, chartTypes),
            aligned = axesData.xAxis.aligned,
            seriesData = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            seriesData[chartType + 'Series'] = {
                limit: limitMap[chartType],
                aligned: aligned,
                hasAxes: true
            };
        });

        return seriesData;
    },

    /**
     * Update percent values.
     * @param {object} axesData axes data
     * @private
     * @override
     */
    _updatePercentValues: function(axesData) {
        var chartTypes = this.chartTypes || [this.chartType],
            limitMap = this._getLimitMap(axesData, chartTypes),
            stackedOption = this.options.series && this.options.series.stacked;
        tui.util.forEachArray(chartTypes, function(chartType) {
            this.dataProcessor.registerPercentValues(limitMap[chartType], stackedOption, chartType);
        }, this);
    },

    /**
     * Make rendering data for axis type chart.
     * @param {object} axesData axesData
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function(axesData) {
        var optionChartTypes = this.chartTypes || [this.chartType],
            seriesData = this._makeSeriesDataForRendering(axesData, optionChartTypes, this.isVertical),
            yAxis = axesData.yAxis ? axesData.yAxis : axesData.rightYAxis;

        return tui.util.extend({
            plot: {
                vTickCount: yAxis.validTickCount,
                hTickCount: axesData.xAxis.validTickCount
            },
            customEvent: {
                tickCount: this.isVertical ? axesData.xAxis.tickCount : yAxis.tickCount
            }
        }, seriesData, axesData);
    },

    /**
     * Add grouped event handler layer.
     * @param {{yAxis: obejct, xAxis: object}} axesData axes data
     * @param {string} chartType chart type
     * @param {boolean} isVertical whether vertical or not
     * @private
     * @override
     */
    _addCustomEventComponentForGroupTooltip: function() {
        this.componentManager.register('customEvent', GroupTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', PointTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        if (this.hasGroupTooltip) {
            this._addCustomEventComponentForGroupTooltip();
        } else {
            this._addCustomEventComponentForNormalTooltip();
        }
    },

    /**
     * Attach coordinate event.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForGroupTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showGroupTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideGroupTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowGroupTooltipLine) {
                tooltip.on('showGroupTooltipLine', series.onShowGroupTooltipLine, series);
                tooltip.on('hideGroupTooltipLine', series.onHideGroupTooltipLine, series);
            }
            tooltip.on('showGroupAnimation', series.onShowGroupAnimation, series);
            tooltip.on('hideGroupAnimation', series.onHideGroupAnimation, series);
        }, this);
    },

    /**
     * Attach custom event for normal tooltip.
     * @param {CustomEvent} customEvent custom event component
     * @param {Tooltip} tooltip tooltip component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForNormalTooltip: function(customEvent, tooltip, serieses) {
        customEvent.on('showTooltip', tooltip.onShow, tooltip);
        customEvent.on('hideTooltip', tooltip.onHide, tooltip);

        tui.util.forEach(serieses, function(series) {
            if (series.onShowAnimation) {
                tooltip.on(renderUtil.makeCustomEventName('show', series.chartType, 'animation'), series.onShowAnimation, series);
                tooltip.on(renderUtil.makeCustomEventName('hide', series.chartType, 'animation'), series.onHideAnimation, series);
            }
        }, this);
    },

    /**
     * Attach custom event for series selection.
     * @param {CustomEvent} customEvent custom event component
     * @param {Array.<Series>} serieses series components
     * @private
     */
    _attachCustomEventForSeriesSelection: function(customEvent, serieses) {
        tui.util.forEach(serieses, function(series) {
            customEvent.on(renderUtil.makeCustomEventName('select', series.chartType, 'series'), series.onSelectSeries, series);
            customEvent.on(renderUtil.makeCustomEventName('unselect', series.chartType, 'series'), series.onUnselectSeries, series);
        }, this);
    },

    /**
     * Attach custom event.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var serieses = this.componentManager.where({componentType: 'series'}),
            customEvent = this.componentManager.get('customEvent'),
            tooltip = this.componentManager.get('tooltip');

        ChartBase.prototype._attachCustomEvent.call(this, serieses);

        if (this.hasGroupTooltip) {
            this._attachCustomEventForGroupTooltip(customEvent, tooltip, serieses);
        } else {
            this._attachCustomEventForNormalTooltip(customEvent, tooltip, serieses);
        }

        this._attachCustomEventForSeriesSelection(customEvent, serieses);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = axisTypeMixer;

},{"../axes/axis":1,"../customEvents/groupTypeCustomEvent":23,"../customEvents/pointTypeCustomEvent":26,"../helpers/renderUtil":42,"../legends/legend":45,"../plots/plot":50,"../tooltips/groupTooltip":76,"../tooltips/tooltip":80,"./chartBase":8}],6:[function(require,module,exports){
/**
 * @fileoverview Bar chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    axisTypeMixer = require('./axisTypeMixer'),
    barTypeMixer = require('./barTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/barChartSeries');

var BarChart = tui.util.defineClass(ChartBase, /** @lends BarChart.prototype */ {
    /**
     * Bar chart.
     * @constructs BarChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-bar-chart';

        /**
         * Whether has right y axis or not.
         * @type {boolean}
         */
        this.hasRightYAxis = false;

        options.series = options.series || {};

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stacked);
            options.series.stacked = options.series.stacked || chartConst.STACKED_NORMAL_TYPE;
            this.hasRightYAxis = options.yAxis && tui.util.isArray(options.yAxis) && options.yAxis.length > 1;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make axes data
     * @param {object} bounds chart bounds
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            xAxisData = axisDataMaker.makeValueAxisData({
                values: this.dataProcessor.getGroupValues(),
                seriesDimension: {
                    width: this.boundsMaker.makeSeriesWidth()
                },
                stackedOption: options.series.stacked || '',
                divergingOption: options.series.diverging,
                chartType: options.chartType,
                formatFunctions: this.dataProcessor.getFormatFunctions(),
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                isVertical: true
            }),
            axesData = {
                xAxis: xAxisData,
                yAxis: yAxisData
            };

        if (this.hasRightYAxis) {
            axesData.rightYAxis = tui.util.extend({
                isPositionRight: true
            }, JSON.parse(JSON.stringify(yAxisData)));
        }

        return axesData;
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        var axes = [
            {
                name: 'yAxis',
                isLabel: true
            },
            {
                name: 'xAxis'
            }
        ];

        if (this.hasRightYAxis) {
            axes.push({
                name: 'rightYAxis',
                isLabe: true
            });
        }
        this._addComponentsForAxisType({
            axes: axes,
            chartType: chartType,
            serieses: [
                {
                    name: 'barSeries',
                    SeriesClass: Series
                }
            ]
        });
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var boundParams;

        if (this.hasRightYAxis) {
            boundParams = {
                optionChartTypes: ['bar', 'bar']
            };
        }

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
    }
});

axisTypeMixer.mixin(BarChart);
barTypeMixer.mixin(BarChart);

module.exports = BarChart;

},{"../const":19,"../helpers/axisDataMaker":33,"../series/barChartSeries":65,"./axisTypeMixer":5,"./barTypeMixer":7,"./chartBase":8}],7:[function(require,module,exports){
/**
 * @fileoverview barTypeMixer is mixer of bar type chart(bar, column).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate');

/**
 * barTypeMixer is mixer of bar type chart(bar, column).
 * @mixin
 */
var barTypeMixer = {

    /**
     * Pick stacks.
     * @param {Array.<{stack: string}>} rawSeriesData raw series data
     * @returns {Array.<string>} stacks
     * @private
     */
    _pickStacks: function(rawSeriesData) {
        var stacks;

        stacks = tui.util.map(rawSeriesData, function(seriesDatum) {
            return seriesDatum.stack;
        });

        stacks = tui.util.filter(stacks, function(stack) {
            return !!stack;
        });

        stacks = tui.util.unique(stacks).slice(0, 2);

        return stacks;
    },

    /**
     * Make minus values.
     * @param {Array.<number>} data number data
     * @returns {Array} minus values
     * @private
     */
    _makeMinusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : -value;
        });
    },

    /**
     * Make plus values.
     * @param {Array.<number>} data number data
     * @returns {Array} plus values
     * @private
     */
    _makePlusValues: function(data) {
        return tui.util.map(data, function(value) {
            return value < 0 ? 0 : value;
        });
    },

    /**
     * Make normal diverging raw series data.
     * @param {{data: Array.<number>}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeNormalDivergingRawSeriesData: function(rawSeriesData) {
        rawSeriesData.length = Math.min(rawSeriesData.length, 2);

        rawSeriesData[0].data = this._makeMinusValues(rawSeriesData[0].data);

        if (rawSeriesData[1]) {
            rawSeriesData[1].data = this._makePlusValues(rawSeriesData[1].data);
        }

        return rawSeriesData;
    },

    /**
     * Make stacked diverging raw series data.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeStackedDivergingRawSeriesData: function(rawSeriesData) {
        var result = [],
            stacks = this._pickStacks(rawSeriesData),
            leftStack = stacks[0],
            rightStack = stacks[1];

        tui.util.forEachArray(rawSeriesData, function(seriesDatum) {
            if (seriesDatum.stack === leftStack) {
                seriesDatum.data = this._makeMinusValues(seriesDatum.data);
                result.push(seriesDatum);
            } else if (seriesDatum.stack === rightStack) {
                seriesDatum.data = this._makePlusValues(seriesDatum.data);
                result.push(seriesDatum);
            }
        }, this);
        return result;
    },

    /**
     * Make raw series data for diverging.
     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
     * @param {?string} stackedOption stacked option
     * @returns {{data: Array.<number>}} changed raw series data
     * @private
     */
    _makeRawSeriesDataForDiverging: function(rawSeriesData, stackedOption) {
        if (predicate.isValidStackedOption(stackedOption)) {
            rawSeriesData = this._makeStackedDivergingRawSeriesData(rawSeriesData);
        } else {
            rawSeriesData = this._makeNormalDivergingRawSeriesData(rawSeriesData);
        }

        return rawSeriesData;
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = barTypeMixer;

},{"../helpers/predicate":41}],8:[function(require,module,exports){
/**
 * @fileoverview ChartBase
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    DefaultDataProcessor = require('../helpers/dataProcessor'),
    BoundsMaker = require('../helpers/boundsMaker'),
    ComponentManager = require('./componentManager'),
    UserEventListener = require('../helpers/userEventListener');

var ChartBase = tui.util.defineClass(/** @lends ChartBase.prototype */ {
    /**
     * Chart base.
     * @constructs ChartBase
     * @param {object} params parameters
     *      @param {object} params.rawData raw data
     *      @param {object} params.theme chart theme
     *      @param {object} params.options chart options
     *      @param {boolean} params.hasAxes whether has axes or not
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {DataProcessor} params.DataProcessor DataProcessor
     */
    init: function(params) {
        /**
         * raw data.
         * @type {object}
         */
        this.rawData = params.rawData;

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = this.options.chartType;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * whether vertical or not
         * @type {boolean}
         */
        this.isVertical = !!params.isVertical;

        /**
         * whether chart has group tooltip or not
         * @type {boolean}
         */
        this.hasGroupTooltip = !!tui.util.pick(this.options, 'tooltip', 'grouped');

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = this._createDataProcessor(params.DataProcessor || DefaultDataProcessor, params);

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = new BoundsMaker({
            options: this.options,
            theme: this.theme,
            dataProcessor: this.dataProcessor,
            hasAxes: this.hasAxes,
            isVertical: this.isVertical,
            chartType: this.chartType
        });

        /**
         * component manager
         * @type {ComponentManager}
         */
        this.componentManager = new ComponentManager({
            dataProcessor: this.dataProcessor,
            options: this.options,
            theme: this.theme,
            boundsMaker: this.boundsMaker,
            hasAxes: this.hasAxes
        });

        /**
         * user event listener
         * @type {object}
         */
        this.userEvent = new UserEventListener();

        /**
         * original whole legend data
         * @type {Array.<object>}
         */
        this.orgWholeLegendData = this.dataProcessor.getWholeLegendData();

        this._addCustomEventComponent();
    },

    /**
     * Create dataProcessor.
     * @param {DataProcessor} DataProcessor DataProcessor class
     * @param {object} params parameters
     *      @params {object} rawData raw data
     *      @params {{chart: object, chartType: string}} options chart options
     *      @params {Array} seriesChartTypes series chart types
     * @returns {object} data processor
     * @private
     */
    _createDataProcessor: function(DataProcessor, params) {
        var dataProcessor = new DataProcessor(params.rawData),
            options = params.options;

        dataProcessor.process(params.rawData, options, params.seriesChartTypes);
        return dataProcessor;
    },

    /**
     * Make data for tooltip component.
     * @returns {object} tooltip data
     * @private
     */
    _makeTooltipData: function() {
        return {
            isVertical: this.isVertical,
            userEvent: this.userEvent,
            chartType: this.chartType
        };
    },

    /**
     * Add custom event component.
     * @private
     * @abstract
     */
    _addCustomEventComponent: function() {},

    /**
     * Make rendering data for axis type chart.
     * @returns {object} rendering data.
     * @private
     */
    _makeRenderingData: function() {
        return {};
    },

    /**
     * Attach custom evnet.
     * @param {Array.<object>} serieses serieses
     * @private
     */
    _attachCustomEvent: function(serieses) {
        var legend = this.componentManager.get('legend');

        serieses = serieses || this.componentManager.where({componentType: 'series'});

        if (legend) {
            legend.on('changeCheckedLegends', this.onChangeCheckedLegends, this);
            tui.util.forEach(serieses, function (series) {
                legend.on(renderUtil.makeCustomEventName('select', series.chartType, 'legend'), series.onSelectLegend, series);
            }, this);
        }
    },

    /**
     * Make axes data.
     * @abstract
     * @private
     */
    _makeAxesData: function() {},

    /**
     * Update percent values.
     * @private
     * @abstract
     */
    _updatePercentValues: function() {},

    /**
     * Execute component function.
     * @param {string} funcName function name
     * @private
     */
    _executeComponentFunc: function(funcName) {
        this.componentManager.each(function(component) {
            if (component[funcName]) {
                component[funcName]();
            }
        });
    },

    /**
     * Render.
     * @param {function} callback callback function
     * @private
     */
    _render: function(callback) {
        var axesData, renderingData;

        this._executeComponentFunc('registerDimension');
        axesData = this._makeAxesData();
        this.boundsMaker.registerAxesData(axesData);
        this._executeComponentFunc('registerAdditionalDimension');
        this.boundsMaker.registerBoundsData();
        this._updatePercentValues(axesData);
        renderingData = this._makeRenderingData(axesData);

        callback(renderingData);

        this._sendSeriesData();
    },

    /**
     * Render chart.
     * @returns {HTMLElement} chart element
     */
    render: function() {
        var el = dom.create('DIV', this.className),
            that = this;

        dom.addClass(el, 'tui-chart');
        this._renderTitle(el);
        renderUtil.renderDimension(el, this.boundsMaker.getDimension('chart'));
        renderUtil.renderBackground(el, this.theme.chart.background);
        renderUtil.renderFontFamily(el, this.theme.chart.fontFamily);

        this._render(function(renderingData) {
            that._renderComponents(renderingData, 'render', el);
        });

        this._attachCustomEvent();
        this.chartContainer = el;

        return el;
    },

    /**
     * Filter raw data.
     * @param {object} rawData raw data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rawData
     * @private
     */
    _filterRawData: function(rawData, checkedLegends) {
        var cloneData = JSON.parse(JSON.stringify(rawData));

        if (tui.util.isArray(cloneData.series)) {
            cloneData.series = tui.util.filter(cloneData.series, function(series, index) {
                return checkedLegends[index];
            });
        } else {
            tui.util.forEach(cloneData.series, function(serieses, chartType) {
                if (!checkedLegends[chartType]) {
                    cloneData.series[chartType] = [];
                } else if (checkedLegends[chartType].length) {
                    cloneData.series[chartType] = tui.util.filter(serieses, function(series, index) {
                        return checkedLegends[chartType][index];
                    });
                }
            });
        }

        return cloneData;
    },

    /**
     * Make rerendering data.
     * @param {object} renderingData rendering data
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @returns {object} rendering data
     * @private
     */
    _makeRerenderingData: function(renderingData, checkedLegends) {
        var tooltipData = this._makeTooltipData(),
            serieses = this.componentManager.where({componentType: 'series'});

        renderingData.tooltip = tui.util.extend({
            checkedLegends: checkedLegends
        }, tooltipData, renderingData.tooltip);

        tui.util.forEach(serieses, function(series) {
            renderingData[series.name] = tui.util.extend({
                checkedLegends: checkedLegends[series.chartType] || checkedLegends
            }, renderingData[series.name]);
        });

        return renderingData;
    },

    /**
     * Rerender.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     * @private
     */
    _rerender: function(checkedLegends, rawData) {
        var that = this,
            newWholeLegendData;

        rawData = rawData || this._filterRawData(this.dataProcessor.getRawData(), checkedLegends);

        this.dataProcessor.process(rawData, this.options, this.seriesChartTypes);

        newWholeLegendData = this.dataProcessor.getWholeLegendData();
        // 범례 영역은 변경되지 않으므로, bounds 계산에는 변경되지 않은 레이블 데이터를 포함해야 함
        this.dataProcessor.setWholeLegendData(this.orgWholeLegendData);

        this.boundsMaker.initBoundsData();
        this._render(function(renderingData) {
            renderingData = that._makeRerenderingData(renderingData, checkedLegends);
            that.dataProcessor.setWholeLegendData(newWholeLegendData);
            that._renderComponents(renderingData, 'rerender');
        });
    },

    /**
     * On change checked legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     * @param {?object} rawData rawData
     * @param {?object} boundsParams addition params for calculating bounds
     */
    onChangeCheckedLegends: function(checkedLegends, rawData, boundsParams) {
        this._rerender(checkedLegends, rawData, boundsParams);
    },

    /**
     * Render title.
     * @param {HTMLElement} el target element
     * @private
     */
    _renderTitle: function(el) {
        var chartOptions = this.options.chart || {},
            elTitle = renderUtil.renderTitle(chartOptions.title, this.theme.title, 'tui-chart-title');

        dom.append(el, elTitle);
    },

    /**
     * Render components.
     * @param {object} renderingData data for rendering
     * @param {string} funcName function name for execution
     * @param {HTMLElement} container container element
     * @private
     */
    _renderComponents: function(renderingData, funcName, container) {
        var elements = this.componentManager.map(function(component) {
            var data = renderingData[component.name],
                element = null;

            if (component[funcName]) {
                element = component[funcName](data);
            }

            return element;
        });

        if (container) {
            dom.append(container, elements);
        }
    },

    /**
     * Send series data to custom event component.
     * @private
     */
    _sendSeriesData: function() {
        var customEvent = this.componentManager.get('customEvent'),
            seriesInfos, chartTypes;

        if (!customEvent) {
            return;
        }

        chartTypes = this.chartTypes || [this.chartType];
        seriesInfos = tui.util.map(chartTypes, function(chartType) {
            var component = this.componentManager.get(chartType + 'Series') || this.componentManager.get('series');

            return {
                chartType: chartType,
                data: component.getSeriesData()
            };
        }, this);

        customEvent.initCustomEventData(seriesInfos);
    },

    /**
     * Make event name for animation.
     * @param {string} chartType chart type
     * @param {string} prefix prefix
     * @returns {string} event name
     * @private
     */
    _makeAnimationEventName: function(chartType, prefix) {
        return prefix + chartType.substring(0, 1).toUpperCase() + chartType.substring(1) + 'Animation';
    },

    /**
     * Animate chart.
     */
    animateChart: function() {
        this.componentManager.each(function(component) {
            if (component.animateComponent) {
                component.animateComponent();
            }
        });
    },

    /**
     * Register of user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    on: function(eventName, func) {
        this.userEvent.register(eventName, func);
    },

    /**
     * Update dimension.
     * @param {{width: number, height: number}} dimension dimension
     * @returns {boolean} whether updated or not
     * @private
     */
    _updateDimension: function(dimension) {
        var updated = false;

        if (dimension.width) {
            this.options.chart.width = dimension.width;
            updated = true;
        }

        if (dimension.height) {
            this.options.chart.height = dimension.height;
            updated = true;
        }

        return updated;
    },

    /**
     * Public API for resizable.
     * @param {object} dimension dimension
     *      @param {number} dimension.width width
     *      @param {number} dimension.height height
     * @api
     */
    resize: function(dimension) {
        var that = this,
            updated;

        if (!dimension) {
            return;
        }

        updated = this._updateDimension(dimension);

        if (!updated) {
            return;
        }

        this.boundsMaker.initBoundsData(this.options.chart);
        renderUtil.renderDimension(this.chartContainer, this.boundsMaker.getDimension('chart'));

        this._render(function(renderingData) {
            that._renderComponents(renderingData, 'resize');
        });
    },

    /**
     * Set tooltip align option.
     * @param {string} align align (left|center|right, top|middle|bottom)
     * @api
     */
    setTooltipAlign: function(align) {
        this.componentManager.get('tooltip').setAlign(align);
    },

    /**
     * Set position option.
     * @param {object} position moving position
     *      @param {number} position.left left
     *      @param {number} position.top top
     * @api
     */
    setTooltipPosition: function(position) {
        this.componentManager.get('tooltip').setPosition(position);
    },

    /**
     * Reset tooltip align option.
     * @api
     */
    resetTooltipAlign: function() {
        this.componentManager.get('tooltip').resetAlign();
    },

    /**
     * Reset tooltip position.
     * @api
     */
    resetTooltipPosition: function() {
        this.componentManager.get('tooltip').resetPosition();
    },

    /**
     * Show series label.
     * @api
     */
    showSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.showLabel();
        });
    },

    /**
     * Hide series label.
     * @api
     */
    hideSeriesLabel: function() {
        var serieses = this.componentManager.where({componentType: 'series'});

        tui.util.forEachArray(serieses, function(series) {
            series.hideLabel();
        });
    }
});

module.exports = ChartBase;

},{"../helpers/boundsMaker":34,"../helpers/dataProcessor":37,"../helpers/domHandler":38,"../helpers/renderUtil":42,"../helpers/userEventListener":44,"./componentManager":11}],9:[function(require,module,exports){
/**
 * @fileoverview Column chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    axisTypeMixer = require('./axisTypeMixer'),
    barTypeMixer = require('./barTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/columnChartSeries');

var ColumnChart = tui.util.defineClass(ChartBase, /** @lends ColumnChart.prototype */ {
    /**
     * Column chart.
     * @constructs ColumnChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     */
    init: function(rawData, theme, options) {
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-column-chart';

        options.series = options.series || {};

        if (options.series.diverging) {
            rawData.series = this._makeRawSeriesDataForDiverging(rawData.series, options.series.stacked);
            options.series.stacked = options.series.stacked || chartConst.STACKED_NORMAL_TYPE;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeValueAxisData({
                values: this.dataProcessor.getGroupValues(),
                seriesDimension: {
                    height: this.boundsMaker.makeSeriesHeight()
                },
                stackedOption: options.series.stacked || '',
                divergingOption: options.series.diverging,
                chartType: options.chartType,
                formatFunctions: this.dataProcessor.getFormatFunctions(),
                options: options.yAxis,
                isVertical: true
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            axes: [
                {
                    name: 'yAxis'
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            chartType: chartType,
            serieses: [
                {
                    name: 'columnSeries',
                    SeriesClass: Series,
                    data: {
                        allowNegativeTooltip: true
                    }
                }
            ]
        });
    }
});

axisTypeMixer.mixin(ColumnChart);
barTypeMixer.mixin(ColumnChart);

module.exports = ColumnChart;

},{"../const":19,"../helpers/axisDataMaker":33,"../series/columnChartSeries":67,"./axisTypeMixer":5,"./barTypeMixer":7,"./chartBase":8}],10:[function(require,module,exports){
/**
 * @fileoverview Combo chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var calculator = require('../helpers/calculator'),
    ChartBase = require('./chartBase'),
    axisTypeMixer = require('./axisTypeMixer'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    defaultTheme = require('../themes/defaultTheme'),
    ColumnChartSeries = require('../series/columnChartSeries'),
    LineChartSeries = require('../series/lineChartSeries');

var ComboChart = tui.util.defineClass(ChartBase, /** @lends ComboChart.prototype */ {
    /**
     * Combo chart.
     * @constructs ComboChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        var chartTypesMap;

        this.className = 'tui-combo-chart';

        chartTypesMap = this._makeChartTypesMap(rawData.series, options.yAxis);

        tui.util.extend(this, chartTypesMap);

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true,
            seriesChartTypes: chartTypesMap.seriesChartTypes
        });

        /**
         * yAxis options map
         * @type {object}
         */
        this.yAxisOptionsMap = this._makeYAxisOptionsMap(chartTypesMap.chartTypes, options.yAxis);
        this._addComponents(chartTypesMap);
    },

    /**
     * Make yAxis options map.
     * @param {Array.<string>} chartTypes chart types
     * @param {?object} yAxisOptions yAxis options
     * @returns {{column: ?object, line: ?object}} options map
     * @private
     */
    _makeYAxisOptionsMap: function(chartTypes, yAxisOptions) {
        var optionMap = {};
        yAxisOptions = yAxisOptions || {};
        tui.util.forEachArray(chartTypes, function(chartType, index) {
            optionMap[chartType] = yAxisOptions[index] || yAxisOptions;
        });

        return optionMap;
    },

    /**
     * Make chart types map.
     * @param {object} rawSeriesData raw series data
     * @param {object} yAxisOption option for y axis
     * @returns {object} chart types map
     * @private
     */
    _makeChartTypesMap: function(rawSeriesData, yAxisOption) {
        var seriesChartTypes = tui.util.keys(rawSeriesData).sort(),
            optionChartTypes = this._getYAxisOptionChartTypes(seriesChartTypes, yAxisOption),
            chartTypes = optionChartTypes.length ? optionChartTypes : seriesChartTypes,
            validChartTypes = tui.util.filter(optionChartTypes, function(chartType) {
                return rawSeriesData[chartType].length;
            }),
            chartTypesMap;

        if (validChartTypes.length === 1) {
            chartTypesMap = {
                chartTypes: validChartTypes,
                seriesChartTypes: validChartTypes,
                optionChartTypes: !optionChartTypes.length ? optionChartTypes : validChartTypes
            };
        } else {
            chartTypesMap = {
                chartTypes: chartTypes,
                seriesChartTypes: seriesChartTypes,
                optionChartTypes: optionChartTypes
            };
        }

        return chartTypesMap;
    },

    /**
     * Make options map
     * @param {object} chartTypes chart types
     * @returns {object} options map
     * @private
     */
    _makeOptionsMap: function(chartTypes) {
        var optionsMap = {};

        tui.util.forEachArray(chartTypes, function(chartType) {
            optionsMap[chartType] = this.options.series[chartType] || this.options.series;
        }, this);

        return optionsMap;
    },

    /**
     * Make theme map
     * @param {object} chartTypes chart types
     * @returns {object} theme map
     * @private
     */
    _makeThemeMap: function(chartTypes) {
        var theme = this.theme,
            themeMap = {},
            colorCount = 0;

        tui.util.forEachArray(chartTypes, function(chartType) {
            var chartTheme = JSON.parse(JSON.stringify(theme)),
                removedColors;

            if (chartTheme.series[chartType]) {
                themeMap[chartType] = chartTheme.series[chartType];
            } else if (!chartTheme.series.colors) {
                themeMap[chartType] = JSON.parse(JSON.stringify(defaultTheme.series));
                themeMap[chartType].label.fontFamily = chartTheme.chart.fontFamily;
            } else {
                removedColors = chartTheme.series.colors.splice(0, colorCount);
                chartTheme.series.colors = chartTheme.series.colors.concat(removedColors);
                themeMap[chartType] = chartTheme.series;
                colorCount += this.dataProcessor.getLegendLabels(chartType).length;
            }
        }, this);

        return themeMap;
    },

    /**
     * Make serieses
     * @param {Array.<string>} chartTypes chart types
     * @returns {Array.<object>} serieses
     * @private
     */
    _makeSerieses: function(chartTypes) {
        var seriesClasses = {
                column: ColumnChartSeries,
                line: LineChartSeries
            },
            optionsMap = this._makeOptionsMap(chartTypes),
            themeMap = this._makeThemeMap(chartTypes),
            serieses;

        serieses = tui.util.map(chartTypes, function(chartType) {
            var data = {
                allowNegativeTooltip: true,
                componentType: 'series',
                chartType: chartType,
                options: optionsMap[chartType],
                theme: themeMap[chartType]
            };

            return {
                name: chartType + 'Series',
                SeriesClass: seriesClasses[chartType],
                data: data
            };
        });

        return serieses;
    },

    /**
     * Add components
     * @param {object} chartTypesMap chart types map
     * @private
     */
    _addComponents: function(chartTypesMap) {
        var axes = [
                {
                    name: 'yAxis',
                    isLabel: true,
                    chartType: chartTypesMap.chartTypes[0]
                },
                {
                    name: 'xAxis'
                }
            ],
            serieses = this._makeSerieses(chartTypesMap.seriesChartTypes);

        if (chartTypesMap.optionChartTypes.length) {
            axes.push({
                name: 'rightYAxis',
                isLabel: true,
                chartType: chartTypesMap.chartTypes[1]
            });
        }

        this._addComponentsForAxisType({
            axes: axes,
            seriesChartTypes: chartTypesMap.seriesChartTypes,
            chartType: this.options.chartType,
            serieses: serieses
        });
    },

    /**
     * Get y axis option chart types.
     * @param {Array.<string>} chartTypes chart types
     * @param {object} yAxisOptions y axis options
     * @returns {Array.<string>} chart types
     * @private
     */
    _getYAxisOptionChartTypes: function(chartTypes, yAxisOptions) {
        var resultChartTypes = chartTypes.slice(),
            isReverse = false,
            optionChartTypes;

        yAxisOptions = yAxisOptions ? [].concat(yAxisOptions) : [];

        if (yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
            resultChartTypes = [];
        } else if (yAxisOptions.length) {
            optionChartTypes = tui.util.map(yAxisOptions, function(option) {
                return option.chartType;
            });

            tui.util.forEachArray(optionChartTypes, function(chartType, index) {
                isReverse = isReverse || (chartType && resultChartTypes[index] !== chartType || false);
            });

            if (isReverse) {
                resultChartTypes.reverse();
            }
        }

        return resultChartTypes;
    },

    /**
     * Make y axis data.
     * @param {object} params parameters
     *      @param {number} params.index chart index
     *      @param {{width: number, height: number}} params.seriesDimension series dimension
     *      @param {Array.<string>} chartTypes chart type
     *      @param {boolean} isOneYAxis whether one series or not
     *      @param {object} options chart options
     *      @param {object} addParams add params
     * @returns {object} y axis data
     * @private
     */
    _makeYAxisData: function(params) {
        var index = params.index,
            chartType = params.chartTypes[index],
            options = params.options,
            yAxisOptions = this.yAxisOptionsMap[chartType],
            yAxisValues, seriesOption, yAxisData;

        if (!chartType) {
            return {};
        }

        if (params.isOneYAxis) {
            yAxisValues = this.dataProcessor.getWholeGroupValues();
        } else {
            yAxisValues = this.dataProcessor.getGroupValues(chartType);
        }

        seriesOption = options.series && options.series[chartType] || options.series;

        yAxisData = axisDataMaker.makeValueAxisData(tui.util.extend({
            values: yAxisValues,
            stackedOption: seriesOption && seriesOption.stacked || '',
            options: yAxisOptions,
            chartType: chartType,
            seriesDimension: params.seriesDimension,
            formatFunctions: this.dataProcessor.getFormatFunctions(),
            isVertical: true
        }, params.addParams));
        yAxisData.options = yAxisOptions;

        return yAxisData;
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            formatFunctions = this.dataProcessor.getFormatFunctions(),
            yAxisParams = {
                seriesDimension: {
                    height: this.boundsMaker.makeSeriesHeight()
                },
                chartTypes: this.chartTypes,
                isOneYAxis: !this.optionChartTypes.length,
                options: options
            },
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories()
            }),
            yAxisData = this._makeYAxisData(tui.util.extend({
                index: 0
            }, yAxisParams)),
            axesData, rightYAxisData;

        axesData = {
            yAxis: yAxisData,
            xAxis: xAxisData
        };

        if (!yAxisParams.isOneYAxis) {
            rightYAxisData = this._makeYAxisData(tui.util.extend({
                index: 1,
                addParams: {
                    isPositionRight: true
                }
            }, yAxisParams));
            if (yAxisData.tickCount < rightYAxisData.tickCount) {
                this._increaseYAxisTickCount(rightYAxisData.tickCount - yAxisData.tickCount, yAxisData, formatFunctions);
            } else if (yAxisData.tickCount > rightYAxisData.tickCount) {
                this._increaseYAxisTickCount(yAxisData.tickCount - rightYAxisData.tickCount, rightYAxisData, formatFunctions);
            }

            rightYAxisData.aligned = xAxisData.aligned;
            axesData.rightYAxis = rightYAxisData;
        }

        return axesData;
    },

    /**
     * Increase y axis tick count.
     * @param {number} increaseTickCount increase tick count
     * @param {object} toData to tick info
     * @param {Array.<function>} formatFunctions format functions
     * @private
     */
    _increaseYAxisTickCount: function(increaseTickCount, toData, formatFunctions) {
        toData.limit.max += toData.step * increaseTickCount;
        toData.labels = axisDataMaker.formatLabels(calculator.makeLabelsFromLimit(toData.limit, toData.step), formatFunctions);
        toData.tickCount += increaseTickCount;
        toData.validTickCount += increaseTickCount;
    },

    /**
     * On change selected legend.
     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
     */
    onChangeCheckedLegends: function(checkedLegends) {
        var rawData = this._filterRawData(this.rawData, checkedLegends),
            chartTypesMap = this._makeChartTypesMap(rawData.series, this.options.yAxis);

        tui.util.extend(this, chartTypesMap);

        ChartBase.prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, chartTypesMap);
    }
});

axisTypeMixer.mixin(ComboChart);

module.exports = ComboChart;

},{"../helpers/axisDataMaker":33,"../helpers/calculator":35,"../series/columnChartSeries":67,"../series/lineChartSeries":68,"../themes/defaultTheme":75,"./axisTypeMixer":5,"./chartBase":8}],11:[function(require,module,exports){
/**
 * @fileoverview ComponentManager manages components of chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ComponentManager = tui.util.defineClass(/** @lends ComponentManager.prototype */ {
    /**
     * ComponentManager manages components of chart.
     * @param {object} params parameters
     *      @param {object} params.theme theme
     *      @param {object} params.options options
     *      @param {DataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs ComponentManager
     */
    init: function(params) {
        /**
         * Components
         * @type {Array.<object>}
         */
        this.components = [];

        /**
         * Component map.
         * @type {object}
         */
        this.componentMap = {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;
    },

    /**
     * Register component.
     * The component refers to a component of the chart.
     * The component types are axis, legend, plot, series and customEvent.
     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif
     * @param {string} name component name
     * @param {function} Component component constructor
     * @param {object} params component parameters
     */
    register: function(name, Component, params) {
        var options, index, theme,
            component, componentType;

        params = params || {};

        componentType = params.componentType || name;
        options = params.options || this.options[componentType];
        theme = params.theme || this.theme[componentType];
        index = params.index || 0;

        params.theme = theme;
        params.options = tui.util.isArray(options) ? options[index] : options || {};
        params.dataProcessor = this.dataProcessor;
        params.boundsMaker = this.boundsMaker;
        params.hasAxes = this.hasAxes;

        component = new Component(params);
        component.name = name;
        component.componentType = componentType;

        this.components.push(component);
        this.componentMap[name] = component;
    },

    /**
     * Iterate each components.
     * @param {function} iteratee iteratee
     */
    each: function(iteratee) {
        tui.util.forEachArray(this.components, iteratee);
    },

    /**
     * Return the results of applying the iteratee to each components.
     *  @param {function} iteratee iteratee
     * @returns {Array.<object>} components
     */
    map: function(iteratee) {
        return tui.util.map(this.components, iteratee);
    },

    /**
     * Find components to conditionMap.
     * @param {object} conditionMap condition map
     * @returns {Array.<object>} filtered components
     */
    where: function(conditionMap) {
        return tui.util.filter(this.components, function(component) {
            var contained = true;

            tui.util.forEach(conditionMap, function(value, key) {
                if (component[key] !== value) {
                    contained = false;
                    return false;
                }
            });

            return contained;
        });
    },

    /**
     * Get component.
     * @param {string} name component name
     * @returns {object} component instance
     */
    get: function(name) {
        return this.componentMap[name];
    }
});

module.exports = ComponentManager;

},{}],12:[function(require,module,exports){
/**
 * @fileoverview Line chart
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    lineTypeMixer = require('./lineTypeMixer'),
    axisTypeMixer = require('./axisTypeMixer'),
    Series = require('../series/lineChartSeries');

var LineChart = tui.util.defineClass(ChartBase, /** @lends LineChart.prototype */ {
    /**
     * className
     * @type {string}
     */
    className: 'tui-line-chart',

    /**
     * Series class
     * @type {function}
     */
    Series: Series,

    /**
     * Line chart.
     * @constructs LineChart
     * @extends ChartBase
     * @mixes axisTypeMixer
     * @mixes verticalTypeMixer
     * @mixes lineTypeMixer
     */
    init: function() {
        this._lineTypeInit.apply(this, arguments);
    }
});

axisTypeMixer.mixin(LineChart);
lineTypeMixer.mixin(LineChart);

module.exports = LineChart;

},{"../series/lineChartSeries":68,"./axisTypeMixer":5,"./chartBase":8,"./lineTypeMixer":13}],13:[function(require,module,exports){
/**
 * @fileoverview lineTypeMixer is mixer of line type chart(line, area).
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    predicate = require('../helpers/predicate'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    AreaTypeCustomEvent = require('../customEvents/areaTypeCustomEvent');

/**
 * lineTypeMixer is mixer of line type chart(line, area).
 * @mixin
 */
var lineTypeMixer = {
    /**
     * Initialize line type chart.
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     * @param {object} initedData initialized data from combo chart
     * @private
     */
    _lineTypeInit: function(rawData, theme, options) {
        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            hasAxes: true,
            isVertical: true
        });

        this._addComponents(options.chartType);
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        var options = this.options,
            aligned = predicate.isLineTypeChart(options.chartType),
            xAxisData = axisDataMaker.makeLabelAxisData({
                labels: this.dataProcessor.getCategories(),
                aligned: aligned,
                options: options.xAxis
            }),
            yAxisData = axisDataMaker.makeValueAxisData({
                values: this.dataProcessor.getGroupValues(),
                seriesDimension: {
                    height: this.boundsMaker.makeSeriesHeight()
                },
                stackedOption: options.series && options.series.stacked || '',
                chartType: options.chartType,
                formatFunctions: this.dataProcessor.getFormatFunctions(),
                options: options.yAxis,
                isVertical: true,
                aligned: aligned
            });

        return {
            xAxis: xAxisData,
            yAxis: yAxisData
        };
    },

    /**
     * Add custom event component for normal tooltip.
     * @private
     */
    _addCustomEventComponentForNormalTooltip: function() {
        this.componentManager.register('customEvent', AreaTypeCustomEvent, {
            chartType: this.chartType,
            isVertical: this.isVertical
        });
    },

    /**
     * Add components
     * @param {string} chartType chart type
     * @private
     */
    _addComponents: function(chartType) {
        this._addComponentsForAxisType({
            axes: [
                {
                    name: 'yAxis'
                },
                {
                    name: 'xAxis',
                    isLabel: true
                }
            ],
            chartType: chartType,
            serieses: [
                {
                    name: this.options.chartType + 'Series',
                    SeriesClass: this.Series
                }
            ]
        });
    },

    /**
     * Render
     * @returns {HTMLElement} chart element
     */
    render: function() {
        return ChartBase.prototype.render.apply(this, arguments);
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = lineTypeMixer;

},{"../customEvents/areaTypeCustomEvent":20,"../helpers/axisDataMaker":33,"../helpers/predicate":41,"./chartBase":8}],14:[function(require,module,exports){
/**
 * @fileoverview Map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    MapChartMapModel = require('./mapChartMapModel'),
    MapChartColorModel = require('./mapChartColorModel'),
    MapChartDataProcessor = require('../helpers/mapChartDataProcessor'),
    axisDataMaker = require('../helpers/axisDataMaker'),
    Series = require('../series/mapChartSeries'),
    Zoom = require('../series/zoom'),
    Legend = require('../legends/mapChartLegend'),
    MapChartTooltip = require('../tooltips/mapChartTooltip'),
    mapChartCustomEvent = require('../customEvents/mapChartCustomEvent');

var MapChart = tui.util.defineClass(ChartBase, /** @lends MapChart.prototype */ {
    /**
     * Map chart.
     * @constructs MapChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        /**
         * class name
         * @type {string}
         */
        this.className = 'tui-map-chart';

        options.tooltip = options.tooltip || {};
        options.legend = options.legend || {};

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options,
            DataProcessor: MapChartDataProcessor
        });

        this._addComponents(options);
    },

    /**
     * Add components
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(options) {
        options.legend = options.legend || {};

        this.componentManager.register('legend', Legend);

        this.componentManager.register('tooltip', MapChartTooltip, this._makeTooltipData());

        this.componentManager.register('mapSeries', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            userEvent: this.userEvent
        });
        this.componentManager.register('zoom', Zoom);
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        this.componentManager.register('customEvent', mapChartCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Make axes data
     * @returns {object} axes data
     * @private
     */
    _makeAxesData: function() {
        return axisDataMaker.makeValueAxisData({
            values: [this.dataProcessor.getValues()],
            seriesDimension: {
                height: this.boundsMaker.getDimension('legend').height
            },
            chartType: this.options.chartType,
            formatFunctions: this.dataProcessor.getFormatFunctions(),
            tickCount: chartConst.MAP_CHART_LEGEND_TICK_COUNT,
            isVertical: true
        });
    },

    /**
     * Update percent values.
     * @param {object} axesData axes data
     * @private
     * @override
     */
    _updatePercentValues: function(axesData) {
        this.dataProcessor.registerPercentValues(axesData.limit);
    },

    /**
     * Make rendering data for map chart.
     * @param {object} axesData axes data
     * @returns {object} data for rendering
     * @private
     * @override
     */
    _makeRenderingData: function(axesData) {
        var seriesTheme = this.theme.series,
            colorModel = new MapChartColorModel(seriesTheme.startColor, seriesTheme.endColor),
            mapModel = new MapChartMapModel(this.dataProcessor, this.options.map);

        return {
            legend: {
                colorModel: colorModel,
                axesData: axesData
            },
            mapSeries: {
                mapModel: mapModel,
                colorModel: colorModel
            },
            tooltip: {
                mapModel: mapModel
            }
        };
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var customEvent = this.componentManager.get('customEvent'),
            mapSeries = this.componentManager.get('mapSeries'),
            legend = this.componentManager.get('legend'),
            tooltip = this.componentManager.get('tooltip'),
            zoom = this.componentManager.get('zoom');

        customEvent.on({
            clickMapSeries: mapSeries.onClickSeries,
            moveMapSeries: mapSeries.onMoveSeries,
            dragStartMapSeries: mapSeries.onDragStartSeries,
            dragMapSeries: mapSeries.onDragSeries,
            dragEndMapSeries: mapSeries.onDragEndSeries
        }, mapSeries);

        mapSeries.on({
            showWedge: legend.onShowWedge,
            hideWedge: legend.onHideWedge
        }, legend);

        mapSeries.on({
            showTooltip: tooltip.onShow,
            hideTooltip: tooltip.onHide,
            showTooltipContainer: tooltip.onShowTooltipContainer,
            hideTooltipContainer: tooltip.onHideTooltipContainer
        }, tooltip);

        zoom.on('zoom', mapSeries.onZoom, mapSeries, mapSeries);
    }
});

module.exports = MapChart;

},{"../const":19,"../customEvents/mapChartCustomEvent":24,"../helpers/axisDataMaker":33,"../helpers/mapChartDataProcessor":40,"../legends/mapChartLegend":49,"../series/mapChartSeries":70,"../series/zoom":74,"../tooltips/mapChartTooltip":78,"./chartBase":8,"./mapChartColorModel":15,"./mapChartMapModel":16}],15:[function(require,module,exports){
/**
 * @fileoverview MapChartColorModel is color model for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var colorutil = require('../helpers/colorutil');

var MapChartColorModel = tui.util.defineClass(/** @lends MapChartColorModel.prototype */ {
    /**
     * MapChartColorModel is legend model.
     * @constructs MapChartColorModel
     * @param {string} startColor hex color
     * @param {string} endColor hex color
     */
    init: function(startColor, endColor) {
        var endRGB;

        this.start = colorutil.colorNameToHex(startColor);
        this.startRGB = colorutil.hexToRGB(this.start);
        this.end = colorutil.colorNameToHex(endColor);

        endRGB = colorutil.hexToRGB(this.end);
        this.distances = this._makeDistances(this.startRGB, endRGB);
        this.colorMap = {};
    },

    /**
     * Make distances start RGB to end RGB.
     * @param {Array.<number>} startRGB start RGB
     * @param {Array.<number>} endRGB end RGB
     * @returns {Array.<number>} distances
     * @private
     */
    _makeDistances: function(startRGB, endRGB) {
        return tui.util.map(startRGB, function(value, index) {
            return endRGB[index] - value;
        });
    },

    /**
     * Get hex color.
     * @param {number} ratio ratio
     * @returns {string} hex color
     */
    getColor: function(ratio) {
        var hexColor = this.colorMap[ratio],
            distances, rgbColor;

        if (!hexColor) {
            distances = this.distances;
            rgbColor = tui.util.map(this.startRGB, function (start, index) {
                return start + parseInt(distances[index] * ratio, 10);
            });
            hexColor = colorutil.rgbToHEX.apply(null, rgbColor);
        }

        return hexColor;
    }
});

module.exports = MapChartColorModel;

},{"../helpers/colorutil":36}],16:[function(require,module,exports){
/**
 * @fileoverview MapChartMapModel is map model of map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var MapChartMapModel = tui.util.defineClass(/** @lends MapChartMapModel.prototype */ {
    /**
     * MapChartMapModel is map model of map chart.
     * @constructs MapChartMapModel
     * @param {MapChartDataProcessor} dataProcessor Map chart data processor
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     */
    init: function(dataProcessor, rawMapData) {
        /**
         * Command function map.
         * @type {{
         *      M: MapChartMapModel._makeCoordinate, m: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      L: MapChartMapModel._makeCoordinate, l: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
         *      H: MapChartMapModel._makeXCoordinate, h: MapChartMapModel._makeXCoordinateFroRelativeCoordinate,
         *      V: MapChartMapModel._makeYCoordinate, v: MapChartMapModel._makeYCoordinateFromRelativeCoordinate
         * }}
         */
        this.commandFuncMap = {
            M: tui.util.bind(this._makeCoordinate, this),
            m: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            L: tui.util.bind(this._makeCoordinate, this),
            l: tui.util.bind(this._makeCoordinateFromRelativeCoordinate, this),
            H: tui.util.bind(this._makeXCoordinate, this),
            h: tui.util.bind(this._makeXCoordinateFroRelativeCoordinate, this),
            V: tui.util.bind(this._makeYCoordinate, this),
            v: tui.util.bind(this._makeYCoordinateFromRelativeCoordinate, this)
        };

        /**
         * Ignore command map.
         * @type {{Z: boolean, z: boolean}}
         */
        this.ignoreCommandMap = {
            Z: true,
            z: true
        };

        /**
         * Map data.
         * @type {Array}
         */
        this.mapData = [];

        /**
         * Map dimension
         * @type {{width: number, height: number}}
         */
        this.mapDimension = null;

        /**
         * Map chart data processor.
         * @type {MapChartDataProcessor}
         */
        this.dataProcessor = dataProcessor;

        this._createMapData(rawMapData);
    },

    /**
     * Split coordinate string.
     * @param {string} coordinateStr coordinate string
     * @returns {{x: number, y: number}} coordinate map
     * @private
     */
    _splitCoordinate: function(coordinateStr) {
        var coordinates = coordinateStr.split(','),
            result = {
                x: parseFloat(coordinates[0])
            };

        if (coordinates[1]) {
            result.y = parseFloat(coordinates[1]);
        }

        return result;
    },

    /**
     * Make coordinate
     * @param {string} coordinateStr coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinate: function(coordinateStr) {
        return this._splitCoordinate(coordinateStr);
    },

    /**
     * Make coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number, y: number}} coordinate
     * @private
     */
    _makeCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x,
            y: coordinate.y + prevCoordinate.y
        };
    },

    /**
     * Make x coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x
        };
    },

    /**
     * Make x coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{x: number}} x coordinate
     * @private
     */
    _makeXCoordinateFroRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            x: coordinate.x + prevCoordinate.x
        };
    },

    /**
     * Make y coordinate.
     * @param {string} coordinateStr coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinate: function(coordinateStr) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x
        };
    },

    /**
     * Make y coordinate from relative coordinate.
     * @param {string} coordinateStr coordinate
     * @param {{x: number, y: number}} prevCoordinate previous coordinate
     * @returns {{y: number}} y coordinate
     * @private
     */
    _makeYCoordinateFromRelativeCoordinate: function(coordinateStr, prevCoordinate) {
        var coordinate = this._splitCoordinate(coordinateStr);

        return {
            y: coordinate.x + prevCoordinate.y
        };
    },

    /**
     * Split path.
     * @param {string} path path
     * @returns {Array.<{type: string, coordinate: string}>} splitted path data
     * @private
     */
    _splitPath: function(path) {
        var i = 0,
            len = path.length,
            pathData = [],
            coordinate = '',
            chr, commandType;

        for (; i < len; i += 1) {
            chr = path.charAt(i);
            if (this.commandFuncMap[chr]) {
                if (commandType && coordinate) {
                    pathData.push({
                        type: commandType,
                        coordinate: coordinate
                    });
                }
                commandType = chr;
                coordinate = '';
            } else if (!this.ignoreCommandMap[chr]) {
                coordinate += chr;
            }
        }

        if (commandType && coordinate) {
            pathData.push({
                type: commandType,
                coordinate: coordinate
            });
        }

        return pathData;
    },

    /**
     * Make coordinates from path.
     * @param {string} path path
     * @returns {Array.<{x: number, y: number}>} coordinates
     * @private
     */
    _makeCoordinatesFromPath: function(path) {
        var pathData = this._splitPath(path),
            prevCoordinate = {
                x: 0,
                y: 0
            };

        return tui.util.map(pathData, function(datum) {
            var commandFunc = this.commandFuncMap[datum.type],
                coordinate = commandFunc(datum.coordinate, prevCoordinate);

            tui.util.extend(prevCoordinate, coordinate);

            return coordinate;
        }, this);
    },

    /**
     * Find bound from coordinates.
     * @param {Array.<{left: number, top: number}>} coordinates coordinates
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound
     * @private
     */
    _findBoundFromCoordinates: function(coordinates) {
        var xs = tui.util.filter(tui.util.pluck(coordinates, 'x'), function(x) {
                return !tui.util.isUndefined(x);
            }),
            ys = tui.util.filter(tui.util.pluck(coordinates, 'y'), function(y) {
                return !tui.util.isUndefined(y);
            }),
            maxLeft = Math.max.apply(null, xs),
            minLeft = Math.min.apply(null, xs),
            maxTop = Math.max.apply(null, ys),
            minTop = Math.min.apply(null, ys);

        return {
            dimension: {
                width: maxLeft - minLeft,
                height: maxTop - minTop
            },
            position: {
                left: minLeft,
                top: minTop
            }
        };
    },

    /**
     * Make label position.
     * @param {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound bound
     * @param {?{left: number, top: number}} positionRatio position ratio
     * @returns {{left: number, top: number}} label position
     * @private
     */
    _makeLabelPosition: function(bound, positionRatio) {
        positionRatio = positionRatio || chartConst.MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;

        return {
            left: bound.position.left + (bound.dimension.width * positionRatio.x),
            top: bound.position.top + (bound.dimension.height * positionRatio.y)
        };
    },

    /**
     * Create map data.
     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
     * @private
     */
    _createMapData: function(rawMapData) {
        this.mapData = tui.util.map(rawMapData, function(datum) {
            var coordinate = this._makeCoordinatesFromPath(datum.path),
                bound = this._findBoundFromCoordinates(coordinate),
                userData = this.dataProcessor.getValueMapDatum(datum.code),
                name, labelCoordinate, formattedValue, percentValue, resultData;

            if (userData) {
                formattedValue = userData.formattedValue;
                percentValue = userData.percentValue;
                name = userData.name || datum.name;
                labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;
            }

            resultData = {
                code: datum.code,
                name: name,
                path: datum.path,
                bound: bound,
                labelPosition: this._makeLabelPosition(bound, labelCoordinate)
            };

            if (formattedValue) {
                resultData.formattedValue = formattedValue;
            }

            if (percentValue) {
                resultData.percentValue = percentValue;
            }

            return resultData;
        }, this);
    },

    getMapData: function() {
        return this.mapData;
    },

    getDatum: function(index) {
        return this.mapData[index];
    },

    /**
     * Get label data.
     * @param {number} ratio ratio
     * @returns {Array.<{name: string, bound: {dimension: {width: number, height: number}, position: {top: number, left: number}}, labelPosition: {width: number, height: number}}>} map data
     */
    getLabelData: function(ratio) {
        var labelData = tui.util.filter(this.mapData, function(datum) {
                return this.dataProcessor.getValueMapDatum(datum.code);
            }, this);

        return tui.util.map(labelData, function(datum) {
            return {
                name: datum.name,
                labelPosition: {
                    left: datum.labelPosition.left * ratio,
                    top: datum.labelPosition.top * ratio
                }
            };
        });
    },

    /**
     * Make map dimension
     * @returns {{width: number, height: number}} map dimension
     * @private
     */
    _makeMapDimension: function() {
        var mapData = this.mapData,
            lefts = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left;
            }),
            rights = tui.util.map(mapData, function(datum) {
                return datum.bound.position.left + datum.bound.dimension.width;
            }),
            tops = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top;
            }),
            bottoms = tui.util.map(mapData, function(datum) {
                return datum.bound.position.top + datum.bound.dimension.height;
            });
        return {
            width: Math.max.apply(null, rights) - Math.min.apply(null, lefts),
            height: Math.max.apply(null, bottoms) - Math.min.apply(null, tops)
        };
    },

    /**
     * Get map dimension.
     * @returns {{width: number, height: number}} map dimension
     */
    getMapDimension: function() {
        if (!this.mapDimension) {
            this.mapDimension = this._makeMapDimension();
        }

        return this.mapDimension;
    }
});

module.exports = MapChartMapModel;

},{"../const":19}],17:[function(require,module,exports){
/**
 * @fileoverview Pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var ChartBase = require('./chartBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    Legend = require('../legends/legend'),
    Tooltip = require('../tooltips/tooltip'),
    Series = require('../series/pieChartSeries'),
    PieChartCustomEvent = require('../customEvents/pieChartCustomEvent');

var PieChart = tui.util.defineClass(ChartBase, /** @lends PieChart.prototype */ {
    /**
     * Column chart.
     * @constructs PieChart
     * @extends ChartBase
     * @param {Array.<Array>} rawData raw data
     * @param {object} theme chart theme
     * @param {object} options chart options
     */
    init: function(rawData, theme, options) {
        this.className = 'tui-pie-chart';

        options.tooltip = options.tooltip || {};

        if (!options.tooltip.align) {
            options.tooltip.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }

        ChartBase.call(this, {
            rawData: rawData,
            theme: theme,
            options: options
        });

        this._addComponents(theme.chart.background, options);
    },

    /**
     * Add components
     * @param {object} chartBackground chart background
     * @param {object} options chart options
     * @private
     */
    _addComponents: function(chartBackground, options) {
        var legendAlign, isPieLegendType;
        options.legend = options.legend || {};
        legendAlign = options.legend && options.legend.align;
        isPieLegendType = predicate.isPieLegendAlign(legendAlign);

        if (!isPieLegendType && !options.legend.hidden) {
            this.componentManager.register('legend', Legend, {
                chartType: options.chartType,
                userEvent: this.userEvent
            });
        }

        this.componentManager.register('tooltip', Tooltip, this._makeTooltipData());

        this.componentManager.register('pieSeries', Series, {
            libType: options.libType,
            chartType: options.chartType,
            componentType: 'series',
            chartBackground: chartBackground,
            userEvent: this.userEvent,
            legendAlign: isPieLegendType && !options.legend.hidden ? legendAlign : null
        });
    },

    /**
     * Add custom event component.
     * @private
     */
    _addCustomEventComponent: function() {
        this.componentManager.register('customEvent', PieChartCustomEvent, {
            chartType: this.chartType
        });
    },

    /**
     * Update percent values.
     * @private
     * @override
     */
    _updatePercentValues: function() {
        this.dataProcessor.registerPieChartPercentValues(this.options.chartType);
    },

    /**
     * Attach custom evnet.
     * @private
     * @override
     */
    _attachCustomEvent: function() {
        var customEvent, tooltip, pieSeries;

        ChartBase.prototype._attachCustomEvent.call(this);

        customEvent = this.componentManager.get('customEvent');
        tooltip = this.componentManager.get('tooltip');
        pieSeries = this.componentManager.get('pieSeries');

        customEvent.on({
            clickPieSeries: pieSeries.onClickSeries,
            movePieSeries: pieSeries.onMoveSeries
        }, pieSeries);

        pieSeries.on({
            showTooltip: tooltip.onShow,
            hideTooltip: tooltip.onHide,
            showTooltipContainer: tooltip.onShowTooltipContainer,
            hideTooltipContainer: tooltip.onHideTooltipContainer
        }, tooltip);
    }
});

module.exports = PieChart;

},{"../const":19,"../customEvents/pieChartCustomEvent":25,"../helpers/predicate":41,"../legends/legend":45,"../series/pieChartSeries":71,"../tooltips/tooltip":80,"./chartBase":8}],18:[function(require,module,exports){
'use strict';

/**
 * Pick minimum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} minimum value
 */
var min = function(arr, condition, context) {
    var result, minValue, rest;
    if (!condition) {
        condition = function(item) {
            return item;
        };
    }
    result = arr[0];
    minValue = condition.call(context, result);
    rest = arr.slice(1);
    tui.util.forEachArray(rest, function(item) {
        var compareValue = condition.call(context, item);
        if (compareValue < minValue) {
            minValue = compareValue;
            result = item;
        }
    });
    return result;
};

/**
 * Pick maximum value from value array.
 * @param {Array} arr value array
 * @param {?function} condition condition function
 * @param {?object} context target context
 * @returns {*} maximum value
 */
var max = function(arr, condition, context) {
    var result, maxValue, rest;
    if (!condition) {
        condition = function(item) {
            return item;
        };
    }
    result = arr[0];
    maxValue = condition.call(context, result);
    rest = arr.slice(1);
    tui.util.forEachArray(rest, function(item) {
        var compareValue = condition.call(context, item);
        if (compareValue > maxValue) {
            maxValue = compareValue;
            result = item;
        }
    });
    return result;
};

/**
 * Whether one of them is true or not.
 * @param {Array} arr target array
 * @param {function} condition condition function
 * @param {?object} context target context
 * @returns {boolean} result boolean
 */
var any = function(arr, condition, context) {
    var result = false;
    tui.util.forEachArray(arr, function(item, index) {
        if (condition.call(context, item, index, arr)) {
            result = true;
            return false;
        }
    });
    return result;
};

/**
 * All of them is true or not.
 * @param {Array} arr target array
 * @param {function} condition condition function
 * @param {[object]} context target context
 * @returns {boolean} result boolean
 */
var all = function(arr, condition, context) {
    var result = true;
    tui.util.forEachArray(arr, function(item, index) {
        if (!condition.call(context, item, index, arr)) {
            result = false;
            return false;
        }
    });
    return result;
};

/**
 * Make unique values.
 * @param {Array} arr target array
 * @param {?boolean} sorted whether sorted or not.
 * @param {?function} iteratee iteratee function
 * @param {?object} context target context
 * @returns {Array} unique values
 */
var unique = function(arr, sorted, iteratee, context) {
    var result = [],
        prevValue;

    if (!tui.util.isBoolean(sorted)) {
        context = iteratee;
        iteratee = sorted;
        sorted = false;
    }

    iteratee = iteratee || function(value) {
        return value;
    };

    if (sorted) {
        tui.util.forEachArray(arr, function (value, index) {
            value = iteratee.call(context, value, index, arr);
            if (!index || prevValue !== value) {
                result.push(value);
            }
            prevValue = value;
        });
    } else {
        tui.util.forEachArray(arr, function(value, index) {
            value = iteratee.call(context, value, index, arr);
            if (tui.util.inArray(value, result) === -1) {
                result.push(value);
            }
        });
    }

    return result;
};

/**
 * Array pivot.
 * @memberOf module:calculator
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */
var pivot = function(arr2d) {
    var result = [];
    tui.util.forEachArray(arr2d, function(arr) {
        tui.util.forEachArray(arr, function(value, index) {
            if (!result[index]) {
                result[index] = [];
            }
            result[index].push(value);
        });
    });
    return result;
};

/**
 * Get after point length.
 * @param {string | number} value target value
 * @returns {number} result length
 */
var lengthAfterPoint = function(value) {
    var valueArr = (value + '').split('.');
    return valueArr.length === 2 ? valueArr[1].length : 0;
};

/**
 * Find multiple num.
 * @param {...Array} target values
 * @returns {number} multiple num
 */
var findMultipleNum = function() {
    var args = [].slice.call(arguments),
        underPointLens = tui.util.map(args, function(value) {
            return tui.util.lengthAfterPoint(value);
        }),
        underPointLen = tui.util.max(underPointLens),
        multipleNum = Math.pow(10, underPointLen);
    return multipleNum;
};

/**
 * Modulo operation for floating point operation.
 * @param {number} target target values
 * @param {number} modNum mod num
 * @returns {number} result mod
 */
var mod = function(target, modNum) {
    var multipleNum = tui.util.findMultipleNum(modNum);
    return ((target * multipleNum) % (modNum * multipleNum)) / multipleNum;
};

/**
 * Addition for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} addition result
 */
var addition = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) + (b * multipleNum)) / multipleNum;
};

/**
 * Subtraction for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} subtraction result
 */
var subtraction = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) - (b * multipleNum)) / multipleNum;
};

/**
 * Multiplication for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} multiplication result
 */
var multiplication = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return ((a * multipleNum) * (b * multipleNum)) / (multipleNum * multipleNum);
};

/**
 * Division for floating point operation.
 * @param {number} a target a
 * @param {number} b target b
 * @returns {number} division result
 */
var division = function(a, b) {
    var multipleNum = findMultipleNum(a, b);
    return (a * multipleNum) / (b * multipleNum);
};

/**
 * Sum.
 * @param {Array.<number>} values target values
 * @returns {number} result value
 */
var sum = function(values) {
    var copyArr = values.slice();
    copyArr.unshift(0);
    return tui.util.reduce(copyArr, function(base, add) {
        return parseFloat(base) + parseFloat(add);
    });
};


var properCase = function(str) {
    return str.substring(0, 1).toUpperCase() + str.substring(1);
};

tui.util.min = min;
tui.util.max = max;
tui.util.any = any;
tui.util.all = all;
tui.util.unique = unique;
tui.util.pivot = pivot;
tui.util.lengthAfterPoint = lengthAfterPoint;
tui.util.mod = mod;
tui.util.findMultipleNum = findMultipleNum;
tui.util.addition = addition;
tui.util.subtraction = subtraction;
tui.util.multiplication = multiplication;
tui.util.division = division;
tui.util.sum = sum;
tui.util.properCase = properCase;

var aps = Array.prototype.slice;

/**
 * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
 * since the last time the debouced function was invoked.
 * @param {function} fn The function to debounce.
 * @param {number} [delay=0] The number of milliseconds to delay
 * @memberof tui.util
 * @returns {function} debounced function.
 * @example
 *
 * function someMethodToInvokeDebounced() {}
 *
 * var debounced = tui.util.debounce(someMethodToInvokeDebounced, 300);
 *
 * // invoke repeatedly
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();    // last invoke of debounced()
 *
 * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
 */
function debounce(fn, delay) {
    var timer,
        args;

    /* istanbul ignore next */
    delay = delay || 0;

    function debounced() {
        args = aps.call(arguments);

        window.clearTimeout(timer);
        timer = window.setTimeout(function() {
            fn.apply(null, args);
        }, delay);
    }

    return debounced;
}

/**
 * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
 *
 * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
 *
 * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
 * @param {function} fn function to throttle
 * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
 * @memberof tui.util
 * @returns {function} throttled function
 * @example
 *
 * function someMethodToInvokeThrottled() {}
 *
 * var throttled = tui.util.throttle(someMethodToInvokeThrottled, 300);
 *
 * // invoke repeatedly
 * throttled();    // invoke (leading)
 * throttled();
 * throttled();    // invoke (near 300 milliseconds)
 * throttled();
 * throttled();
 * throttled();    // invoke (near 600 milliseconds)
 * // ...
 * // invoke (trailing)
 *
 * // if you need reuse throttled method. then invoke reset()
 * throttled.reset();
 */
function throttle(fn, interval) {
    var base,
        _timestamp = tui.util.timestamp,
        debounced,
        isLeading = true,
        stamp,
        args,
        tick = function(_args) {
            fn.apply(null, _args);
            base = null;
        };

    /* istanbul ignore next */
    interval = interval || 0;

    debounced = tui.util.debounce(tick, interval);

    function throttled() {
        args = aps.call(arguments);

        if (isLeading) {
            tick(args);
            isLeading = false;
            return;
        }

        stamp = _timestamp();

        base = base || stamp;

        debounced(args);

        if ((stamp - base) >= interval) {
            tick(args);
        }
    }

    function reset() {
        isLeading = true;
        base = null;
    }

    throttled.reset = reset;
    return throttled;
}

tui.util.debounce = debounce;
tui.util.throttle = throttle;

},{}],19:[function(require,module,exports){
/**
 * @fileoverview Chart const
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

/**
 * Chart const
 * @readonly
 * @enum {number}
 */
var chartConst = {
    /** tui class names
     * @type {string}
     */
    CLASS_NAME_LEGEND_LABEL: 'tui-chart-legend-label',
    /** @type {string} */
    CLASS_NAME_LEGEND_CHECKBOX: 'tui-chart-legend-checkbox',
    /** @type {string} */
    CLASS_NAME_SERIES_LABEL: 'tui-chart-series-label',
    /** @type {string} */
    CLASS_NAME_SERIES_LEGEND: 'tui-chart-series-legend',
    /** chart types
     * @type {string}
     */
    CHART_TYPE_BAR: 'bar',
    /** @type {string} */
    CHART_TYPE_COLUMN: 'column',
    /** @type {string} */
    CHART_TYPE_LINE: 'line',
    /** @type {string} */
    CHART_TYPE_AREA: 'area',
    /** @type {string} */
    CHART_TYPE_COMBO: 'combo',
    /** @type {string} */
    CHART_TYPE_PIE: 'pie',
    /** @type {string} */
    CHART_TYPE_MAP: 'map',
    /** chart padding */
    CHART_PADDING: 10,
    /** chart default width */
    CHART_DEFAULT_WIDTH: 500,
    /** chart default height */
    CHART_DEFAULT_HEIGHT: 400,
    /** hidden width */
    HIDDEN_WIDTH: 1,
    /** rendered text padding */
    TEXT_PADDING: 2,
    /** series expand size */
    SERIES_EXPAND_SIZE: 10,
    /** series label padding */
    SERIES_LABEL_PADDING: 5,
    /** default font size of title */
    DEFAULT_TITLE_FONT_SIZE: 14,
    /** default font size of axis title */
    DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
    /** default font size of label */
    DEFAULT_LABEL_FONT_SIZE: 12,
    /** default font size of series label */
    DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
    /** default graph plugin
     * @type {string}
     */
    DEFAULT_PLUGIN: 'raphael',
    /** default tick color
     * @type {string}
     */
    DEFAULT_TICK_COLOR: 'black',
    /** default theme name
     * @type {string}
     */
    DEFAULT_THEME_NAME: 'default',
    MAX_HEIGHT_WORLD: 'A',
    /** stacked option types
     * @type {string}
     */
    STACKED_NORMAL_TYPE: 'normal',
    /** @type {string} */
    STACKED_PERCENT_TYPE: 'percent',
    /** empty axis label */
    EMPTY_AXIS_LABEL: '',
    /** angel */
    ANGLE_85: 85,
    ANGLE_90: 90,
    ANGLE_360: 360,
    /** radian */
    RAD: Math.PI / 180,
    /** series legend aligns
     * @type {string}
     */
    LEGEND_ALIGN_OUTER: 'outer',
    /** @type {string} */
    LEGEND_ALIGN_CENTER: 'center',
    /** @type {string} */
    LEGEND_ALIGN_TOP: 'top',
    /** @type {string} */
    LEGEND_ALIGN_BOTTOM: 'bottom',
    /** @type {string} */
    LEGEND_ALIGN_LEFT: 'left',
    /** series outer label padding */
    SERIES_OUTER_LABEL_PADDING: 20,
    /** default rate of pie graph */
    PIE_GRAPH_DEFAULT_RATE: 0.8,
    /** small rate of pie graph */
    PIE_GRAPH_SMALL_RATE: 0.65,
    /** tick count for map chart legend */
    MAP_CHART_LEGEND_TICK_COUNT: 4,
    /** default position ratio of map chart label
     * @type {object}
     */
    MAP_CHART_LABEL_DEFAULT_POSITION_RATIO: {
        x: 0.5,
        y: 0.5
    },
    /** dot radius */
    DOT_RADIUS: 4,
    /** yAxis properties
     * @type {Array.<string>}
     */
    YAXIS_PROPS: ['tickColor', 'title', 'label'], // yaxis theme의 속성 - chart type filtering할 때 사용됨
    /** series properties
     * @type {Array.<string>}
     */
    SERIES_PROPS: ['label', 'colors', 'borderColor', 'singleColors',
        'selectionColor', 'startColor', 'endColor', 'overColor'], // series theme의 속성 - chart type filtering할 때 사용됨
    /** title area width padding */
    TITLE_AREA_WIDTH_PADDING: 20,
    /** top margin of x axis label */
    XAXIS_LABEL_TOP_MARGIN: 10,
    /** right padding of vertical label */
    V_LABEL_RIGHT_PADDING: 10,
    /** tooltip prefix
     * @type {string}
     */
    TOOLTIP_PREFIX: 'tui-chart-tooltip',
    /** tooltip z-index **/
    TOOLTIP_ZINDEX: 500,
    /** tooltip animation time */
    TOOLTIP_ANIMATION_TIME: 100,
    /** tooltip animation time for pie chart */
    TOOLTIP_PIE_ANIMATION_TIME: 50,
    /** minimum pixel type step size */
    MIN_PIXEL_TYPE_STEP_SIZE: 40,
    /** maximum pixel type step size */
    MAX_PIXEL_TYPE_STEP_SIZE: 60,
    /** tick info of percent stacked option
     * @type {object}
     */
    PERCENT_STACKED_TICK_INFO: {
        limit: {
            min: 0,
            max: 100
        },
        step: 25,
        tickCount: 5,
        labels: [0, 25, 50, 75, 100]
    },
    /** tick info of negative percent stacked option
     * @type {object}
     */
    NEGATIVE_PERCENT_STACKED_TICK_INFO: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        tickCount: 9,
        labels: [-100, -75, -50, -25, 0, 25, 50, 75, 100]
    },
    /** tick info of diverging percent stacked option
     * @type {object}
     */
    DIVERGENT_PERCENT_STACKED_TICK_INFO: {
        limit: {
            min: -100,
            max: 100
        },
        step: 25,
        tickCount: 9,
        labels: [100, 75, 50, 25, 0, 25, 50, 75, 100]
    },
    /** title add padding */
    TITLE_PADDING: 20,
    /** legend area padding */
    LEGEND_AREA_PADDING: 10,
    /** legend checkbox width */
    LEGEND_CHECKBOX_WIDTH: 20,
    /** legend rect width */
    LEGEND_RECT_WIDTH: 12,
    /** lgend label left padding */
    LEGEND_LABEL_LEFT_PADDING: 5,
    /** map legend height */
    MAP_LEGEND_SIZE: 200,
    /** map legend graph size */
    MAP_LEGEND_GRAPH_SIZE: 25,
    /** map legend label padding */
    MAP_LEGEND_LABEL_PADDING: 5,
    /** AXIS LABEL PADDING */
    AXIS_LABEL_PADDING: 7,
    /** rotations degree candidates */
    DEGREE_CANDIDATES: [25, 45, 65, 85],
    /** xAxis label compare margin */
    XAXIS_LABEL_COMPARE_MARGIN: 20,
    /** xAxis label gutter */
    XAXIS_LABEL_GUTTER: 2,
    /**
     * Standard multiple nums of axis
     * @type {Array}
     */
    AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10, 20, 50, 100],
    /**
     * Last standard multiple num of axis
     */
    AXIS_LAST_STANDARD_MULTIPLE_NUM: 100,
    /** label padding top */
    LABEL_PADDING_TOP: 2,
    /** line margin top */
    LINE_MARGIN_TOP: 5,
    /** tooltip gap */
    TOOLTIP_GAP: 5,
    /** tooltip direction
     * @type {string}
     */
    TOOLTIP_DIRECTION_FORWARD: 'forword',
    /** @type {string} */
    TOOLTIP_DIRECTION_CENTER: 'center',
    /** @type {string} */
    TOOLTIP_DIRECTION_BACKWARD: 'backword',
    /** tooltip align options
     * @type {string}
     */
    TOOLTIP_DEFAULT_ALIGN_OPTION: 'center top',
    /** @type {string} */
    TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: 'right middle',
    /** @type {string} */
    TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: 'center bottom',
    /** hide delay */
    HIDE_DELAY: 200
};
module.exports = chartConst;

},{}],20:[function(require,module,exports){
/**
 * @fileoverview AreaTypeCustomEvent is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    AreaTypeDataModel = require('./areaTypeDataModel'),
    chartConst = require('../const');

var AreaTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends AreaTypeCustomEvent.prototype */ {
    /**
     * AreaTypeCustomEvent is custom event for line type chart.
     * @param {object} params parameters
     * @constructs AreaTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        CustomEventBase.call(this, params);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;
    },

    /**
     * Initialize data of custom event
     * @param {Array.<object>} seriesInfos series infos
     * @override
     */
    initCustomEventData: function(seriesInfos) {
        var seriesInfo = seriesInfos[0];
        this.dataModel = new AreaTypeDataModel(seriesInfo);
        CustomEventBase.prototype.initCustomEventData.call(this, seriesInfos);
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            bound = elTarget.getBoundingClientRect(),
            layerX = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left,
            layerY = e.clientY - bound.top,
            groupIndex = this.tickBaseDataModel.findIndex(layerX),
            foundData = this.dataModel.findData(groupIndex, layerY);

        if (!this._isChanged(this.prevFoundData, foundData)) {
            return;
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
        } else if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
        }
        this.prevFoundData = foundData;
    },

    /**
     * On mouseout.
     * @private
     * @override
     */
    _onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            this.prevFoundData = null;
        }
    }
});

module.exports = AreaTypeCustomEvent;

},{"../const":19,"./areaTypeDataModel":21,"./customEventBase":22}],21:[function(require,module,exports){
/**
 * @fileoverview AreaTypeDataModel is data model for area type custom event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var AreaTypeDataModel = tui.util.defineClass(/** @lends AreaTypeDataModel.prototype */ {
    /**
     * AreaTypeDataModel is data mode for area type custom event.
     * @constructs AreaTypeDataModel
     * @param {object} seriesInfo series info
     */
    init: function(seriesInfo) {
        this.data = this._makeData(seriesInfo.data.groupPositions, seriesInfo.chartType);
    },

    /**
     * Make area type data for custom event.
     * @param {Array.<Array.<object>>} groupPositions group positions
     * @param {string} chartType cahrt type
     * @returns {Array} area type data for custom event
     * @private
     */
    _makeData: function(groupPositions, chartType) {
        groupPositions = tui.util.pivot(groupPositions);
        return tui.util.map(groupPositions, function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    chartType: chartType,
                    indexes: {
                        groupIndex: groupIndex,
                        index: index
                    },
                    bound: position
                };
            });
        });
    },

    /**
     * Find Data.
     * @param {number} groupIndex group index
     * @param {number} layerY mouse position
     * @returns {object} index
     */
    findData: function(groupIndex, layerY) {
        var result = null,
            min = 10000;
        tui.util.forEach(this.data[groupIndex], function(data) {
            var diff = Math.abs(layerY - data.bound.top);
            if (min > diff) {
                min = diff;
                result = data;
            }
        });
        return result;
    }
});

module.exports = AreaTypeDataModel;

},{}],22:[function(require,module,exports){
/**
 * @fileoverview CustomEventBase is base class for event handle layers.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var eventListener = require('../helpers/eventListener'),
    TickBaseDataModel = require('./tickBaseDataModel'),
    PointTypeDataModel = require('./pointTypeDataModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var CustomEventBase = tui.util.defineClass(/** @lends CustomEventBase.prototype */ {
    /**
     * CustomEventBase is base class for custom event components.
     * @constructs CustomEventBase
     * @param {object} params parameters
     *      @param {{
     *          dimension: {width: number, height: number},
     *          position: {left: number, top: number}
     *      }} params.bound bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.isVertical whether vertical or not
     */
    init: function(params) {
        this.chartType = params.chartType;
        this.isVertical = params.isVertical;
        this.dataProcessor = params.dataProcessor;
        this.boundsMaker = params.boundsMaker;
    },

    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer custom event container element
     * @param {object} data rendering data
     * @private
     */
    _renderCustomEventArea: function(customEventContainer, data) {
        var expandedBound;

        this.dimension = this.boundsMaker.getDimension('customEvent');
        this.tickBaseDataModel = new TickBaseDataModel(this.dimension, data.tickCount, this.chartType, this.isVertical);
        expandedBound = renderUtil.expandBound(this.boundsMaker.getBound('customEvent'));
        renderUtil.renderDimension(customEventContainer, expandedBound.dimension);
        renderUtil.renderPosition(customEventContainer, expandedBound.position);
    },

    /**
     * Render event handle layer component.
     * @param {object} data rendering data
     * @returns {HTMLElement} coordinate area
     */
    render: function(data) {
        var el = dom.create('DIV', 'tui-chart-series-custom-event-area');

        this._renderCustomEventArea(el, data);
        this.attachEvent(el);
        this.customEventContainer = el;
        return el;
    },

    /**
     * Initialize data of custom event
     * @param {Array.<object>} seriesInfos series infos
     */
    initCustomEventData: function(seriesInfos) {
        this.pointTypeDataModel = new PointTypeDataModel(seriesInfos);
    },

    /**
     * Render.
     * @param {{tickCount: number}} data data
     */
    rerender: function(data) {
        this._renderCustomEventArea(this.customEventContainer, data);
    },

    /**
     * Resize event handle layer component.
     * @param {{tickCount: number}} data data
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Whether changed or not.
     * @param {object} prev previous data
     * @param {object} cur current data
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(prev, cur) {
        return !prev || !cur || prev.chartType !== cur.chartType ||
            prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
    },

    /**
     * Find point type data.
     * @param {HTMLElement} elTarget target element
     * @param {number} clientX mouse position x
     * @param {number} clientY mouse position y
     * @returns {object} found data
     * @private
     */
    _findPointTypeData: function(elTarget, clientX, clientY) {
        var bound = elTarget.getBoundingClientRect(),
            layerX = clientX - bound.left,
            layerY = clientY - bound.top,
            groupIndex = this.tickBaseDataModel.findIndex(this.isVertical ? layerX : layerY);
        return this.pointTypeDataModel.findData(groupIndex, layerX + chartConst.SERIES_EXPAND_SIZE, layerY);
    },

    /**
     * Unselect selected data.
     * @private
     */
    _unselectSelectedData: function() {
        var eventName = renderUtil.makeCustomEventName('unselect', this.selectedData.chartType, 'series');
        this.fire(eventName, this.selectedData);
        delete this.selectedData;
    },

    /**
     * On mouse event.
     * @param {string} eventType custom event type
     * @param {mouseevent} e mouse event
     * @private
     */
    _onMouseEvent: function(eventType, e) {
        var eventName = renderUtil.makeCustomEventName(eventType, this.chartType, 'series');

        dom.addClass(this.customEventContainer, 'hide');
        this.fire(eventName, {
            left: e.clientX,
            top: e.clientY
        });
        dom.removeClass(this.customEventContainer, 'hide');
    },

    /**
     * On click
     * @param {mouseevent} e mouse event
     * @private
     */
    _onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findPointTypeData(elTarget, clientX, e.clientY);
        if (!this._isChanged(this.selectedData, foundData)) {
            this._unselectSelectedData();
        } else if (foundData) {
            if (this.selectedData) {
                this._unselectSelectedData();
            }
            this.fire(renderUtil.makeCustomEventName('select', foundData.chartType, 'series'), foundData);
            this.selectedData = foundData;
        }
    },

    /**
     * On mouse down
     * @private
     * @abstract
     */
    _onMousedown: function() {},

    /**
     * On mouse up
     * @private
     * @abstract
     */
    _onMouseup: function() {},

    /**
     * On mouse move
     * @private
     * @abstract
     */
    _onMousemove: function() {},

    /**
     * On mouse out
     * @private
     * @abstract
     */
    _onMouseout: function() {},

    /**
     * Attach event
     * @param {HTMLElement} el target element
     */
    attachEvent: function(el) {
        eventListener.bindEvent('click', el, tui.util.bind(this._onClick, this));
        eventListener.bindEvent('mousedown', el, tui.util.bind(this._onMousedown, this));
        eventListener.bindEvent('mouseup', el, tui.util.bind(this._onMouseup, this));
        eventListener.bindEvent('mousemove', el, tui.util.bind(this._onMousemove, this));
        eventListener.bindEvent('mouseout', el, tui.util.bind(this._onMouseout, this));
    }
});

tui.util.CustomEvents.mixin(CustomEventBase);

module.exports = CustomEventBase;

},{"../const":19,"../helpers/domHandler":38,"../helpers/eventListener":39,"../helpers/renderUtil":42,"./pointTypeDataModel":27,"./tickBaseDataModel":28}],23:[function(require,module,exports){
/**
 * @fileoverview GroupTypeCustomEvent is event handle layer for grouped tooltip option.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    chartConst = require('../const');

var GroupTypeCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends GroupTypeCustomEvent.prototype */ {
    /**
     * GroupTypeCustomEvent is event handle layer for grouped tooltip option.
     * @constructs GroupTypeCustomEvent
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);
    },

    /**
     * Whether out position or not.
     * @param {number} layerX layerX
     * @param {number} layerY layerY
     * @returns {boolean} result boolean
     * @private
     */
    _isOutPosition: function(layerX, layerY) {
        var dimension = this.dimension;
        return layerX < 0 || layerX > dimension.width || layerY < 0 || layerY > dimension.height;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            bound = elTarget.getBoundingClientRect(),
            layerX = e.clientX - chartConst.SERIES_EXPAND_SIZE - bound.left,
            layerY = e.clientY - chartConst.SERIES_EXPAND_SIZE - bound.top,
            index = -1;

        if (!this._isOutPosition(layerX, layerY)) {
            index = this.tickBaseDataModel.findIndex(this.isVertical ? layerX : layerY);
        }

        if (index === -1) {
            this._onMouseout();
        } else if (this.prevIndex !== index) {
            this.prevIndex = index;
            this.fire('showGroupTooltip', {
                index: index,
                range: this.tickBaseDataModel.makeRange(index, this.chartType),
                size: this.dimension[this.isVertical ? 'height' : 'width'],
                isVertical: this.isVertical
            });
        }
    },

    /**
     * On mouseout.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    _onMouseout: function() {
        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupTooltip', this.prevIndex);
            delete this.prevIndex;
        }
    }
});

module.exports = GroupTypeCustomEvent;

},{"../const":19,"./customEventBase":22}],24:[function(require,module,exports){
/**
 * @fileoverview MapChartCustomEvent is event handle layer for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var MapChartCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends MapChartCustomEvent.prototype */ {
    /**
     * MapChartCustomEvent is event handle layer for map chart.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker boundsMaker instance
     * @constructs MapChartCustomEvent
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
        this.isDown = false;
    },
    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer custom event container element
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @private
     * @override
     */
    _onClick: function() {},

    /**
     * On mouse down
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousedown: function(e) {
        this.isDown = true;
        this.fire('dragStartMapSeries', {
            left: e.clientX,
            top: e.clientY
        });
    },

    /**
     * Drag end.
     * @private
     */
    _dragEnd: function() {
        this.isDrag = false;
        dom.removeClass(this.customEventContainer, 'drag');
        this.fire('dragEndMapSeries');
    },

    /**
     * On mouse up
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMouseup: function(e) {
        this.isDown = false;
        if (this.isDrag) {
            this._dragEnd();
        } else if (!this.isMove) {
            this._onMouseEvent('click', e);
        }
        this.isMove = false;
    },

    /**
     * On mouse move.
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        if (this.isDown) {
            if (!this.isDrag) {
                dom.addClass(this.customEventContainer, 'drag');
            }
            this.isDrag = true;
            this.fire('dragMapSeries', {
                left: e.clientX,
                top: e.clientY
            });
        } else {
            this.isMove = true;
            this._onMouseEvent('move', e);
        }
    },

    /**
     * On mouse out
     * @private
     * @override
     */
    _onMouseout: function(e) {
        if (this.isDrag) {
            this._dragEnd();
        } else {
            this._onMouseEvent('move', e);
        }
        this.isDown = false;
    }
});

tui.util.CustomEvents.mixin(MapChartCustomEvent);

module.exports = MapChartCustomEvent;

},{"../helpers/domHandler":38,"../helpers/renderUtil":42,"./customEventBase":22}],25:[function(require,module,exports){
/**
 * @fileoverview PieChartCustomEvent is event handle layer for pie chart tooltip.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var CustomEventBase = require('./customEventBase'),
    renderUtil = require('../helpers/renderUtil');

var PieChartCustomEvent = tui.util.defineClass(CustomEventBase, /** @lends PieChartCustomEvent.prototype */ {
    /**
     * PieChartCustomEvent is event handle layer for pie chart tooltip.
     * @constructs PieChartCustomEvent
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker instance
     *      @param {string} parmas.chartType chart type
     * @extends CustomEventBase
     */
    init: function(params) {
        this.boundsMaker = params.boundsMaker;
        this.chartType = params.chartType;
    },
    /**
     * Render event handle layer area
     * @param {HTMLElement} customEventContainer custom event container element
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound bound of event handler layer
     * @private
     */
    _renderCustomEventArea: function(customEventContainer) {
        var bound = this.boundsMaker.getBound('customEvent');
        renderUtil.renderDimension(customEventContainer, bound.dimension);
        renderUtil.renderPosition(customEventContainer, bound.position);
    },

    /**
     * Initialize data of custom event
     * @override
     */
    initCustomEventData: function() {},

    /**
     * On click.
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onClick: function(e) {
        this._onMouseEvent('click', e);
    },

    /**
     * On mouse move.
     * @param {mouseevent} e mouse event
     * @private
     * @override
     */
    _onMousemove: function(e) {
        this._onMouseEvent('move', e);
    }
});

tui.util.CustomEvents.mixin(PieChartCustomEvent);

module.exports = PieChartCustomEvent;

},{"../helpers/renderUtil":42,"./customEventBase":22}],26:[function(require,module,exports){
/**
 * @fileoverview PointTypeCustomEven is event handle layer for line type chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    CustomEventBase = require('./customEventBase');

var PointTypeCustomEven = tui.util.defineClass(CustomEventBase, /** @lends PointTypeCustomEven.prototype */ {
    /**
     * PointTypeCustomEven is event handle layer for line type chart.
     * @constructs PointTypeCustomEven
     * @extends CustomEventBase
     */
    init: function() {
        CustomEventBase.apply(this, arguments);

        /**
         * previous found data
         * @type {null | object}
         */
        this.prevFoundData = null;
    },

    /**
     * On mousemove.
     * @param {MouseEvent} e mouse event object
     * @private
     * @override
     */
    _onMousemove: function(e) {
        var elTarget = e.target || e.srcElement,
            clientX = e.clientX - chartConst.SERIES_EXPAND_SIZE,
            foundData = this._findPointTypeData(elTarget, clientX, e.clientY);

        if (!this._isChanged(this.prevFoundData, foundData)) {
            return;
        }

        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
        }

        if (foundData) {
            this.fire('showTooltip', foundData);
        }

        this.prevFoundData = foundData;
    },

    /**
     * On mouseout.
     * @param {MouseEvent} e mouse event object
     * @override
     */
    _onMouseout: function() {
        if (this.prevFoundData) {
            this.fire('hideTooltip', this.prevFoundData);
            this.prevFoundData = null;
        }
    }
});

module.exports = PointTypeCustomEven;

},{"../const":19,"./customEventBase":22}],27:[function(require,module,exports){
/**
 * @fileoverview PointTypeDataModel is data mode for point type custom event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * position
 * @typedef {{left: number, top: number}} position
 */

/**
 * bound
 * @typedef {{
 *      dimension: {width: number, height: number},
 *      position: position
 *}} bound
 */

/**
 * group bound
 *  @typedef {Array.<Array.<bound>>} groupBound
 */

/**
 * group position
 *  @typedef {Array.<Array.<position>>} groupPosition
 */

/**
 * series info
 * @typedef {{
 *      chartType: {string},
 *      data: {
 *          groupBounds: ?groupBound,
 *          groupValues: ?Array.<Array.<number>>,
 *          groupPositions: ?groupPosition
 *      }
 *}} seriesInfo
 */

var chartConst = require('../const'),
    predicate = require('../helpers/predicate');

var PointTypeDataModel = tui.util.defineClass(/** @lends PointTypeDataModel.prototype */ {
    /**
     * PointTypeDataModel is data mode for point type custom event.
     * @constructs PointTypeDataModel
     * @param {Array.<seriesInfo>} seriesInfos series infos
     */
    init: function(seriesInfos) {
        this.data = this._makeData(seriesInfos);
    },

    /**
     * Make coordinate data about bar type graph
     * @param {groupBound} groupBounds group bounds
     * @param {string} chartType chart type
     * @returns {Array} coordinate data
     * @private
     */
    _makeRectTypeCoordinateData: function(groupBounds, chartType) {
        return tui.util.map(groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(_bound, index) {
                var bound;
                if (!_bound) {
                    return null;
                }

                bound = _bound.end;

                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        allowNegativeTooltip: true,
                        bound: bound
                    },
                    bound: {
                        left: bound.left,
                        top: bound.top,
                        right: bound.left + bound.width,
                        bottom: bound.top + bound.height
                    }
                };
            });
        });
    },

    /**
     * Make coordinate data about dot type graph
     * @param {groupPositions} groupPositions group positions
     * @param {string} chartType chart type
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeDotTypeCoordinateData: function(groupPositions, chartType) {
        if (!groupPositions) {
            return [];
        }

        return tui.util.map(tui.util.pivot(groupPositions), function(positions, groupIndex) {
            return tui.util.map(positions, function(position, index) {
                return {
                    sendData: {
                        chartType: chartType,
                        indexes: {
                            groupIndex: groupIndex,
                            index: index
                        },
                        bound: position
                    },
                    bound: {
                        left: position.left - chartConst.DOT_RADIUS,
                        top: position.top - chartConst.DOT_RADIUS,
                        right: position.left + chartConst.DOT_RADIUS,
                        bottom: position.top + chartConst.DOT_RADIUS
                    }
                };
            });
        });
    },

    /**
     * Join data.
     * @param {Array.<Array.<Array.<object>>>} groupData group data
     * @returns {Array.<Array.<object>>} joined data
     * @private
     */
    _joinData: function(groupData) {
        var results = [];
        tui.util.forEachArray(groupData, function(coordData) {
            tui.util.forEachArray(coordData, function(data, index) {
                if (!results[index]) {
                    results[index] = [];
                }
                results[index] = results[index].concat(data);
            });
        });

        return results;
    },

    /**
     * Make coordinate data.
     * @param {Array.<seriesInfo>} seriesInfos series infos
     * @returns {Array.<Array.<object>>} coordinate data
     * @private
     */
    _makeData: function(seriesInfos) {
        var coordinateData;
        seriesInfos.reverse();
        coordinateData = tui.util.map(seriesInfos, function(info) {
            var result;
            if (predicate.isLineTypeChart(info.chartType)) {
                result = this._makeDotTypeCoordinateData(info.data.groupPositions, info.chartType);
            } else {
                result = this._makeRectTypeCoordinateData(info.data.groupBounds, info.chartType);
            }
            return result;
        }, this);
        return this._joinData(coordinateData);
    },

    /**
     * Find tooltip data.
     * @param {number} groupIndex group index
     * @param {number} layerX mouse position x
     * @param {number} layerY mouse position y
     * @returns {object} tooltip data
     */
    findData: function(groupIndex, layerX, layerY) {
        var min = 10000,
            result = null,
            candidates;

        if (groupIndex === -1) {
            return result;
        }

        // layerX, layerY를 포함하는 data 추출
        candidates = tui.util.filter(this.data[groupIndex], function(data) {
            var bound = data && data.bound;
            return bound && bound.left <= layerX && bound.right >= layerX && bound.top <= layerY && bound.bottom >= layerY;
        });

        // 추출된 data 중 top이 layerY와 가장 가까운 data 찾아내기
        tui.util.forEachArray(candidates, function(data) {
            var diff = Math.abs(layerY - data.sendData.bound.top);
            if (min > diff) {
                min = diff;
                result = data.sendData;
            }
        });

        return result;
    }
});

module.exports = PointTypeDataModel;

},{"../const":19,"../helpers/predicate":41}],28:[function(require,module,exports){
/**
 * @fileoverview TickBaseDataModel is tick base data model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('../helpers/predicate');

var TickBaseDataModel = tui.util.defineClass(/** @lends TickBaseDataModel.prototype */ {
    /**
     * TickBaseDataModel is tick base data model.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @constructs TickBaseDataModel
     */
    init: function(dimension, tickCount, chartType, isVertical) {
        this.data = this._makeData(dimension, tickCount, chartType, isVertical);
    },

    /**
     * Make tick base data about line type chart.
     * @param {number} width width
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeLineTypeData: function(width, tickCount) {
        var tickInterval = (width + 1) / (tickCount - 1),
            halfInterval = tickInterval / 2,
            ranges = tui.util.map(tui.util.range(0, tickCount), function(index) {
                return {
                    min: index * tickInterval - halfInterval,
                    max: index * tickInterval + halfInterval
                };
            });
        ranges[tickCount - 1].max -= 1;
        return ranges;
    },

    /**
     * Make tick base data about non line type chart.
     * @param {number} size width or height
     * @param {number} tickCount tick count
     * @returns {Array} tick base data
     * @private
     */
    _makeNormalData: function(size, tickCount) {
        var len = tickCount - 1,
            tickInterval = size / len,
            prev = 0;
        return tui.util.map(tui.util.range(0, len), function(index) {
            var max = tui.util.min([size, (index + 1) * tickInterval]),
                limit = {
                    min: prev,
                    max: max
                };
            prev = max;
            return limit;
        });
    },

    /**
     * Make tick base data for custom event.
     * @param {{width: number, height: number}} dimension dimension
     * @param {number} tickCount tick count
     * @param {string} chartType chart type
     * @param {boolan} isVertical whether vertical or not
     * @returns {Array.<object>} tick base data
     * @private
     */
    _makeData: function(dimension, tickCount, chartType, isVertical) {
        var sizeType = isVertical ? 'width' : 'height',
            data;
        if (predicate.isLineTypeChart(chartType)) {
            data = this._makeLineTypeData(dimension[sizeType], tickCount);
        } else {
            data = this._makeNormalData(dimension[sizeType], tickCount);
        }

        return data;
    },

    /**
     * Find index.
     * @param {number} pointValue mouse position point value
     * @returns {number} group index
     */
    findIndex: function(pointValue) {
        var foundIndex = -1;
        tui.util.forEachArray(this.data, function(limit, index) {
            if (limit.min < pointValue && limit.max >= pointValue) {
                foundIndex = index;
                return false;
            }
        });

        return foundIndex;
    },

    /**
     * Get tick base data length.
     * @returns {number} length
     */
    getLength: function() {
        return this.data.length;
    },

    /**
     * Make range of tooltip position.
     * @param {number} index index
     * @param {string} chartType chart type
     * @returns {{start: number, end: number}} range type value
     * @private
     */
    makeRange: function(index, chartType) {
        var limit = this.data[index],
            range, center;
        if (predicate.isLineTypeChart(chartType)) {
            center = parseInt(limit.max - (limit.max - limit.min) / 2, 10);
            range = {
                start: center,
                end: center
            };
        } else {
            range = {
                start: limit.min,
                end: limit.max
            };
        }

        return range;
    }
});

module.exports = TickBaseDataModel;

},{"../helpers/predicate":41}],29:[function(require,module,exports){
/**
 * @fileoverview  Chart factory play role register chart.
 *                Also, you can get chart from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var charts = {},
    factory = {
        /**
         * Get chart instance.
         * @param {string} chartType chart type
         * @param {object} data chart data
         * @param {object} theme chart options
         * @param {object} options chart options
         * @returns {object} chart instance;
         */
        get: function(chartType, data, theme, options) {
            var Chart = charts[chartType],
                chart;

            if (!Chart) {
                throw new Error('Not exist ' + chartType + ' chart.');
            }

            chart = new Chart(data, theme, options);

            return chart;
        },

        /**
         * Register chart.
         * @param {string} chartType char type
         * @param {class} ChartClass chart class
         */
        register: function(chartType, ChartClass) {
            charts[chartType] = ChartClass;
        }
    };

module.exports = factory;

},{}],30:[function(require,module,exports){
/**
 * @fileoverview  Map factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var maps = {};

module.exports = {
    /**
     * Get map data.
     * @param {string} mapName map name
     * @returns {Array} map data
     */
    get: function(mapName) {
        var data = maps[mapName];

        if (!data) {
            throw new Error('Not exist ' + mapName + ' map.');
        }

        return data;
    },

    /**
     * Register Map.
     * @param {string} mapName map name
     * @param {Array} data map data
     */
    register: function(mapName, data) {
        maps[mapName] = data;
    }
};

},{}],31:[function(require,module,exports){
/**
 * @fileoverview  Plugin factory play role register rendering plugin.
 *                Also, you can get plugin from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var plugins = {},
    factory = {
        /**
         * Get graph renderer.
         * @param {string} libType type of graph library
         * @param {string} chartType chart type
         * @returns {object} renderer instance
         */
        get: function(libType, chartType) {
            var plugin = plugins[libType],
                Renderer, renderer;

            if (!plugin) {
                throw new Error('Not exist ' + libType + ' plugin.');
            }

            Renderer = plugin[chartType];
            if (!Renderer) {
                throw new Error('Not exist ' + chartType + ' chart renderer.');
            }

            renderer = new Renderer();

            return renderer;
        },
        /**
         * Plugin register.
         * @param {string} libType type of graph library
         * @param {object} plugin plugin to control library
         */
        register: function(libType, plugin) {
            plugins[libType] = plugin;
        }
    };

module.exports = factory;

},{}],32:[function(require,module,exports){
/**
 * @fileoverview  Theme factory play role register theme.
 *                Also, you can get theme from this factory.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    defaultTheme = require('../themes/defaultTheme');

var themes = {};

module.exports = {
    /**
     * Get theme.
     * @param {string} themeName theme name
     * @returns {object} theme object
     */
    get: function(themeName) {
        var theme = themes[themeName];

        if (!theme) {
            throw new Error('Not exist ' + themeName + ' theme.');
        }

        return theme;
    },

    /**
     * Theme register.
     * @param {string} themeName theme name
     * @param {object} theme theme
     */
    register: function(themeName, theme) {
        var targetItems;
        theme = JSON.parse(JSON.stringify(theme));

        if (themeName !== chartConst.DEFAULT_THEME_NAME) {
            theme = this._initTheme(theme);
        }

        targetItems = this._getInheritTargetThemeItems(theme);

        this._inheritThemeFont(theme, targetItems);
        this._copyColorInfo(theme);
        themes[themeName] = theme;
    },

    /**
     * Init theme.
     * @param {object} theme theme
     * @returns {object} theme
     * @private
     * @ignore
     */
    _initTheme: function(theme) {
        var cloneTheme = JSON.parse(JSON.stringify(defaultTheme)),
            newTheme;

        this._concatDefaultColors(theme, cloneTheme.series.colors)
        newTheme = this._overwriteTheme(theme, cloneTheme);

        newTheme = this._copyProperty({
            propName: 'yAxis',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.YAXIS_PROPS
        });

        newTheme = this._copyProperty({
            propName: 'series',
            fromTheme: theme,
            toTheme: newTheme,
            rejectionProps: chartConst.SERIES_PROPS
        });

        return newTheme;
    },

    /**
     * Filter chart types.
     * @param {object} target target charts
     * @param {Array.<string>} rejectionProps reject property
     * @returns {Object} filtered charts.
     * @private
     */
    _filterChartTypes: function(target, rejectionProps) {
        var result;
        if (!target) {
            return [];
        }

        result = tui.util.filter(target, function(item, name) {
            return tui.util.inArray(name, rejectionProps) === -1;
        });
        return result;
    },

    /**
     * Concat colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatColors: function(theme, seriesColors) {
        if (theme.colors) {
            theme.colors = theme.colors.concat(seriesColors);
        }

        if (theme.singleColors) {
            theme.singleColors = theme.singleColors.concat(seriesColors);
        }
    },

    /**
     * Concat default colors.
     * @param {object} theme theme
     * @param {Array.<string>} seriesColors series colors
     * @private
     */
    _concatDefaultColors: function(theme, seriesColors) {
        var chartTypes;

        if (!theme.series) {
            return;
        }

        chartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(chartTypes).length) {
            this._concatColors(theme.series, seriesColors);
        } else {
            tui.util.forEach(chartTypes, function(item) {
                this._concatColors(item, seriesColors);
            }, this);
        }
    },

    /**
     * Overwrite theme
     * @param {object} from from theme property
     * @param {object} to to theme property
     * @returns {object} result property
     * @private
     */
    _overwriteTheme: function(from, to) {
        tui.util.forEach(to, function(item, key) {
            var fromItem = from[key];
            if (!fromItem) {
                return;
            }

            if (tui.util.isArray(fromItem)) {
                to[key] = fromItem.slice();
            } else if (tui.util.isObject(fromItem)) {
                this._overwriteTheme(fromItem, item);
            } else {
                to[key] = fromItem;
            }
        }, this);

        return to;
    },

    /**
     * Copy property.
     * @param {object} params parameters
     *      @param {string} params.propName property name
     *      @param {object} params.fromTheme from property
     *      @param {object} params.toTheme tp property
     *      @param {Array.<string>} params.rejectionProps reject property name
     * @returns {object} copied property
     * @private
     */
    _copyProperty: function(params) {
        var chartTypes;

        if (!params.toTheme[params.propName]) {
            return params.toTheme;
        }

        chartTypes = this._filterChartTypes(params.fromTheme[params.propName], params.rejectionProps);
        if (tui.util.keys(chartTypes).length) {
            tui.util.forEach(chartTypes, function(item, key) {
                var cloneTheme = JSON.parse(JSON.stringify(defaultTheme[params.propName]));
                params.fromTheme[params.propName][key] = this._overwriteTheme(item, cloneTheme);
            }, this);

            params.toTheme[params.propName] = params.fromTheme[params.propName];
        }

        return params.toTheme;
    },

    /**
     * Copy color info to legend
     * @param {object} seriesTheme series theme
     * @param {object} legendTheme legend theme
     * @param {Array.<string>} colors colors
     * @private
     */
    _copyColorInfoToOther: function(seriesTheme, legendTheme, colors) {
        legendTheme.colors = colors || seriesTheme.colors;
        if (seriesTheme.singleColors) {
            legendTheme.singleColors = seriesTheme.singleColors;
        }
        if (seriesTheme.borderColor) {
            legendTheme.borderColor = seriesTheme.borderColor;
        }
        if (seriesTheme.selectionColor) {
            legendTheme.selectionColor = seriesTheme.selectionColor;
        }
    },

    /**
     * Get target items about font inherit.
     * @param {object} theme theme
     * @returns {Array.<object>} target items
     * @private
     */
    _getInheritTargetThemeItems: function(theme) {
        var items = [
                theme.title,
                theme.xAxis.title,
                theme.xAxis.label,
                theme.legend.label
            ],
            yAxisChartTypeThems = this._filterChartTypes(theme.yAxis, chartConst.YAXIS_PROPS),
            seriesChartTypeThemes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);

        if (!tui.util.keys(yAxisChartTypeThems).length) {
            items.push(theme.yAxis.title);
            items.push(theme.yAxis.label);
        } else {
            tui.util.forEach(yAxisChartTypeThems, function(chatTypeTheme) {
                items.push(chatTypeTheme.title);
                items.push(chatTypeTheme.label);
            });
        }

        if (!tui.util.keys(seriesChartTypeThemes).length) {
            items.push(theme.series.label);
        } else {
            tui.util.forEach(seriesChartTypeThemes, function(chatTypeTheme) {
                items.push(chatTypeTheme.label);
            });
        }
        return items;
    },

    /**
     * Inherit theme font.
     * @param {object} theme theme
     * @param {Array.<object>} targetItems target theme items
     * @private
     */
    _inheritThemeFont: function(theme, targetItems) {
        var baseFont = theme.chart.fontFamily;

        tui.util.forEachArray(targetItems, function(item) {
            if (!item.fontFamily) {
                item.fontFamily = baseFont;
            }
        });
    },

    /**
     * Copy color info.
     * @param {object} theme theme
     * @private
     * @ignore
     */
    _copyColorInfo: function(theme) {
        var seriesChartTypes = this._filterChartTypes(theme.series, chartConst.SERIES_PROPS);
        if (!tui.util.keys(seriesChartTypes).length) {
            this._copyColorInfoToOther(theme.series, theme.legend);
            this._copyColorInfoToOther(theme.series, theme.tooltip);
        } else {
            tui.util.forEach(seriesChartTypes, function(item, chartType) {
                theme.legend[chartType] = {};
                theme.tooltip[chartType] = {};
                this._copyColorInfoToOther(item, theme.legend[chartType], item.colors || theme.legend.colors);
                this._copyColorInfoToOther(item, theme.tooltip[chartType], item.colors || theme.tooltip.colors);
                delete theme.legend.colors;
                delete theme.tooltip.colors;
            }, this);
        }
    }
};

},{"../const":19,"../themes/defaultTheme":75}],33:[function(require,module,exports){
/**
 * @fileoverview Axis Data Maker
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('./predicate'),
    calculator = require('./calculator'),
    renderUtil = require('./renderUtil');

var abs = Math.abs,
    concat = Array.prototype.concat;

/**
 * Axis data maker.
 * @module axisDataMaker
 */
var axisDataMaker = {
    /**
     * Make labels.
     * @param {Array.<string>} labels labels
     * @param {number} labelInterval label interval
     * @returns {Array.<string>} labels
     * @private
     */
    _makeLabels: function(labels, labelInterval) {
        var lastIndex;
        if (!labelInterval) {
            return labels;
        }

        lastIndex = labels.length - 1;
        return tui.util.map(labels, function(label, index) {
            if (index > 0 && index < lastIndex && (index % labelInterval) > 0) {
                label = chartConst.EMPTY_AXIS_LABEL;
            }
            return label;
        });
    },

    /**
     * Make data about label axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {Array.<string>} labels chart labels
     *      @param {boolean} isVertical whether vertical or not
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      isVertical: boolean
     * }} axis data
     */
    makeLabelAxisData: function(params) {
        var tickCount = params.labels.length,
            options = params.options || {};

        if (!params.aligned) {
            tickCount += 1;
        }

        return {
            labels: this._makeLabels(params.labels, options.labelInterval),
            tickCount: tickCount,
            validTickCount: 0,
            isLabelAxis: true,
            isVertical: !!params.isVertical,
            aligned: !!params.aligned
        };
    },

    /**
     * Make data about value axis.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {Array.<Array.<number>>} params.values chart values
     *      @param {{width:number, height:number}} params.seriesDimension series dimension
     *      @param {Array.<function>} params.formatFunctions format functions
     *      @param {string} params.stacked stacked option
     *      @param {string} params.options axis options
     * @returns {{
     *      labels: Array.<string>,
     *      tickCount: number,
     *      validTickCount: number,
     *      isLabelAxis: boolean,
     *      limit: {min: number, max: number},
     *      isVertical: boolean
     * }} axis data
     */
    makeValueAxisData: function(params) {
        var options = params.options || {},
            isVertical = !!params.isVertical,
            isPositionRight = !!params.isPositionRight,
            isAllowedStackedOption = predicate.isAllowedStackedOption(params.chartType),
            formatFunctions = params.formatFunctions,
            minusSum, tickInfo;

        if (isAllowedStackedOption && predicate.isPercentStacked(params.stackedOption)) {
            minusSum = calculator.sumMinusValues(concat.apply([], params.values));
            if (minusSum < 0) {
                tickInfo = params.divergingOption ? chartConst.DIVERGENT_PERCENT_STACKED_TICK_INFO
                    : chartConst.NEGATIVE_PERCENT_STACKED_TICK_INFO;
            } else {
                tickInfo = chartConst.PERCENT_STACKED_TICK_INFO;
            }
            formatFunctions = [function(value) {
                return value + '%';
            }];
        } else {
            tickInfo = this._getTickInfo({
                values: this._makeBaseValues(params.values, isAllowedStackedOption, params.stackedOption),
                seriesDimension: params.seriesDimension,
                isVertical: isVertical,
                isPositionRight: isPositionRight,
                chartType: params.chartType,
                divergingOption: params.divergingOption,
                tickCount: params.tickCount
            }, options);
        }

        return {
            labels: this.formatLabels(tickInfo.labels, formatFunctions),
            tickCount: tickInfo.tickCount,
            validTickCount: tickInfo.tickCount,
            limit: tickInfo.limit,
            step: tickInfo.step,
            isVertical: isVertical,
            isPositionRight: isPositionRight,
            aligned: !!params.aligned
        };
    },

    /**
     * Make base values.
     * @memberOf module:axisDataMaker
     * @param {Array.<number>} groupValues group values
     * @param {boolean} isAllowedStackedOption whether allowed stacked option or not.
     * @param {string} stacked stacked option.
     * @returns {Array.<number>} base values
     * @private
     */
    _makeBaseValues: function(groupValues, isAllowedStackedOption, stacked) {
        if (isAllowedStackedOption && predicate.isNormalStacked(stacked)) {
            groupValues = tui.util.map(groupValues, function(values) {
                var plusSum = calculator.sumPlusValues(values),
                    minusSum = calculator.sumMinusValues(values);
                return [plusSum, minusSum];
            }, this);
        }
        return concat.apply([], groupValues);
    },

    /**
     * Get base size for get candidate tick counts.
     * @memberOf module:axisDataMaker
     * @param {{width: number, height: number}} dimension chat dimension
     * @param {boolean} isVertical whether vertical or not
     * @returns {number} base size
     * @private
     */
    _getBaseSize: function(dimension, isVertical) {
        var baseSize;

        if (isVertical) {
            baseSize = dimension.height;
        } else {
            baseSize = dimension.width;
        }

        return baseSize;
    },

    /**
     * Get candidate tick counts.
     * @memberOf module:axisDataMaker
     * @param {{width: number, height: number}} chartDimension chat dimension
     * @param {boolean} isVertical whether vertical or not
     * @returns {Array.<number>} tick counts
     * @private
     */
    _getCandidateTickCounts: function(chartDimension, isVertical) {
        var baseSize = this._getBaseSize(chartDimension, isVertical),
            start = tui.util.max([3, parseInt(baseSize / chartConst.MAX_PIXEL_TYPE_STEP_SIZE, 10)]),
            end = tui.util.max([start, parseInt(baseSize / chartConst.MIN_PIXEL_TYPE_STEP_SIZE, 10)]) + 1,
            tickCounts = tui.util.range(start, end);
        return tickCounts;
    },

    /**
     * Get comparing value.
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{limit: {min: number, max: number}, step: number}} tickInfo tick info
     * @returns {number} comparing value
     * @private
     */
    _getComparingValue: function(min, max, tickInfo) {
        var diffMax = abs(tickInfo.limit.max - max),
            diffMin = abs(min - tickInfo.limit.min),
            weight = Math.pow(10, tui.util.lengthAfterPoint(tickInfo.step));
        return (diffMax + diffMin) * weight;
    },

    /**
     * Select tick info.
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {Array.<object>} candidates tick info candidates
     * @returns {{limit: {min: number, max: number}, tickCount: number, step: number, labels: Array.<number>}} selected tick info
     * @private
     */
    _selectTickInfo: function(min, max, candidates) {
        var getComparingValue = tui.util.bind(this._getComparingValue, this, min, max),
            tickInfo = tui.util.min(candidates, getComparingValue);
        return tickInfo;
    },

    /**
     * Make limit for diverging option.
     * @param {number} min min value
     * @param {max} max max value
     * @returns {{min: number, max: number}} limit
     * @private
     */
    _makeLimitForDivergingOption: function(min, max) {
        var newMax = Math.max(Math.abs(min), Math.abs(max));

        return {
            min: -newMax,
            max: newMax
        };
    },

    /**
     * Get tick count and limit.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.values base values
     *      @param {{width: number, height: number}} params.seriesDimension chat dimension
     *      @param {boolean} params.isVertical whether vertical or not
     *      @param {string} params.chartType chat type
     * @param {{min: number, max:number}} options axis options
     * @returns {{tickCount: number, limit: object}} tick info
     * @private
     */
    _getTickInfo: function(params, options) {
        var min = tui.util.min(params.values),
            max = tui.util.max(params.values),
            changedLimit, intTypeInfo, tickCounts, candidates, tickInfo;

        if (min === 0 && max === 0) {
            max = 5;
        }

        if (params.divergingOption) {
            delete options.min;
            changedLimit = this._makeLimitForDivergingOption(min, max);
            min = changedLimit.min;
            max = changedLimit.max;
        }

        // 01. min, max, options 정보를 정수형으로 변경
        intTypeInfo = this._makeIntegerTypeInfo(min, max, options);

        // 02. tick count 후보군 얻기
        tickCounts = params.tickCount ? [params.tickCount] : this._getCandidateTickCounts(params.seriesDimension, params.isVertical);

        // 03. tick info 후보군 계산
        candidates = this._getCandidateTickInfos({
            min: intTypeInfo.min,
            max: intTypeInfo.max,
            tickCounts: tickCounts,
            chartType: params.chartType
        }, intTypeInfo.options);

        // 04. tick info 후보군 중 하나 선택
        tickInfo = this._selectTickInfo(intTypeInfo.min, intTypeInfo.max, candidates);

        // 05. 정수형으로 변경했던 tick info를 원래 형태로 변경
        tickInfo = this._revertOriginalTypeTickInfo(tickInfo, intTypeInfo.divideNum);

        if (params.divergingOption) {
            tickInfo.labels = tui.util.map(tickInfo.labels, Math.abs);
        }
        return tickInfo;
    },

    /**
     * Make integer type info
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number, options: {min: number, max: number}, divideNum: number}} integer type info
     * @private
     */
    _makeIntegerTypeInfo: function(min, max, options) {
        var multipleNum, changedOptions;

        if (abs(min) >= 1 || abs(max) >= 1) {
            return {
                min: min,
                max: max,
                options: options,
                divideNum: 1
            };
        }

        multipleNum = tui.util.findMultipleNum(min, max);
        changedOptions = {};

        if (!tui.util.isUndefined(options.min)) {
            changedOptions.min = options.min * multipleNum;
        }

        if (!tui.util.isUndefined(options.max)) {
            changedOptions.max = options.max * multipleNum;
        }

        return {
            min: min * multipleNum,
            max: max * multipleNum,
            options: changedOptions,
            divideNum: multipleNum
        };
    },

    /**
     * Revert tick info to original type.
     * @memberOf module:axisDataMaker
     * @param {{step: number, limit: {min: number, max: number}, labels: Array.<number>}} tickInfo tick info
     * @param {number} divideNum divide num
     * @returns {{step: number, limit: {min: number, max: number}, labels: Array.<number>}} divided tick info
     * @private
     */
    _revertOriginalTypeTickInfo: function(tickInfo, divideNum) {
        if (divideNum === 1) {
            return tickInfo;
        }

        tickInfo.step = tui.util.division(tickInfo.step, divideNum);
        tickInfo.limit.min = tui.util.division(tickInfo.limit.min, divideNum);
        tickInfo.limit.max = tui.util.division(tickInfo.limit.max, divideNum);
        tickInfo.labels = tui.util.map(tickInfo.labels, function(label) {
            return tui.util.division(label, divideNum);
        });

        return tickInfo;
    },

    /**
     * Normalize step.
     * @memberOf module:axisDataMaker
     * @param {number} step original step
     * @returns {number} normalized step
     * @private
     */
    _normalizeStep: function(step) {
        return calculator.normalizeAxisNumber(step);
    },

    /**
     * Minimize tick limit.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.userMin user min
     *      @param {number} params.userMax user max
     *      @param {{tickCount: number, limit: object}} params.tickInfo tick info
     *      @param {{min: number, max:number}} params.options axis options
     * @returns {{tickCount: number, limit: object, labels: Array}} corrected tick info
     * @private
     */
    _minimizeTickLimit: function(params) {
        var tickInfo = params.tickInfo,
            ticks = tui.util.range(1, tickInfo.tickCount),
            options = params.options,
            step = tickInfo.step,
            limit = tickInfo.limit,
            tickMax = limit.max,
            tickMin = limit.min,
            isUndefinedMin = tui.util.isUndefined(options.min),
            isUndefinedMax = tui.util.isUndefined(options.max),
            labels;

        tui.util.forEachArray(ticks, function(tickIndex) {
            var curStep = (step * tickIndex),
                curMin = tickMin + curStep,
                curMax = tickMax - curStep;

            // 더이상 변경이 필요 없을 경우
            if (params.userMin <= curMin && params.userMax >= curMax) {
                return false;
            }

            // min 값에 변경 여유가 있을 경우
            if ((isUndefinedMin && params.userMin > curMin) ||
                (!isUndefinedMin && options.min >= curMin)) {
                limit.min = curMin;
            }

            // max 값에 변경 여유가 있을 경우
            if ((isUndefinedMin && params.userMax < curMax) ||
                (!isUndefinedMax && options.max <= curMax)) {
                limit.max = curMax;
            }
        });

        labels = calculator.makeLabelsFromLimit(limit, step);
        tickInfo.labels = labels;
        tickInfo.step = step;
        tickInfo.tickCount = labels.length;
        return tickInfo;
    },

    /**
     * Divide tick step.
     * @memberOf module:axisDataMaker
     * @param {{limit: {min: number, max: number}, tickCount: number, step: number, labels: Array.<number>}} tickInfo tick info
     * @param {number} orgTickCount original tickCount
     * @returns {{limit: {min: number, max: number}, tickCount: number, step: number, labels: Array.<number>}} tick info
     * @private
     */
    _divideTickStep: function(tickInfo, orgTickCount) {
        var step = tickInfo.step,
            limit = tickInfo.limit,
            tickCount = tickInfo.tickCount;
        // step 2의 배수 이면서 변경된 tickCount의 두배수-1이 tickCount보다 orgTickCount와 차이가 덜나거나 같으면 step을 반으로 변경한다.
        if ((step % 2 === 0) &&
            abs(orgTickCount - ((tickCount * 2) - 1)) <= abs(orgTickCount - tickCount)) {
            step = step / 2;
            tickInfo.labels = calculator.makeLabelsFromLimit(limit, step);
            tickInfo.tickCount = tickInfo.labels.length;
            tickInfo.step = step;
        }
        return tickInfo;
    },

    /**
     * Make tick info
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.tickCount tick count
     *      @param {number} params.min limit min
     *      @param {number} params.max limit max
     *      @param {number} params.userMin minimum value of user data
     *      @param {number} params.userMax maximum value of user data
     *      @param {boolean} params.isMinus whether limit is minus or not
     *      @param {string} params.chartType chart type
     *      @param {{min: number, max: number}} params.options axis options
     * @returns {{
     *      limit: {min: number, max: number},
     *      tickCount: number,
     *      step: number,
     *      labels: Array.<number>
     * }} tick info
     * @private
     */
    _makeTickInfo: function(params) {
        var limit = params.limit,
            step, tickInfo;

        // 01. 기본 limit 정보로 step 얻기
        step = calculator.calculateStepFromLimit(limit, params.tickCount);

        // 02. step 정규화 시키기 (ex: 0.3 --> 0.5, 7 --> 10)
        step = this._normalizeStep(step);

        // 03. limit 정규화 시키기
        limit = this.normalizeLimit(limit, step, params.tickCount);

        // 04. line차트의 경우 사용자의 min값이 limit의 min값과 같을 경우, min값을 1 step 감소 시킴
        limit.min = this._addMinPadding({
            min: limit.min,
            step: step,
            userMin: params.userMin,
            minOption: params.options.min,
            chartType: params.chartType
        });

        // 04. 사용자의 max값이 scael max와 같을 경우, max값을 1 step 증가 시킴
        limit.max = this._addMaxPadding({
            max: limit.max,
            step: step,
            userMax: params.userMax,
            maxOption: params.options.max,
            chartType: params.chartType
        });

        // 05. axis limit이 사용자 min, max와 거리가 멀 경우 조절
        tickInfo = this._minimizeTickLimit({
            userMin: params.userMin,
            userMax: params.userMax,
            tickInfo: {limit: limit, step: step, tickCount: params.tickCount},
            options: params.options
        });

        tickInfo = this._divideTickStep(tickInfo, params.tickCount);
        return tickInfo;
    },

    /**
     * Add limit min padding.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @prams {number} params.min limit min
     *      @param {number} params.userMin minimum value of user data
     *      @param {number} params.minOption min option
     *      @param {number} params.step tick step
     * @returns {number} limit min
     * @private
     */
    _addMinPadding: function(params) {
        var min = params.min;

        if ((!predicate.isLineChart(params.chartType) && params.userMin >= 0) || !tui.util.isUndefined(params.minOption)) {
            return min;
        }
        // normalize된 limit min값이 user min값과 같을 경우 step 감소
        if (params.min === params.userMin) {
            min -= params.step;
        }
        return min;
    },

    /**
     * Add limit max padding.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @prams {number} params.max limit max
     *      @param {number} params.userMax maximum value of user data
     *      @param {number} params.maxOption max option
     *      @param {number} params.step tick step
     * @returns {number} limit max
     * @private
     */
    _addMaxPadding: function(params) {
        var max = params.max;

        if ((!predicate.isLineChart(params.chartType) && params.userMax <= 0) || !tui.util.isUndefined(params.maxOption)) {
            return max;
        }

        // normalize된 limit max값이 user max값과 같을 경우 step 증가
        if (tui.util.isUndefined(params.maxOption) && (params.max === params.userMax)) {
            max += params.step;
        }
        return max;
    },

    /**
     * Normalize min.
     * @memberOf module:axisDataMaker
     * @param {number} min original min
     * @param {number} step tick step
     * @returns {number} normalized min
     * @private
     */
    _normalizeMin: function(min, step) {
        var mod = tui.util.mod(min, step),
            normalized;

        if (mod === 0) {
            normalized = min;
        } else {
            normalized = tui.util.subtraction(min, (min >= 0 ? mod : step + mod));
        }
        return normalized;
    },

    /**
     * Make normalized max.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit limit
     * @param {number} step tick step
     * @param {number} tickCount tick count
     * @returns {number} normalized max
     * @private
     */
    _makeNormalizedMax: function(limit, step, tickCount) {
        var minMaxDiff = tui.util.multiplication(step, tickCount - 1),
            normalizedMax = tui.util.addition(limit.min, minMaxDiff),
            maxDiff = limit.max - normalizedMax,
            modDiff, divideDiff;
        // normalize된 max값이 원래의 max값 보다 작을 경우 step을 증가시켜 큰 값으로 만들기
        if (maxDiff > 0) {
            modDiff = maxDiff % step;
            divideDiff = Math.floor(maxDiff / step);
            normalizedMax += step * (modDiff > 0 ? divideDiff + 1 : divideDiff);
        }
        return normalizedMax;
    },

    /**
     * Normalize limit.
     * @memberOf module:axisDataMaker
     * @param {{min: number, max: number}} limit base limit
     * @param {number} step tick step
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} normalized limit
     * @private
     */
    normalizeLimit: function(limit, step, tickCount) {
        limit.min = this._normalizeMin(limit.min, step);
        limit.max = this._makeNormalizedMax(limit, step, tickCount);
        return limit;
    },

    /**
     * Get candidates about tick info.
     * @memberOf module:axisDataMaker
     * @param {object} params parameters
     *      @param {number} params.min minimum value of user data
     *      @param {number} params.max maximum value of user data
     *      @param {Array.<number>} params.tickCounts tick counts
     *      @param {string} params.chartType chart type
     * @param {{min: number, max:number}} options axis options
     * @returns {Array} candidates about tick info
     * @private
     */
    _getCandidateTickInfos: function(params, options) {
        var userMin = params.min,
            userMax = params.max,
            min = params.min,
            max = params.max,
            limit, candidates;

        // min, max만으로 기본 limit 얻기
        limit = this._makeBaseLimit(min, max, options);

        candidates = tui.util.map(params.tickCounts, function(tickCount) {
            return this._makeTickInfo({
                tickCount: tickCount,
                limit: tui.util.extend({}, limit),
                userMin: userMin,
                userMax: userMax,
                chartType: params.chartType,
                options: options
            });
        }, this);
        return candidates;
    },

    /**
     * Make base limit
     * @memberOf module:axisDataMaker
     * @param {number} min minimum value of user data
     * @param {number} max maximum value of user data
     * @param {{min: number, max: number}} options axis options
     * @returns {{min: number, max: number}} base limit
     * @private
     */
    _makeBaseLimit: function(min, max, options) {
        var isMinus = false,
            tmpMin, limit;

        if (min === max) {
            if (min > 0) {
                min = 0;
            } else {
                max = 0;
            }

            return {
                min: min,
                max: max
            };
        }

        if (min < 0 && max <= 0) {
            isMinus = true;
            tmpMin = min;
            min = -max;
            max = -tmpMin;
        }

        limit = calculator.calculateLimit(min, max);

        if (isMinus) {
            tmpMin = limit.min;
            limit.min = -limit.max;
            limit.max = -tmpMin;
        }

        limit.min = !tui.util.isUndefined(options.min) ? options.min : limit.min;
        limit.max = !tui.util.isUndefined(options.max) ? options.max : limit.max;

        return limit;
    },

    /**
     * Format labels.
     * @memberOf module:axisDataMaker
     * @param {string[]} labels target labels
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted labels
     */
    formatLabels: function(labels, formatFunctions) {
        var result;
        if (!formatFunctions || !formatFunctions.length) {
            return labels;
        }
        result = tui.util.map(labels, function(label) {
            return renderUtil.formatValue(label, formatFunctions);
        });
        return result;
    }
};

module.exports = axisDataMaker;

},{"../const":19,"./calculator":35,"./predicate":41,"./renderUtil":42}],34:[function(require,module,exports){
/**
 * @fileoverview Bounds maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    calculator = require('./calculator'),
    predicate = require('./predicate'),
    renderUtil = require('./renderUtil');

/**
 * Dimension.
 * @typedef {{width: number, height:number}} dimension
 */

/**
 * Position.
 * @typedef {{left: number, top:number}} position
 */

/**
 * Bound.
 * @typedef {{dimension: dimension, position:position}} bound
 */

var BoundsMaker = tui.util.defineClass(/** @lends BoundsMaker.prototype */{
    /**
     * Bounds maker.
     * @constructs BoundsMaker
     * @param {object} params parameters
     */
    init: function(params) {
        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        this.options.legend = this.options.legend || {};

        /**
         * theme
         * @type {object}
         */
        this.theme = params.theme || {};

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = params.hasAxes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * chart left padding
         * @type {number}
         */
        this.chartLeftPadding = chartConst.CHART_PADDING;

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        this.initBoundsData();
    },

    /**
     * Initialize bounds data.
     * @param {object} chartOption chart option
     */
    initBoundsData: function(chartOption) {
        this.dimensions = {
            legend: {
                width: 0
            },
            yAxis: {
                width: 0
            },
            rightYAxis: {
                width: 0
            },
            xAxis: {
                height: 0
            }
        };

        this.positions = {};

        this.axesData = {};

        this.xAxisDegree = 0;

        if (chartOption) {
            this.options.chart = chartOption;
        }

        this._registerChartDimension();
        this._registerTitleDimension();
    },

    /**
     * Register dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     * @private
     */
    _registerDimension: function(name, dimension) {
        this.dimensions[name] = tui.util.extend(this.dimensions[name] || {}, dimension);
    },

    /**
     * Register base dimension.
     * @param {string} name component name
     * @param {dimension} dimension component dimension
     */
    registerBaseDimension: function(name, dimension) {
        this._registerDimension(name, dimension);
    },

    /**
     * Register axes data.
     * @param {object} axesData axes data
     */
    registerAxesData: function(axesData) {
        this.axesData = axesData;
    },

    /**
     * Get bound.
     * @param {string} name component name
     * @returns {bound} component bound
     */
    getBound: function(name) {
        return {
            dimension: this.dimensions[name] || {},
            position: this.positions[name] || {}
        };
    },

    /**
     * Get dimension.
     * @param {string} name component name
     * @returns {dimension} component dimension
     */
    getDimension: function(name) {
        return this.dimensions[name];
    },

    /**
     * Get position.
     * @param {string} name component name
     * @returns {position} component position
     */
    getPosition: function(name) {
        return this.positions[name];
    },

    /**
     * Register chart dimension
     * @private
     */
    _registerChartDimension: function() {
        var chartOptions = this.options.chart || {},
            dimension = {
            width: chartOptions.width || chartConst.CHART_DEFAULT_WIDTH,
            height: chartOptions.height || chartConst.CHART_DEFAULT_HEIGHT
        };

        this._registerDimension('chart', dimension);
    },

    /**
     * Register title dimension
     * @private
     */
    _registerTitleDimension: function() {
        var chartOptions = this.options.chart || {},
            dimension = {
            height: renderUtil.getRenderedLabelHeight(chartOptions.title, this.theme.title) + chartConst.TITLE_PADDING
        };

        this._registerDimension('title', dimension);
    },

    /**
     * Calculate limit width of x axis.
     * @returns {number} limit width
     * @private
     */
    _calculateXAxisLabelLimitWidth: function() {
        var seriesWidth = this.getDimension('series').width,
            labelCount = this.axesData.xAxis.labels.length,
            isAlign = predicate.isLineTypeChart(this.chartType);
        return seriesWidth / (isAlign ? labelCount - 1 : labelCount);
    },

    /**
     * Find rotation degree.
     * @param {number} limitWidth limit width
     * @param {number} labelWidth label width
     * @param {number} labelHeight label height
     * @param {number} index candidates index
     * @returns {number} rotation degree
     * @private
     */
    _findRotationDegree: function(limitWidth, labelWidth, labelHeight) {
        var foundDegree,
            halfWidth = labelWidth / 2,
            halfHeight = labelHeight / 2;

        tui.util.forEachArray(chartConst.DEGREE_CANDIDATES, function(degree) {
            var compareWidth = (calculator.calculateAdjacent(degree, halfWidth) + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, halfHeight)) * 2;
            foundDegree = degree;
            if (compareWidth <= limitWidth + chartConst.XAXIS_LABEL_COMPARE_MARGIN) {
                return false;
            }
        });

        return foundDegree;
    },

    /**
     * Make rotation info about horizontal label.
     * @param {number} limitWidth limit width
     * @param {Array.<string>} labels axis labels
     * @param {object} theme axis label theme
     * @returns {?object} rotation info
     * @private
     */
    _makeHorizontalLabelRotationInfo: function(limitWidth) {
        var labels = this.axesData.xAxis.labels,
            theme = this.theme.xAxis.label,
            maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(labels, theme),
            degree, labelHeight;

        if (maxLabelWidth <= limitWidth) {
            return null;
        }

        labelHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme);
        degree = this._findRotationDegree(limitWidth, maxLabelWidth, labelHeight);

        return {
            maxLabelWidth: maxLabelWidth,
            labelHeight: labelHeight,
            degree: degree
        };
    },


    /**
     * Calculate overflow position left.
     * @param {{degree: number, labelHeight: number}} rotationInfo rotation info
     * @param {string} firstLabel firstLabel
     * @returns {number} overflow position left
     * @private
     */
    _calculateOverflowLeft: function(rotationInfo, firstLabel) {
        var degree = rotationInfo.degree,
            labelHeight = rotationInfo.labelHeight,
            firstLabelWidth = renderUtil.getRenderedLabelWidth(firstLabel, this.theme.xAxis.label),
            newLabelWidth = (calculator.calculateAdjacent(degree, firstLabelWidth / 2)
                + calculator.calculateAdjacent(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2,
            diffLeft = newLabelWidth - this.getDimension('yAxis').width;
        return diffLeft;
    },

    /**
     * Update width of dimensions.
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDimensionsWidth: function(overflowLeft) {
        if (overflowLeft > 0) {
            this.chartLeftPadding += overflowLeft;
            this.dimensions.plot.width -= overflowLeft;
            this.dimensions.series.width -= overflowLeft;
            this.dimensions.xAxis.width -= overflowLeft;
        }
    },

    /**
     * Update degree of rotationInfo.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @param {number} labelLength labelLength
     * @param {number} overflowLeft overflow left
     * @private
     */
    _updateDegree: function(rotationInfo, labelLength, overflowLeft) {
        var limitWidth, newDegree;
        if (overflowLeft > 0) {
            limitWidth = this.getDimension('series').width / labelLength + chartConst.XAXIS_LABEL_GUTTER;
            newDegree = this._findRotationDegree(limitWidth, rotationInfo.maxLabelWidth, rotationInfo.labelHeight);
            rotationInfo.degree = newDegree;
        }
    },

    /**
     * Calculate rotated height of xAxis.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} xAxis height
     * @private
     */
    _calculateXAxisRotatedHeight: function(rotationInfo) {
        var degree = rotationInfo.degree,
            maxLabelWidth = rotationInfo.maxLabelWidth,
            labelHeight = rotationInfo.labelHeight,
            axisHeight = (calculator.calculateOpposite(degree, maxLabelWidth / 2) + calculator.calculateOpposite(chartConst.ANGLE_90 - degree, labelHeight / 2)) * 2;
        return axisHeight;
    },

    /**
     * Calculate height difference between origin category and rotation category.
     * @param {{degree: number, maxLabelWidth: number, labelHeight: number}} rotationInfo rotation info
     * @returns {number} height difference
     * @private
     */
    _calculateDiffWithRotatedHeight: function(rotationInfo) {
        var rotatedHeight = this._calculateXAxisRotatedHeight(rotationInfo);
        return rotatedHeight - rotationInfo.labelHeight;
    },

    /**
     * Calculate height difference between origin category and multiline category.
     * @param {Array.<string>} labels labels
     * @param {number} limitWidth limit width
     * @returns {number} calculated height
     * @private
     */
    _calculateDiffWithMultilineHeight: function(labels, limitWidth) {
        var theme = this.theme.xAxis.label,
            multilineLabels = this.dataProcessor.getMultilineCategories(limitWidth, theme),
            normalHeight = renderUtil.getRenderedLabelsMaxHeight(labels, theme),
            multilineHeight = renderUtil.getRenderedLabelsMaxHeight(multilineLabels, tui.util.extend({
                cssText: 'line-height:1.2;width:' + limitWidth + 'px'
            }, theme));

        return multilineHeight - normalHeight;
    },

    /**
     * Update height of dimensions.
     * @param {number} diffHeight diff height
     * @private
     */
    _updateDimensionsHeight: function(diffHeight) {
        this.dimensions.plot.height -= diffHeight;
        this.dimensions.series.height -= diffHeight;
        this.dimensions.yAxis.height -= diffHeight;
        this.dimensions.rightYAxis.height -= diffHeight;
        this.dimensions.xAxis.height += diffHeight;
    },

    /**
     * Update dimensions and degree.
     * @private
     */
    _updateDimensionsAndDegree: function() {
        var xAxisOptions = this.options.xAxis || {},
            limitWidth = this._calculateXAxisLabelLimitWidth(),
            labels = this.axesData.xAxis.labels,
            rotationInfo, overflowLeft, diffHeight;

        if (xAxisOptions.rotation !== false) {
            rotationInfo = this._makeHorizontalLabelRotationInfo(limitWidth);
        }

        if (rotationInfo) {
            overflowLeft = this._calculateOverflowLeft(rotationInfo, labels[0]);
            this.xAxisDegree = rotationInfo.degree;
            this._updateDimensionsWidth(overflowLeft);
            this._updateDegree(rotationInfo, labels.length, overflowLeft);
            diffHeight = this._calculateDiffWithRotatedHeight(rotationInfo);
        } else {
            diffHeight = this._calculateDiffWithMultilineHeight(labels, limitWidth);
        }

        this._updateDimensionsHeight(diffHeight);
    },

    /**
     * Make plot dimention
     * @returns {{width: number, height: number}} plot dimension
     * @private
     */
    _makePlotDimension: function() {
        var seriesDimension = this.getDimension('series');
        return {
            width: seriesDimension.width + chartConst.HIDDEN_WIDTH,
            height: seriesDimension.height + chartConst.HIDDEN_WIDTH
        };
    },

    /**
     * Register axis components dimension.
     * @private
     */
    _registerAxisComponentsDimension: function() {
        var plotDimension = this._makePlotDimension();

        this._registerDimension('plot', plotDimension);

        this._registerDimension('xAxis', {
            width: plotDimension.width
        });

        this._registerDimension('yAxis', {
            height: plotDimension.height
        });

        this._registerDimension('rightYAxis', {
            height: plotDimension.height
        });
    },

    /**
     * Make series width.
     * @returns {number} series width
     */
    makeSeriesWidth: function() {
        var legendWidth, rightAreaWidth;

        if (predicate.isHorizontalLegend(this.options.legend.align)) {
            legendWidth = 0;
        } else {
            legendWidth = this.getDimension('legend').width;
        }

        rightAreaWidth = legendWidth + this.getDimension('rightYAxis').width;

        return this.getDimension('chart').width - (chartConst.CHART_PADDING * 2) - this.getDimension('yAxis').width - rightAreaWidth;
    },

    /**
     * Make series height
     * @returns {number} series height
     */
    makeSeriesHeight: function() {
        var legendHeight, bottomAreaWidth;

        if (predicate.isHorizontalLegend(this.options.legend.align)) {
            legendHeight = this.getDimension('legend').height;
        } else {
            legendHeight = 0;
        }

        bottomAreaWidth = legendHeight + this.dimensions.xAxis.height;

        return this.getDimension('chart').height - (chartConst.CHART_PADDING * 2) - this.getDimension('title').height - bottomAreaWidth;
    },

    /**
     * Make series dimension.
     * @returns {{width: number, height: number}} series dimension
     * @private
     */
    _makeSeriesDimension: function() {
        return {
            width: this.makeSeriesWidth(),
            height: this.makeSeriesHeight()
        };
    },

    /**
     * Register center componets dimension.
     * @private
     */
    _registerCenterComponentsDimension: function() {
        var seriesDimension = this._makeSeriesDimension();

        this._registerDimension('series', seriesDimension);
        this._registerDimension('tooltip', seriesDimension);
        this._registerDimension('customEvent', seriesDimension);
    },

    /**
     * Register axes type component positions.
     * @param {position} seriesPosition series position
     * @param {number} leftLegendWidth legend width
     * @private
     */
    _registerAxisComponentsPosition: function(seriesPosition, leftLegendWidth) {
        var seriesDimension = this.getDimension('series');

        this.positions['plot'] = {
            top: seriesPosition.top,
            left: seriesPosition.left - chartConst.HIDDEN_WIDTH
        };

        this.positions['yAxis'] = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + leftLegendWidth
        };

        this.positions['xAxis'] = {
            top: seriesPosition.top + seriesDimension.height,
            left: seriesPosition.left - chartConst.HIDDEN_WIDTH
        };

        this.positions['rightYAxis'] = {
            top: seriesPosition.top,
            left: this.chartLeftPadding + this.getDimension('yAxis').width + seriesDimension.width + leftLegendWidth - chartConst.HIDDEN_WIDTH
        };
    },

    /**
     * Make legend bound.
     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} legend bound
     * @private
     */
    _makeLegendPosition: function() {
        var dimensions = this.dimensions,
            sereisDimension = this.getDimension('series'),
            legendOption = this.options.legend,
            top = dimensions.title.height,
            left;

        if (predicate.isBottomLegendAlign(legendOption.align)) {
            top += sereisDimension.height + this.getDimension('xAxis').height + chartConst.LEGEND_AREA_PADDING;
        }

        if (predicate.isHorizontalLegend(legendOption.align)) {
            left = (this.getDimension('chart').width - this.getDimension('legend').width) / 2;
        } else if (predicate.isLeftLegendAlign(legendOption.align)) {
            left = 0;
        } else {
            left = this.getDimension('yAxis').width + sereisDimension.width + this.getDimension('rightYAxis').width + this.chartLeftPadding;
        }

        return {
            top: top,
            left: left
        };
    },

    /**
     * Register essential components positions.
     * @param {position} seriesPosition series position
     * @private
     */
    _registerEssentialComponentsPositions: function(seriesPosition) {
        var tooltipPosition;

        this.positions['series'] = seriesPosition;
        this.positions['customEvent']= seriesPosition;
        this.positions['legend'] = this._makeLegendPosition();

        if (this.hasAxes) {
            tooltipPosition = {
                top: seriesPosition.top - chartConst.SERIES_EXPAND_SIZE,
                left: seriesPosition.left - chartConst.SERIES_EXPAND_SIZE
            }
        } else {
            tooltipPosition = seriesPosition;
        }

        this.positions['tooltip'] = tooltipPosition;
    },

    /**
     * Register positions.
     * @private
     */
    _registerPositions: function() {
        var alignOption = this.options.legend.align,
            legendDimension = this.getDimension('legend'),
            topLegendHeight = predicate.isTopLegendAlign(alignOption) ? legendDimension.height : 0,
            leftLegendWidth = predicate.isLeftLegendAlign(alignOption) ? legendDimension.width : 0,
            seriesPosition = {
                top: this.getDimension('title').height + chartConst.CHART_PADDING + topLegendHeight,
                left: this.getDimension('yAxis').width + this.chartLeftPadding + leftLegendWidth
            };

        if (this.hasAxes) {
            this._updateDimensionsAndDegree();
            this._registerAxisComponentsPosition(seriesPosition, leftLegendWidth);
        }

        this._registerEssentialComponentsPositions(seriesPosition);
    },

    /**
     * Register bounds data.
     * @param {{xAxis: object, yAxis: object, rightYAxis: ?object}} axesData axes data
     */
    registerBoundsData: function() {
        this._registerCenterComponentsDimension();
        if (this.hasAxes) {
            this._registerAxisComponentsDimension();
        }
        this._registerPositions();
    }
});

module.exports = BoundsMaker;

},{"../const":19,"./calculator":35,"./predicate":41,"./renderUtil":42}],35:[function(require,module,exports){
/**
 * @fileoverview calculator.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * Calculator.
 * @module calculator
 */
var calculator = {
    /**
     * Calculate limit from chart min, max data.
     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
     * @memberOf module:calculator
     * @param {number} min min minimum value of user data
     * @param {number} max max maximum value of user data
     * @param {number} tickCount tick count
     * @returns {{min: number, max: number}} limit axis limit
     */
    calculateLimit: function(min, max) {
        var saveMin = 0,
            limit = {},
            iodValue; // increase or decrease value;

        if (min < 0) {
            saveMin = min;
            max -= min;
            min = 0;
        }

        iodValue = (max - min) / 20;
        limit.max = max + iodValue + saveMin;

        if (max / 6 > min) {
            limit.min = 0 + saveMin;
        } else {
            limit.min = min - iodValue + saveMin;
        }
        return limit;
    },

    /**
     * Normalize number.
     * @memberOf module:calculator
     * @param {number} value target value
     * @returns {number} normalized number
     */
    normalizeAxisNumber: function(value) {
        var standard = 0,
            flag = 1,
            normalized, mod;

        if (value === 0) {
            return value;
        } else if (value < 0) {
            flag = -1;
        }

        value *= flag;

        tui.util.forEachArray(chartConst.AXIS_STANDARD_MULTIPLE_NUMS, function(num) {
            if (value < num) {
                if (num > 1) {
                    standard = num;
                }
                return false;
            } else if (num === chartConst.AXIS_LAST_STANDARD_MULTIPLE_NUM) {
                standard = num;
            }
        });

        if (standard < 1) {
            normalized = this.normalizeAxisNumber(value * 10) * 0.1;
        } else {
            mod = tui.util.mod(value, standard);
            normalized = tui.util.addition(value, (mod > 0 ? standard - mod : 0));
        }

        normalized *= flag;

        return normalized;
    },

    /**
     * Make tick positions of pixel type.
     * @memberOf module:calculator
     * @param {number} size area width or height
     * @param {number} count tick count
     * @returns {Array.<number>} positions
     */
    makeTickPixelPositions: function(size, count) {
        var positions = [],
            pxLimit, pxStep;

        if (count > 0) {
            pxLimit = {min: 0, max: size - 1};
            pxStep = this.calculateStepFromLimit(pxLimit, count);
            positions = tui.util.map(tui.util.range(0, size, pxStep), function(position) {
                return Math.round(position);
            });
            positions[positions.length - 1] = size - 1;
        }
        return positions;
    },

    /**
     * Make labels from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} step step between max and min
     * @returns {string[]} labels
     * @private
     */
    makeLabelsFromLimit: function(limit, step) {
        var multipleNum = tui.util.findMultipleNum(step),
            min = limit.min * multipleNum,
            max = limit.max * multipleNum,
            labels = tui.util.range(min, max + 1, step * multipleNum);
        labels = tui.util.map(labels, function(label) {
            return label / multipleNum;
        });
        return labels;
    },

    /**
     * Calculate step from limit.
     * @memberOf module:calculator
     * @param {{min: number, max: number}} limit axis limit
     * @param {number} count value count
     * @returns {number} step
     */
    calculateStepFromLimit: function(limit, count) {
        return (limit.max - limit.min) / (count - 1);
    },

    /**
     * Calculate adjacent.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} adjacent
     *
     *   H : Hypotenuse
     *   A : Adjacent
     *   O : Opposite
     *   D : Degree
     *
     *        /|
     *       / |
     *    H /  | O
     *     /   |
     *    /\ D |
     *    -----
     *       A
     */
    calculateAdjacent: function(degree, hypotenuse) {
        return Math.cos(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Calculate opposite.
     * @param {number} degree degree
     * @param {number} hypotenuse hypotenuse
     * @returns {number} opposite
     */
    calculateOpposite: function(degree, hypotenuse) {
        return Math.sin(degree * chartConst.RAD) * hypotenuse;
    },

    /**
     * Sum plus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumPlusValues: function(values) {
        var plusValues = tui.util.filter(values, function(value) {
            return value > 0;
        });
        return tui.util.sum(plusValues);
    },

    /**
     * Sum minus values.
     * @param {Array.<number>} values values
     * @returns {number} sum
     */
    sumMinusValues: function(values) {
        var minusValues = tui.util.filter(values, function(value) {
            return value < 0;
        });
        return tui.util.sum(minusValues);
    }
};

module.exports = calculator;

},{"../const":19}],36:[function(require,module,exports){
/**
 * @fileoverview Utility methods to manipulate colors
 * @author NHN Ent. FE Development Team <dl_javascript@nhnent.com>
 */
'use strict';

var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;

/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @type {object}
 */
var colorMap = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred ': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32'
};

var colorutil = {
    /**
     * pad left zero characters.
     * @param {number} number number value to pad zero.
     * @param {number} length pad length to want.
     * @returns {string} padded string.
     */
    leadingZero: function(number, length) {
        var zero = '',
            i = 0;

        if ((number + '').length > length) {
            return number + '';
        }

        for (; i < (length - 1); i += 1) {
            zero += '0';
        }

        return (zero + number).slice(length * -1);
    },

    /**
     * Check validate of hex string value is RGB
     * @param {string} str - rgb hex string
     * @returns {boolean} return true when supplied str is valid RGB hex string
     */
    isValidRGB: function(str) {
        return hexRX.test(str);
    },

    /**
     * Convert color hex string to rgb number array
     * @param {string} hexStr - hex string
     * @returns {number[]} rgb numbers
     */
    hexToRGB: function(hexStr) {
        var r, g, b;

        if (!colorutil.isValidRGB(hexStr)) {
            return false;
        }

        hexStr = hexStr.substring(1);

        r = parseInt(hexStr.substr(0, 2), 16);
        g = parseInt(hexStr.substr(2, 2), 16);
        b = parseInt(hexStr.substr(4, 2), 16);

        return [r, g, b];
    },

    /**
     * Convert rgb number to hex string
     * @param {number} r - red
     * @param {number} g - green
     * @param {number} b - blue
     * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
     */
    rgbToHEX: function(r, g, b) {
        var hexStr = '#' +
            colorutil.leadingZero(r.toString(16), 2) +
            colorutil.leadingZero(g.toString(16), 2) +
            colorutil.leadingZero(b.toString(16), 2);

        if (colorutil.isValidRGB(hexStr)) {
            return hexStr;
        }

        return false;
    },

    /**
     * Color name to hex.
     * @param {string} colorName color name
     * @returns {string} hex
     */
    colorNameToHex: function (colorName) {
        return colorMap[colorName.toLowerCase()] || colorName;
    }
};

tui.util.defineNamespace('tui.chart');
tui.chart.colorutil = colorutil;

module.exports = colorutil;

},{}],37:[function(require,module,exports){
/**
 * @fileoverview Data processor.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var predicate = require('./predicate'),
    renderUtil = require('./renderUtil'),
    calculator = require('./calculator');

var concat = Array.prototype.concat;

/**
 * Raw data.
 * @typedef {Array.<{name: string, data: Array.<number>}>} rawSeriesData
 */

var DataProcessor = tui.util.defineClass(/** @lends DataProcessor.prototype */{
    /**
     * Data processor.
     * @constructs DataProcessor
     * @param {{
     *      categories: Array.<string>,
     *      series: (rawSeriesData | {line: ?rawSeriesData, column: ?rawSeriesData})
     * }} rawData raw data
     */
    init: function(rawData) {
        this.orgRawData = rawData;
        this.data = null;
    },

    /**
     * Get raw data.
     * @returns {{categories: Array.<string>, series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})}} raw data
     */
    getRawData: function() {
        return this.orgRawData;
    },

    /**
     * Process raw data.
     * @param {Array.<Array>} rawData raw data
     * @param {object} options options
     * @param {Array.<string>} seriesChartTypes chart types
     */
    process: function(rawData, options, seriesChartTypes) {
        var chartType = options.chartType,
            categories = this._processCategories(rawData.categories),
            seriesData = rawData.series,
            values = this._pickValues(seriesData),
            wholeValues = this._makeWholeValues(values, seriesChartTypes),
            legendLabels = this._pickLegendLabels(seriesData),
            wholeLegendData = this._makeWholeLegendData(legendLabels, chartType, seriesChartTypes),
            format = options.chart && options.chart.format || '',
            formatFunctions = this._findFormatFunctions(format),
            seriesOption = options.series || {},
            formattedValues, wholeFormattedValues;

        this.divergingOption = predicate.isBarTypeChart(options.chartType) && seriesOption.diverging;
        formattedValues = this._formatValues(values, formatFunctions);
        wholeFormattedValues = this._makeWholeValues(formattedValues, seriesChartTypes);

        this.data = {
            categories: categories,
            values: values,
            wholeValues: wholeValues,
            legendLabels: legendLabels,
            wholeLegendData: wholeLegendData,
            formatFunctions: formatFunctions,
            formattedValues: formattedValues,
            wholeFormattedValues: wholeFormattedValues,
            percentValues: {}
        };
    },

    /**
     * Get Categories
     * @returns {Array.<string>}}
     */
    getCategories: function() {
        return this.data.categories;
    },

    /**
     * Get category.
     * @param {number} index index
     * @returns {string} category
     */
    getCategory: function(index) {
        return this.data.categories[index];
    },

    /**
     * Get group values.
     * @param {string} chartType chart type
     * @returns {Array.Array.<number>} group values
     */
    getGroupValues: function(chartType) {
        return this.data.values[chartType] || this.data.values;
    },

    /**
     * Get value.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {?string} chartType chart type
     * @returns {number} value
     */
    getValue: function(groupIndex, index, chartType) {
        var groupValues = this.getGroupValues(chartType);
        return groupValues[groupIndex][index];
    },

    /**
     * Get whole group values.
     * @returns {Array.<Array.<number>>} gruop values
     */
    getWholeGroupValues: function() {
        return this.data.wholeValues;
    },

    /**
     * Get legend labels.
     * @param {?string} chartType chart type
     * @returns {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}} legend labels
     */
    getLegendLabels: function(chartType) {
        return this.data.legendLabels[chartType] || this.data.legendLabels;
    },

    /**
     * Get whole legend data.
     * @returns {Array.<string>} legend data
     */
    getWholeLegendData: function() {
        return this.data.wholeLegendData;
    },

    /**
     * Set whole legend data.
     * @param {Array.<{chartType: string, label: string}>} wholeLegendData legend data
     */
    setWholeLegendData: function(wholeLegendData) {
        this.data.wholeLegendData = wholeLegendData;
    },

    /**
     * Get legend data.
     * @param {number} index index
     * @returns {{chartType: string, label: string}} legend data
     */
    getLegendData: function(index) {
        return this.data.wholeLegendData[index];
    },

    /**
     * Get format functions.
     * @returns {Array.<function>} functions
     */
    getFormatFunctions: function() {
        return this.data.formatFunctions;
    },

    /**
     * Get formatted group values
     * @param {string} chartType chart type
     * @returns {Array.<string>} group values
     */
    getFormattedGroupValues: function(chartType) {
        return this.data.formattedValues[chartType] || this.data.formattedValues;
    },

    /**
     * Get formatted value.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {?string} chartType chartType
     * @returns {string} formatted value
     */
    getFormattedValue: function(groupIndex, index, chartType) {
        var formattedGroupValues = this.getFormattedGroupValues(chartType);
        return formattedGroupValues[groupIndex][index];
    },

    /**
     * Get first formatted vlaue.
     * @param {?string} chartType chartType
     * @returns {string} formatted value
     */
    getFirstFormattedValue: function(chartType) {
        return this.getFormattedValue(0, 0, chartType);
    },

    /**
     * Get whole formatted values.
     * @returns {Array.Array.<string>} formatted values
     */
    getWholeFormattedValues: function() {
        return this.data.wholeFormattedValues;
    },

    /**
     * Process categories
     * @param {Array.<string>} categories categories
     * @returns {Array.<string>} processed categories
     * @private
     */
    _processCategories: function(categories) {
        return tui.util.map(categories, tui.util.encodeHTMLEntity);
    },

    /**
     * Pick value.
     * @param {{name: string, data: (Array.<number> | number)}} items items
     * @returns {Array} picked value
     * @private
     */
    _pickValue: function(items) {
        return tui.util.map([].concat(items.data), parseFloat);
    },

    /**
     * Pick values from axis data.
     * @param {Array.<Array>} seriesData series data
     * @returns {string[]} values
     */
    _pickValues: function(seriesData) {
        var values, result;
        if (tui.util.isArray(seriesData)) {
            values = tui.util.map(seriesData, this._pickValue, this);
            result = tui.util.pivot(values);
        } else {
            result = {};
            tui.util.forEach(seriesData, function(groupValues, type) {
                values = tui.util.map(groupValues, this._pickValue, this);
                result[type] = tui.util.pivot(values);
            }, this);
        }
        return result;
    },

    /**
     * Make whole values.
     * @param {Array.<Array>} groupValues values
     * @param {Array.<string>} seriesChartTypes chart types
     * @returns {Array.<number>} join values
     * @private
     */
    _makeWholeValues: function(groupValues, seriesChartTypes) {
        var wholeValues = [];

        if (!seriesChartTypes) {
            wholeValues = groupValues;
        } else {
            tui.util.forEachArray(seriesChartTypes, function(_chartType) {
                tui.util.forEach(groupValues[_chartType], function(values, index) {
                    if (!wholeValues[index]) {
                        wholeValues[index] = [];
                    }
                    wholeValues[index] = wholeValues[index].concat(values);
                });
            });
        }

        return wholeValues;
    },

    /**
     * Pick legend label.
     * @param {object} item item
     * @returns {string} label
     * @private
     */
    _pickLegendLabel: function(item) {
        return tui.util.encodeHTMLEntity(item.name);
    },

    /**
     * Pick legend labels from axis data.
     * @param {Array.<Array>} seriesData series data
     * @returns {string[]} labels
     */
    _pickLegendLabels: function(seriesData) {
        var result;
        if (tui.util.isArray(seriesData)) {
            result = tui.util.map(seriesData, this._pickLegendLabel, this);
        } else {
            result = {};
            tui.util.forEach(seriesData, function(groupValues, type) {
                result[type] = tui.util.map(groupValues, this._pickLegendLabel, this);
            }, this);
        }
        return result;
    },

    /**
     * Make whole legend data.
     * @param {Array} legendLabels legend labels
     * @param {string} chartType chart type
     * @param {Array.<string>} seriesChartTypes chart types
     * @returns {Array} labels
     * @private
     */
    _makeWholeLegendData: function(legendLabels, chartType, seriesChartTypes) {
        var wholeLabels;
        if (!seriesChartTypes || !seriesChartTypes.length) {
            wholeLabels = tui.util.map(legendLabels, function(label) {
                return {
                    chartType: chartType,
                    label: label
                };
            });
        } else {
            wholeLabels = [];
            tui.util.forEachArray(seriesChartTypes, function(_chartType) {
                var labels = tui.util.map(legendLabels[_chartType], function(label) {
                    return {
                        chartType: _chartType,
                        label: label
                    };
                });
                wholeLabels = wholeLabels.concat(labels);
            });
        }
        return wholeLabels;
    },

    /**
     * Format group values.
     * @param {Array.<Array>} groupValues group values
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted values
     * @private
     */
    _formatGroupValues: function(groupValues, formatFunctions) {
        return tui.util.map(groupValues, function(values) {
            if (this.divergingOption) {
                values = tui.util.map(values, Math.abs);
            }
            return tui.util.map(values, function(value) {
                var fns = [value].concat(formatFunctions);
                return tui.util.reduce(fns, function(stored, fn) {
                    return fn(stored);
                });
            });
        }, this);
    },

    /**
     * Format converted values.
     * @param {Array.<Array>} chartValues chart values
     * @param {function[]} formatFunctions format functions
     * @returns {string[]} formatted values
     * @private
     */
    _formatValues: function(chartValues, formatFunctions) {
        var result;
        formatFunctions = formatFunctions || [];
        if (tui.util.isArray(chartValues)) {
            result = this._formatGroupValues(chartValues, formatFunctions);
        } else {
            result = {};
            tui.util.forEach(chartValues, function(groupValues, chartType) {
                result[chartType] = this._formatGroupValues(groupValues, formatFunctions);
            }, this);
        }
        return result;
    },

    /**
     * Pick max length under point.
     * @param {string[]} values chart values
     * @returns {number} max length under point
     * @private
     */
    _pickMaxLenUnderPoint: function(values) {
        var max = 0;

        tui.util.forEachArray(values, function(value) {
            var len = tui.util.lengthAfterPoint(value);
            if (len > max) {
                max = len;
            }
        }, this);

        return max;
    },

    /**
     * Whether zero fill format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isZeroFill: function(format) {
        return format.length > 2 && format.charAt(0) === '0';
    },

    /**
     * Whether decimal format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isDecimal: function(format) {
        var indexOf = format.indexOf('.');
        return indexOf > -1 && indexOf < format.length - 1;
    },

    /**
     * Whether comma format or not.
     * @param {string} format format
     * @returns {boolean} result boolean
     * @private
     */
    _isComma: function(format) {
        return format.indexOf(',') === format.split('.')[0].length - 4;
    },

    /**
     * Format zero fill.
     * @param {number} len length of result
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatZeroFill: function(len, value) {
        var zero = '0',
            isMinus = value < 0;

        value = Math.abs(value) + '';

        if (value.length >= len) {
            return value;
        }

        while (value.length < len) {
            value = zero + value;
        }

        return (isMinus ? '-' : '') + value;
    },

    /**
     * Format Decimal.
     * @param {number} len length of under decimal point
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatDecimal: function(len, value) {
        var pow;

        if (len === 0) {
            return Math.round(value, 10);
        }

        pow = Math.pow(10, len);
        value = Math.round(value * pow) / pow;
        value = parseFloat(value).toFixed(len);
        return value;
    },

    /**
     * Format Comma.
     * @param {string} value target value
     * @returns {string} formatted value
     * @private
     */
    _formatComma: function(value) {
        var comma = ',',
            underPointValue = '',
            values, lastIndex;

        value += '';

        if (value.indexOf('.') > -1) {
            values = value.split('.');
            value = values[0];
            underPointValue = '.' + values[1];
        }

        if (value.length < 4) {
            return value + underPointValue;
        }

        values = (value).split('').reverse();
        lastIndex = values.length - 1;
        values = tui.util.map(values, function(char, index) {
            var result = [char];
            if (index < lastIndex && (index + 1) % 3 === 0) {
                result.push(comma);
            }
            return result;
        });

        return concat.apply([], values).reverse().join('') + underPointValue;
    },

    /**
     * Find format functions.
     * @param {string} format format
     * @param {string[]} values chart values
     * @returns {function[]} functions
     */
    _findFormatFunctions: function(format) {
        var funcs = [],
            len;

        if (!format) {
            return [];
        }

        if (this._isDecimal(format)) {
            len = this._pickMaxLenUnderPoint([format]);
            funcs = [tui.util.bind(this._formatDecimal, this, len)];
        } else if (this._isZeroFill(format)) {
            len = format.length;
            funcs = [tui.util.bind(this._formatZeroFill, this, len)];
            return funcs;
        }

        if (this._isComma(format)) {
            funcs.push(this._formatComma);
        }

        return funcs;
    },

    /**
     * Make multiline category.
     * @param {string} category category
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @returns {string} multiline category
     * @private
     */
    _makeMultilineCategory: function(category, limitWidth, theme) {
        var words = category.split(/\s+/),
            lineWords = words[0],
            lines = [];

        tui.util.forEachArray(words.slice(1), function(word) {
            var width = renderUtil.getRenderedLabelWidth(lineWords + ' ' + word, theme);

            if (width > limitWidth) {
                lines.push(lineWords);
                lineWords = word;
            } else {
                lineWords += ' ' + word;
            }
        });

        if (lineWords) {
            lines.push(lineWords);
        }

        return lines.join('<br>');
    },

    /**
     * Get multiline categories.
     * @param {number} limitWidth limit width
     * @param {object} theme label theme
     * @returns {Array} multiline categories
     */
    getMultilineCategories: function(limitWidth, theme) {
        if (!this.data.multilineCategories) {
            this.data.multilineCategories = tui.util.map(this.getCategories(), function(category) {
                return this._makeMultilineCategory(category, limitWidth, theme);
            }, this);
        }

        return this.data.multilineCategories;
    },

    /**
     * Make percent value.
     * @param {Array.<Array.<number>>} groupValues gruop values
     * @returns {Array.<Array.<number>>} percent values
     * @private
     */
    _makePieChartPercentValues: function(groupValues) {
        var result = tui.util.map(groupValues, function(values) {
            var sum = tui.util.sum(values);

            return tui.util.map(values, function(value) {
                return value / sum;
            });
        });
        return result;
    },

    /**
     * Make percent values for normal stacked option.
     * @param {Array.<Array.<number>>} groupValues gruop values
     * @param {{min: number, max: number}} limit axis limit
     * @returns {Array} percent values about normal stacked option.
     * @private
     */
    _makeNormalStackedPercentValues: function(groupValues, limit) {
        var distance = Math.abs(limit.max - limit.min);

        return tui.util.map(groupValues, function(values) {
            return tui.util.map(values, function(value) {
                return value / distance;
            });
        });
    },

    /**
     * Make percent values for percent stacked option.
     * @param {Array.<Array.<number>>} groupValues gruop values
     * @returns {Array} percent values about percent stacked option
     * @private
     */
    _makePercentStackedPercentValues: function(groupValues) {
        var flattenValues = concat.apply([], groupValues),
            plusSum = calculator.sumPlusValues(flattenValues),
            minusSum = Math.abs(calculator.sumMinusValues(flattenValues)),
            ratio = (plusSum > 0 && minusSum > 0) ? 0.5 : 1;

        return tui.util.map(groupValues, function(values) {
            var sum = tui.util.sum(tui.util.map(values, function(value) {
                return Math.abs(value);
            }));

            return tui.util.map(values, function(value) {
                return sum === 0 ? 0 : ratio * (value / sum);
            });
        });
    },

    /**
     * Make percent values for percent diverging stacked option.
     * @param {Array.<Array.<number>>} groupValues group values
     * @returns {Array.<Array.<number>>} percent values
     * @private
     */
    _makePercentDivergentStackedPercentValues: function(groupValues) {
        return tui.util.map(groupValues, function(values) {
            var plusSum = calculator.sumPlusValues(values),
                minusSum = Math.abs(calculator.sumMinusValues(values));

            return tui.util.map(values, function(value) {
                var sum = value >= 0 ? plusSum : minusSum;
                return sum === 0 ? 0 : 0.5 * (value / sum);
            });
        });
    },

    /**
     * Make percent value.
     * @param {Array.<Array.<number>>} groupValues group values
     * @param {{min: number, max: number}} limit axis limit
     * @param {boolean} isLineTypeChart whether line type chart or not.
     * @returns {Array.<Array.<number>>} percent values
     * @private
     */
    _makePercentValues: function(groupValues, limit, isLineTypeChart) {
        var min = limit.min,
            max = limit.max,
            distance = max - min,
            flag = 1,
            subValue = 0,
            percentValues;

        if (!isLineTypeChart && min < 0 && max <= 0) {
            flag = -1;
            subValue = max;
            distance = min - max;
        } else if (isLineTypeChart || min >= 0) {
            subValue = min;
        }

        percentValues = tui.util.map(groupValues, function(values) {
            return tui.util.map(values, function(value) {
                return (value - subValue) * flag / distance;
            });
        });

        return percentValues;
    },

    /**
     * Register percent values.
     * @param {string} chartType chart type
     */
    registerPieChartPercentValues: function(chartType) {
        var groupValues = this.getGroupValues(chartType);
        this.data.percentValues[chartType] = this._makePieChartPercentValues(groupValues);
    },

    /**
     * Register percent values.
     * @param {{min: number, max: number}} limit axis limit
     * @param {string} stacked stacked option
     * @param {string} chartType chart type
     * @private
     */
    registerPercentValues: function(limit, stacked, chartType) {
        var result,
            groupValues = this.getGroupValues(chartType),
            isAllowedStackedOption = predicate.isAllowedStackedOption(chartType),
            isLineTypeChart = predicate.isLineTypeChart(chartType);

        if (isAllowedStackedOption && predicate.isNormalStacked(stacked)) {
            result = this._makeNormalStackedPercentValues(groupValues, limit);
        } else if (isAllowedStackedOption && predicate.isPercentStacked(stacked)) {
            if (this.divergingOption) {
                result = this._makePercentDivergentStackedPercentValues(groupValues);
            } else {
                result = this._makePercentStackedPercentValues(groupValues);
            }
        } else {
            result = this._makePercentValues(groupValues, limit, isLineTypeChart);
        }

        this.data.percentValues[chartType] = isLineTypeChart ? tui.util.pivot(result) : result;
    },

    /**
     * Get percent values.
     * @param {string} chartType chart type
     * @returns {Array.<Array.<number>>} percent values
     */
    getPercentValues: function(chartType) {
        return this.data.percentValues[chartType];
    }
});

module.exports = DataProcessor;

},{"./calculator":35,"./predicate":41,"./renderUtil":42}],38:[function(require,module,exports){
/**
 * @fileoverview DOM Handler.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var aps = Array.prototype.slice;

/**
 * DOM Handler.
 * @module domHandler
 */
var domHandler = {
    /**
     * Create element.
     * @memberOf module:domHandler
     * @param {string} tag html tag
     * @param {string} newClass class name
     * @returns {HTMLElement} created element
     */
    create: function(tag, newClass) {
        var el = document.createElement(tag);

        if (newClass) {
            this.addClass(el, newClass);
        }

        return el;
    },

    /**
     * Get class names.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @returns {Array} names
     * @private
     */
    _getClassNames: function(el) {
        var className, classNames;

        if (el.classList) {
            classNames = aps.call(el.classList);
        } else {
            className = el.className || '';
            classNames = className && tui.util.isString(className) ? className.split(' ') : [];
        }

        return classNames;
    },

    /**
     * Add css class to target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} newClass add class name
     */
    addClass: function(el, newClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(newClass, classNames);

        if (index > -1) {
            return;
        }

        classNames.push(newClass);
        el.className = classNames.join(' ');
    },

    /**
     * Remove css class from target element.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} rmClass remove class name
     */
    removeClass: function(el, rmClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(rmClass, classNames);

        if (index === -1) {
            return;
        }

        classNames.splice(index, 1);
        el.className = classNames.join(' ');
    },

    /**
     * Whether class exist or not.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} findClass target css class
     * @returns {boolean} has class
     */
    hasClass: function(el, findClass) {
        var classNames = this._getClassNames(el),
            index = tui.util.inArray(findClass, classNames);
        return index > -1;
    },

    /**
     * Find parent by class name.
     * @memberOf module:domHandler
     * @param {HTMLElement} el target element
     * @param {string} className target css class
     * @param {string} lastClass last css class
     * @returns {HTMLElement} result element
     */
    findParentByClass: function(el, className, lastClass) {
        var parent = el.parentNode,
            result;

        if (!parent) {
            result = null;
        } else if (this.hasClass(parent, className)) {
            result = parent;
        } else if (parent.nodeName === 'BODY' || this.hasClass(parent, lastClass)) {
            result = null;
        } else {
            result = this.findParentByClass(parent, className, lastClass);
        }

        return result;
    },

    /**
     * Append child element.
     * @memberOf module:domHandler
     * @param {HTMLElement} container container element
     * @param {HTMLElement} children child element
     */
    append: function(container, children) {
        if (!container || !children) {
            return;
        }
        children = tui.util.isArray(children) ? children : [children];

        tui.util.forEachArray(children, function(child) {
            if (!child) {
                return;
            }
            container.appendChild(child);
        }, this);
    }
};

module.exports = domHandler;

},{}],39:[function(require,module,exports){
/**
 * @fileoverview Event listener.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Event listener.
 * @module eventListener
 */
var eventListener = {
    /**
     * Event listener for IE.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @private
     */
    _attachEvent: function (eventName, el, callback) {
        el.attachEvent('on' + eventName, callback);
    },

    /**
     * Event listener for other browsers.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     * @private
     */
    _addEventListener: function (eventName, el, callback) {
        try {
            el.addEventListener(eventName, callback);
        } catch (e) {
            throw e;
        }
    },
    /**
     * Bind event function.
     * @memberOf module:eventListener
     * @param {string} eventName event name
     * @param {HTMLElement} el target element
     * @param {function} callback callback function
     */
    bindEvent: function (eventName, el, callback) {
        var bindEvent;
        if ('addEventListener' in el) {
            bindEvent = this._addEventListener;
        } else if ('attachEvent' in el) {
            bindEvent = this._attachEvent;
        }
        this.bindEvent = bindEvent;
        bindEvent(eventName, el, callback);
    }
};

module.exports = eventListener;

},{}],40:[function(require,module,exports){
/**
 * @fileoverview Data processor for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var DataProcessor = require('./dataProcessor'),
    renderUtil = require('./renderUtil');

/**
 * Raw data.
 * @typedef {Array.<{name: string, data: Array.<number>}>} rawSeriesData
 */

/**
 * @classdesc Data processor for map chart.
 * @class MapChartDataProcessor
 */
var MapChartDataProcessor = tui.util.defineClass(DataProcessor, /** @lends MapChartDataProcessor.prototype */{
    /**
     * Process raw data.
     * @param {{series: Array.<{code: string, name: ?string, data: number}>}} rawData raw data
     * @param {{chart: {format: string}}} options options
     */
    process: function(rawData, options) {
        var seriesData = rawData.series,
            valueMap = this._makeValueMap(seriesData, options);

        this.data = {
            valueMap: valueMap
        };
    },

    /**
     * Make value map.
     * @param {Array.<{code: string, name: ?string, data: number}>} rawSeriesData raw series data
     * @param {{chart: {format: string}}} options options
     * @returns {{value: number, formattedValue: string, name: ?string}} value map
     * @private
     */
    _makeValueMap: function(rawSeriesData, options) {
        var valueMap = {},
            format = options.chart && options.chart.format || '',
            formatFunctions = this._findFormatFunctions(format);

        tui.util.forEachArray(rawSeriesData, function(datum) {
            var result = {
                value: datum.data,
                formattedValue: renderUtil.formatValue(datum.data, formatFunctions)
            };

            if (datum.name) {
                result.name = datum.name;
            }

            if (datum.labelCoordinate) {
                result.labelCoordinate = datum.labelCoordinate;
            }

            valueMap[datum.code] = result;
        });

        return valueMap;
    },

    /**
     * Get value map.
     * @returns {number} value
     */
    getValueMap: function() {
        return this.data.valueMap;
    },

    /**
     * Get values.
     * @returns {Array.<number>} picked values.
     */
    getValues: function() {
        return tui.util.pluck(this.data.valueMap, 'value');
    },

    /**
     * Get valueMap datum.
     * @param {string} code map code
     * @returns {{code: string, name: string, formattedValue: number, labelCoordinate: {x: number, y: number}}} valueMap datum
     */
    getValueMapDatum: function(code) {
        return this.data.valueMap[code];
    },

    /**
     * Make percent value.
     * @param {{min: number, max: number}} limit axis limit
     */
    registerPercentValues: function(limit) {
        var min = limit.min,
            max = limit.max - min;
        tui.util.forEach(this.getValueMap(), function(map) {
            map.percentValue = (map.value - min) / max;
        }, this);
    }
});

module.exports = MapChartDataProcessor;

},{"./dataProcessor":37,"./renderUtil":42}],41:[function(require,module,exports){
/**
 * @fileoverview Predicate.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

/**
 * predicate.
 * @module predicate
 */
var predicate = {
    /**
     * Whether bar chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBarChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_BAR;
    },

    /**
     * Whether column chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isColumnChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COLUMN;
    },

    /**
     * Whether bar type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isBarTypeChart: function(chartType) {
        return this.isBarChart(chartType) || this.isColumnChart(chartType);
    },

    /**
     * Whether combo chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isComboChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_COMBO;
    },

    /**
     * Whether line chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_LINE;
    },

    /**
     * Whether area chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isAreaChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_AREA;
    },

    /**
     * Whether line type chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isLineTypeChart: function(chartType) {
        return this.isLineChart(chartType) || this.isAreaChart(chartType);
    },

    /**
     * Whether pie chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isPieChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_PIE;
    },

    /**
     * Whether map chart or not.
     * @memberOf module:predicate
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isMapChart: function(chartType) {
        return chartType === chartConst.CHART_TYPE_MAP;
    },

    /**
     * Whether mouse position chart or not.
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isMousePositionChart: function(chartType) {
        return this.isPieChart(chartType) || this.isMapChart(chartType);
    },

    /**
     * Whether outer legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isOuterLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_OUTER;
    },

    /**
     * Whether center legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isCenterLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_CENTER;
    },

    /**
     * Whether left legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isLeftLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_LEFT;
    },

    /**
     * Whether top legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isTopLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_TOP;
    },

    /**
     * Whether bottom legend align or not.
     * @memberOf module:predicate
     * @param {string} align legend type
     * @returns {boolean} result boolean
     */
    isBottomLegendAlign: function(align) {
        return align === chartConst.LEGEND_ALIGN_BOTTOM;
    },

    /**
     * Whether horizontal legend align or not.
     * @param {string} align align
     * @returns {boolean} result boolean
     */
    isHorizontalLegend: function(align) {
        return this.isTopLegendAlign(align) || this.isBottomLegendAlign(align);
    },

    /**
     * Whether legend align of pie chart or not.
     * @memberOf module:predicate
     * @param {?string} align chart type
     * @returns {boolean} result boolean
     */
    isPieLegendAlign: function(align) {
        var result = false;
        if (align) {
            result = this.isOuterLegendAlign(align) || this.isCenterLegendAlign(align);
        }
        return result;
    },

    /**
     * Whether allowed stacked option or not.
     * @param {string} chartType chart type
     * @returns {boolean} result boolean
     */
    isAllowedStackedOption: function(chartType) {
        return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isAreaChart(chartType);
    },

    /**
     * Whether normal stacked or not.
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isNormalStacked: function(stacked) {
        return stacked === chartConst.STACKED_NORMAL_TYPE;
    },

    /**
     * Whether percent stacked or not.
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isPercentStacked: function(stacked) {
        return stacked === chartConst.STACKED_PERCENT_TYPE;
    },

    /**
     * Whether valid stacked option or not.
     * @param {boolean} stacked stacked option
     * @returns {boolean} result boolean
     */
    isValidStackedOption: function(stacked) {
        return stacked && (this.isNormalStacked(stacked) || this.isPercentStacked(stacked));
    }
};

module.exports = predicate;

},{"../const":19}],42:[function(require,module,exports){
/**
 * @fileoverview Util for rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('./domHandler'),
    chartConst = require('./../const');

var browser = tui.util.browser,
    isIE7 = browser.msie && browser.version === 7,
    isOldBrowser = browser.msie && browser.version <= 8;

/**
 * Util for rendering.
 * @module renderUtil
 */
var renderUtil = {
    /**
     * Concat string.
     * @memberOf module:renderUtil
     * @params {...string} target strings
     * @returns {string} concat string
     */
    concatStr: function() {
        return String.prototype.concat.apply('', arguments);
    },

    /**
     * Make cssText for font.
     * @memberOf module:renderUtil
     * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
     * @returns {string} cssText
     */
    makeFontCssText: function(theme) {
        var cssTexts = [];

        if (!theme) {
            return '';
        }

        if (theme.fontSize) {
            cssTexts.push(this.concatStr('font-size:', theme.fontSize, 'px'));
        }

        if (theme.fontFamily) {
            cssTexts.push(this.concatStr('font-family:', theme.fontFamily));
        }

        if (theme.color) {
            cssTexts.push(this.concatStr('color:', theme.color));
        }

        return cssTexts.join(';');
    },

    checkEl: null,
    /**
     * Create element for size check.
     * @memberOf module:renderUtil
     * @returns {HTMLElement} element
     * @private
     */
    _createSizeCheckEl: function() {
        var div, span;
        if (!this.checkEl) {
            div = dom.create('DIV', 'tui-chart-size-check-element');
            span = dom.create('SPAN');
            div.appendChild(span);
            this.checkEl = div;
        } else {
            this.checkEl.style.cssText = '';
        }

        return this.checkEl;
    },

    /**
     * Make caching key.
     * @param {string} label labek
     * @param {{fontSize: number, fontFamily: string}} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(label, theme, offsetType) {
        var keys = [label, offsetType];

        tui.util.forEach(theme, function(key, value) {
            keys.push(key + value);
        });

        return keys.join('-');
    },

    /**
     * Size cache.
     * @type {object}
     */
    sizeCache: {},

    /**
     * Add css style.
     * @param {HTMLElement} div div element
     * @param {{fontSize: number, fontFamily: string, cssText: string}} theme theme
     * @private
     */
    _addCssStyle: function(div, theme) {
        div.style.fontSize = (theme.fontSize || chartConst.DEFAULT_LABEL_FONT_SIZE) + 'px';

        if (theme.fontFamily) {
            div.style.fontFamily = theme.fontFamily;
        }

        if (theme.cssText) {
            div.style.cssText += theme.cssText;
        }
    },

    /**
     * Get rendered label size (width or height).
     * @memberOf module:renderUtil
     * @param {string | number} label label
     * @param {object} theme theme
     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
     * @returns {number} size
     * @private
     */
    _getRenderedLabelSize: function(label, theme, offsetType) {
        var key, div, span, labelSize;

        theme = theme || {};

        label += '';

        if (!label) {
            return 0;
        }

        key = this._makeCachingKey(label, theme, offsetType);
        labelSize = this.sizeCache[key];

        if (!labelSize) {
            div = this._createSizeCheckEl();
            span = div.firstChild;

            span.innerHTML = label;

            this._addCssStyle(div, theme);

            document.body.appendChild(div);
            labelSize = span[offsetType];
            document.body.removeChild(div);

            this.sizeCache[key] = labelSize;
        }

        return labelSize;
    },

    /**
     * Get rendered label width.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} width
     */
    getRenderedLabelWidth: function(label, theme) {
        var labelWidth = this._getRenderedLabelSize(label, theme, 'offsetWidth');
        return labelWidth;
    },

    /**
     * Get rendered label height.
     * @memberOf module:renderUtil
     * @param {string} label label
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} height
     */
    getRenderedLabelHeight: function(label, theme) {
        var labelHeight = this._getRenderedLabelSize(label, theme, 'offsetHeight');
        return labelHeight;
    },

    /**
     * Get Rendered Labels Max Size(width or height).
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @param {function} iteratee iteratee
     * @returns {number} max size (width or height)
     * @private
     */
    _getRenderedLabelsMaxSize: function(labels, theme, iteratee) {
        var sizes = tui.util.map(labels, function(label) {
                return iteratee(label, theme);
            }, this),
            maxSize = tui.util.max(sizes);
        return maxSize;
    },

    /**
     * Get rendered labels max width.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max width
     * @private
     */
    getRenderedLabelsMaxWidth: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelWidth, this),
            maxWidth = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxWidth;
    },

    /**
     * Get rendered labels max height.
     * @memberOf module:boundsMaker
     * @param {string[]} labels labels
     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
     * @returns {number} max height
     */
    getRenderedLabelsMaxHeight: function(labels, theme) {
        var iteratee = tui.util.bind(this.getRenderedLabelHeight, this),
            maxHeight = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
        return maxHeight;
    },

    /**
     * Render dimension.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{width: number, height: number}} dimension dimension
     */
    renderDimension: function(el, dimension) {
        el.style.cssText = [
            this.concatStr('width:', dimension.width, 'px'),
            this.concatStr('height:', dimension.height, 'px')
        ].join(';');
    },

    /**
     * Render position(top, right).
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {{top: number, left: number, right: number}} position position
     */
    renderPosition: function(el, position) {
        if (tui.util.isUndefined(position)) {
            return;
        }

        if (!tui.util.isUndefined(position.top)) {
            el.style.top = position.top + 'px';
        }

        if (!tui.util.isUndefined(position.left)) {
            el.style.left = position.left + 'px';
        }

        if (!tui.util.isUndefined(position.right)) {
            el.style.right = position.right + 'px';
        }
    },

    /**
     * Render background.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} background background option
     */
    renderBackground: function(el, background) {
        if (!background) {
            return;
        }

        el.style.background = background;
    },

    /**
     * Render font family.
     * @memberOf module:renderUtil
     * @param {HTMLElement} el target element
     * @param {string} fontFamily font family option
     */
    renderFontFamily: function(el, fontFamily) {
        if (!fontFamily) {
            return;
        }

        el.style.fontFamily = fontFamily;
    },

    /**
     * Render title.
     * @memberOf module:renderUtil
     * @param {string} title title
     * @param {{fontSize: number, color: string, background: string}} theme title theme
     * @param {string} className css class name
     * @returns {HTMLElement} title element
     */
    renderTitle: function(title, theme, className) {
        var elTitle, cssText;

        if (!title) {
            return null;
        }

        elTitle = dom.create('DIV', className);
        elTitle.innerHTML = title;

        cssText = renderUtil.makeFontCssText(theme);

        if (theme.background) {
            cssText += ';' + this.concatStr('background:', theme.background);
        }

        elTitle.style.cssText = cssText;

        return elTitle;
    },

    /**
     * Expand dimension.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound series bound
     * @returns {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} expended bound
     */
    expandBound: function(bound) {
        var dimension = bound.dimension,
            position = bound.position;
        return {
            dimension: {
                width: dimension.width + chartConst.SERIES_EXPAND_SIZE * 2,
                height: dimension.height + chartConst.SERIES_EXPAND_SIZE * 2
            },
            position: {
                left: position.left - chartConst.SERIES_EXPAND_SIZE,
                top: position.top - chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make custom event name.
     * @param {string} prefix prefix
     * @param {string} value value
     * @param {string} suffix suffix
     * @returns {string} custom event name
     */
    makeCustomEventName: function(prefix, value, suffix) {
        return prefix + tui.util.properCase(value) + tui.util.properCase(suffix);
    },

    /**
     * Format value.
     * @param {number} value value
     * @param {Array.<function>} formatFunctions functions for format
     * @returns {string} formatted value
     */
    formatValue: function(value, formatFunctions) {
        var fns = [value].concat(formatFunctions || []);

        return tui.util.reduce(fns, function(stored, fn) {
            return fn(stored);
        });
    },

    /**
     * Cancel animation
     * @param {{id: number}} animation animaion object
     */
    cancelAnimation: function(animation) {
        if (animation && animation.id) {
            cancelAnimationFrame(animation.id);
            delete animation.id;
        }
    },

    /**
     * Start animation.
     * @param {number} animationTime animation time
     * @param {function} callback callback function
     * @returns {{id: number}} requestAnimationFrame id
     */
    startAnimation: function(animationTime, callback) {
        var animation = {},
            startTime;

        function animate() {
            var diffTime = (new Date()).getTime() - startTime,
                ratio = Math.min((diffTime / animationTime), 1);

            callback(ratio);

            if (ratio === 1) {
                delete animation.id;
            } else {
                animation.id = requestAnimationFrame(animate);
            }
        }

        startTime = (new Date()).getTime();
        animation.id = requestAnimationFrame(animate);

        return animation;
    },

    /**
     * Whether IE7 or not.
     * @returns {boolean} result boolean
     */
    isIE7: function() {
        return isIE7;
    },

    /**
     * Whether oldBrowser or not.
     * @memberOf module:renderUtil
     * @returns {boolean} result boolean
     */
    isOldBrowser: function() {
        return isOldBrowser;
    }
};

tui.util.defineNamespace('tui.chart');
tui.chart.renderUtil = renderUtil;

module.exports = renderUtil;

},{"./../const":19,"./domHandler":38}],43:[function(require,module,exports){
/**
 * @fileoverview This is template maker.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

module.exports = {
    /**
     * This is template maker.
     * @param {string} html html
     * @returns {function} template function
     * @eaxmple
     *
     *   var template = templateMaker.template('<span>{{ name }}</span>'),
     *       result = template({name: 'John');
     *   console.log(result); // <span>John</span>
     *
     */
    template: function (html) {
        return function (data) {
            var result = html;
            tui.util.forEach(data, function (value, key) {
                var regExp = new RegExp('{{\\s*' + key + '\\s*}}', 'g');
                result = result.replace(regExp, value);
            });
            return result;
        };
    }
};

},{}],44:[function(require,module,exports){
/**
 * @fileoverview UserEventListener is listener of user event.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var UserEventListener = tui.util.defineClass(/** @lends UserEventListener.prototype */ {
    /**
     * Register user event.
     * @param {string} eventName event name
     * @param {function} func event callback
     */
    register: function(eventName, func) {
        this.on(eventName, func);
    }
});

tui.util.CustomEvents.mixin(UserEventListener);

module.exports = UserEventListener;

},{}],45:[function(require,module,exports){
/**
 * @fileoverview  Legend component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var LegendModel = require('./legendModel'),
    LegendDimensionModel = require('./legendDimensionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    eventListener = require('../helpers/eventListener'),
    renderUtil = require('../helpers/renderUtil'),
    legendTemplate = require('./../legends/legendTemplate');

var Legend = tui.util.defineClass(/** @lends Legend.prototype */ {
    /**
     * Legend component.
     * @constructs Legend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.chartTypes chart types
     *      @param {string} params.chart type
     */
    init: function(params) {
        var legendData;

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {Object}
         */
        this.options = params.options || {};

        /**
         * chart types
         * @type {?Array.<string>}
         */
        this.chartTypes = params.chartTypes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * user event object
         */
        this.userEvent = params.userEvent;

        /**
         * Legend view className
         */
        this.className = 'tui-chart-legend-area';

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedIndexes = [];

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        legendData = params.dataProcessor.getWholeLegendData();
        /**
         * legend model
         */
        this.legendModel = new LegendModel({
            theme: this.theme,
            labels: params.dataProcessor.getLegendLabels(),
            legendData: legendData,
            chartTypes: this.chartTypes,
            chartType: this.chartType
        });

        this.dimensionModel = new LegendDimensionModel({
            legendLabels: tui.util.pluck(legendData, 'label'),
            chartType: this.chartType,
            options: this.options,
            theme: this.theme
        });
    },

    /**
     * Register legend dimension.
     */
    registerDimension: function() {
        var chartWidth = this.boundsMaker.getDimension('chart').width;
        this.boundsMaker.registerBaseDimension('legend', this.dimensionModel.makeDimension(chartWidth));
    },

    /**
     * Render legend area.
     * @param {HTMLElement} legendContainer legend container
     * @param {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound lengend bound
     * @param {Array.<boolean>} checkedIndexes checked indexes
     * @private
     */
    _renderLegendArea: function(legendContainer) {
        legendContainer.innerHTML = this._makeLegendHtml(this.legendModel.getData());
        renderUtil.renderPosition(legendContainer, this.boundsMaker.getPosition('legend'));
        legendContainer.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @returns {HTMLElement} legend element
     */
    render: function() {
        var el = dom.create('DIV', this.className);

        this.legendContainer = el;

        if (predicate.isHorizontalLegend(this.options.align)) {
            dom.addClass(el, 'horizontal');
        }

        this._renderLegendArea(el);
        this._attachEvent(el);
        return el;
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * Make cssText of legend rect.
     * @param {{
     *      chartType: string,
     *      theme: {color: string, borderColor: ?string, singleColor: ?string}
     * }} legendDatum legend datum
     * @param {number} baseMarginTop base margin-top
     * @returns {string} cssText of legend rect
     * @private
     */
    _makeLegendRectCssText: function(legendDatum, baseMarginTop) {
        var theme = legendDatum.theme,
            borderCssText = theme.borderColor ? renderUtil.concatStr(';border:1px solid ', theme.borderColor) : '',
            rectMargin, marginTop;
        if (legendDatum.chartType === 'line') {
            marginTop = baseMarginTop + chartConst.LINE_MARGIN_TOP;
        } else {
            marginTop = baseMarginTop;
        }

        rectMargin = renderUtil.concatStr(';margin-top:', marginTop, 'px');

        return renderUtil.concatStr('background-color:', theme.singleColor || theme.color, borderCssText, rectMargin);
    },


    /**
     * Make labels width.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {Array.<number>} labels width
     * @private
     */
    _makeLabelsWidth: function(legendData) {
        return tui.util.map(legendData, function(item) {
            var labelWidth = renderUtil.getRenderedLabelWidth(item.label, this.theme.label);
            return labelWidth + chartConst.LEGEND_AREA_PADDING;
        }, this);
    },

    /**
     * Make legend html.
     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
     * @returns {string} legend html
     * @private
     */
    _makeLegendHtml: function(legendData) {
        var template = legendTemplate.tplLegend,
            checkBoxTemplate = legendTemplate.tplCheckbox,
            labelsWidth = this._makeLabelsWidth(legendData),
            labelHeight = renderUtil.getRenderedLabelHeight(legendData[0].label, legendData[0].theme),
            isHorizontalLegend = predicate.isHorizontalLegend(this.options.align),
            height = labelHeight + (chartConst.LABEL_PADDING_TOP * 2),
            baseMarginTop = parseInt((height - chartConst.LEGEND_RECT_WIDTH) / 2, 10) - 1,
            html = tui.util.map(legendData, function(legendDatum, index) {
                var rectCssText = this._makeLegendRectCssText(legendDatum, baseMarginTop),
                    checkbox = this.options.hasCheckbox === false ? '' : checkBoxTemplate({
                        index: index,
                        checked: this.legendModel.isCheckedIndex(index) ? ' checked' : ''
                    }),
                    data;

                data = {
                    rectCssText: rectCssText,
                    height: height,
                    labelHeight: labelHeight,
                    unselected: this.legendModel.isUnselectedIndex(index) ? ' unselected' : '',
                    labelWidth: isHorizontalLegend ? ';width:' + labelsWidth[index] + 'px' : '',
                    iconType: legendDatum.chartType || 'rect',
                    label: legendDatum.label,
                    checkbox: checkbox,
                    index: index
                };
                return template(data);
            }, this).join('');
        return html;
    },

    /**
     * Find legend element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} legend element
     * @private
     */
    _findLegendLabelElement: function(elTarget) {
        var legendContainer;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL)) {
            legendContainer = elTarget;
        } else {
            legendContainer = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_LEGEND_LABEL);
        }

        return legendContainer;
    },

    /**
     * Fire legend checkbox event.
     * @private
     */
    _fireLegendCheckboxEvent: function() {
        this.fire('changeCheckedLegends', this.legendModel.getCheckedIndexes());
    },

    /**
     * Fire legend event.
     * @param {{chartType: string, index: number}} data data
     * @private
     */
    _fireLegendSelectionEvent: function(data) {
        var chartTypes = this.chartTypes || [data.chartType],
            index = this.legendModel.getSelectedIndex(),
            legendIndex = !tui.util.isNull(index) ? data.seriesIndex : index;

        tui.util.forEachArray(chartTypes, function(chartType) {
            this.fire(renderUtil.makeCustomEventName('select', chartType, 'legend'), data.chartType, legendIndex);
        }, this);
    },

    /**
     * Fire user event.
     * @param {{label: string, chartType: string, index: number}} data data
     * @private
     */
    _fireUserEvent: function(data) {
        this.userEvent.fire('selectLegend', {
            legend: data.label,
            chartType: data.chartType,
            index: data.index
        });
    },

    /**
     * Select legend.
     * @param {number} index index
     * @private
     */
    _selectLegend: function(index) {
        var data = this.legendModel.getDatum(index);

        this.legendModel.toggleSelectedIndex(index);

        if (!tui.util.isNull(this.legendModel.getSelectedIndex()) && !this.legendModel.isCheckedSelectedIndex()) {
            this.legendModel.checkSelectedIndex();
            this._fireLegendCheckboxEvent();
        }

        this._renderLegendArea(this.legendContainer);

        this._fireLegendSelectionEvent(data);
        this._fireUserEvent(data);
    },

    /**
     * Get checked indexes.
     * @returns {Array} checked indexes
     * @private
     */
    _getCheckedIndexes: function() {
        var checkedIndexes = [];
        tui.util.forEachArray(this.legendContainer.getElementsByTagName('input'), function(checkbox, index) {
            if (checkbox.checked) {
                checkedIndexes.push(index);
            }
        });
        return checkedIndexes;
    },

    /**
     * Check legend.
     * @private
     */
    _checkLegend: function() {
        var checkedIndexes = this._getCheckedIndexes(),
            checkedCount = checkedIndexes.length,
            data;

        if ((predicate.isPieChart(this.chartType) && checkedCount === 1) || checkedCount === 0) {
            this._renderLegendArea(this.legendContainer);
        } else {
            this.legendModel.updateCheckedData(checkedIndexes);

            data = this.legendModel.getSelectedDatum();

            if (!this.legendModel.isCheckedSelectedIndex()) {
                this.legendModel.updateSelectedIndex(null);
            }

            this._renderLegendArea(this.legendContainer);

            this._fireLegendCheckboxEvent();

            if (data) {
                this._fireLegendSelectionEvent(data, true);
            }
        }
    },

    /**
     * On click event handler.
     * @param {MouseEvent} e mouse event
     * @private
     */
    _onClick: function(e) {
        var elTarget = e.target || e.srcElement,
            legendContainer, index;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_LEGEND_CHECKBOX)) {
            this._checkLegend();
            return;
        }

        legendContainer = this._findLegendLabelElement(elTarget);

        if (!legendContainer) {
            return;
        }

        index = parseInt(legendContainer.getAttribute('data-index'), 10);
        this._selectLegend(index);
    },

    /**
     * Attach browser event.
     * @param {HTMLElement} el target element
     * @private
     */
    _attachEvent: function(el) {
        eventListener.bindEvent('click', el, tui.util.bind(this._onClick, this));
    }
});

tui.util.CustomEvents.mixin(Legend);

module.exports = Legend;

},{"../const":19,"../helpers/domHandler":38,"../helpers/eventListener":39,"../helpers/predicate":41,"../helpers/renderUtil":42,"./../legends/legendTemplate":48,"./legendDimensionModel":46,"./legendModel":47}],46:[function(require,module,exports){
/**
 * @fileoverview LegendDimensionModel is legend dimension model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var LegendDimensionModel = tui.util.defineClass(/** @lends LegendDimensionModel.prototype */ {
    /**
     * LegendDimensionModel is legend dimension model.
     * @constructs LegendDimensionModel
     * @param {object} params parameters
     *      @param {string} params.chartType chart type
     *      @param {object} params.options legend options
     *      @param {object} params.theme legend theme
     *      @param {Array.<string | number>} params.legendLabels legend labels
     */
    init: function(params) {
        this.chartType = params.chartType;

        this.options = params.options;

        this.theme = params.theme;

        this.legendLabels = params.legendLabels;

        this.legendCheckboxWidth = this.options.hasCheckbox === false ? 0 : chartConst.LEGEND_CHECKBOX_WIDTH;
    },

    /**
     * Make legend width.
     * @param {number} labelWidth label width
     * @returns {number} legend width
     * @private
     */
    _makeLegendWidth: function(labelWidth) {
        return labelWidth + this.legendCheckboxWidth + chartConst.LEGEND_RECT_WIDTH +
            chartConst.LEGEND_LABEL_LEFT_PADDING + chartConst.LEGEND_AREA_PADDING;
    },

    /**
     * Calculate sum of legends width.
     * @param {Array.<string>} labels legend labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number} sum of width
     * @private
     */
    _calculateLegendsWidthSum: function(labels, labelTheme) {
        return tui.util.sum(tui.util.map(labels, function(label) {
            var labelWidth = this._makeLegendWidth(renderUtil.getRenderedLabelWidth(label, labelTheme));
            return labelWidth;
        }, this));
    },

    /**
     * Divide legend labels.
     * @param {Array.<string>} labels legend labels
     * @param {number} count division count
     * @returns {Array.<Array.<string>>} divided labels
     * @private
     */
    _divideLegendLabels: function(labels, count) {
        var limitCount = Math.round(labels.length / count),
            results = [],
            temp = [];

        tui.util.forEachArray(labels, function(label) {
            if (temp.length < limitCount) {
                temp.push(label);
            } else {
                results.push(temp);
                temp = [label];
            }
        });

        if (temp.length) {
            results.push(temp);
        }

        return results;
    },

    /**
     * Make division labels and max line width.
     * @param {Array.<string>} labels legend labels
     * @param {number} chartWidth chart width
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{dividedLabels: Array.<Array.<string>>, maxLineWidth: number}} result
     * @private
     */
    _makeDividedLabelsAndMaxLineWidth: function(labels, chartWidth, labelTheme) {
        var divideCount = 1,
            maxLineWidth = 0,
            prevMaxWidth = 0,
            dividedLabels, lineWidths, prevLabels;

        do {
            dividedLabels = this._divideLegendLabels(labels, divideCount);
            lineWidths = tui.util.map(dividedLabels, function(_labels) {
                return this._calculateLegendsWidthSum(_labels, labelTheme);
            }, this);
            maxLineWidth = Math.max.apply(null, lineWidths);

            if (prevMaxWidth === maxLineWidth) {
                dividedLabels = prevLabels;
                break;
            }

            prevMaxWidth = maxLineWidth;
            prevLabels = dividedLabels;
            divideCount += 1;
        } while (maxLineWidth >= chartWidth);

        return {
            dividedLabels: dividedLabels,
            maxLineWidth: maxLineWidth
        };
    },

    /**
     * Calculate height of horizontal legend.
     * @param {Array.<Array.<string>>} dividedLabels divided labels
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {number} legend height
     * @private
     */
    _calculateHorizontalLegendHeight: function(dividedLabels, labelTheme) {
        return tui.util.sum(tui.util.map(dividedLabels, function(labels) {
            return renderUtil.getRenderedLabelsMaxHeight(labels, labelTheme);
        }, this));
    },

    /**
     * Make dimension of horizontal legend.
     * @param {number} chartWidth chart width
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{width: number, height: (number)}} dimension of horizontal legend
     * @private
     */
    _makeHorizontalDimension: function(chartWidth) {
        var labelsAndMaxWidth = this._makeDividedLabelsAndMaxLineWidth(this.legendLabels, chartWidth, this.theme.label),
            legendHeight = this._calculateHorizontalLegendHeight(labelsAndMaxWidth.dividedLabels, this.theme.label) + (chartConst.LEGEND_AREA_PADDING * 2);

        return {
            width: labelsAndMaxWidth.maxLineWidth,
            height: legendHeight
        };
    },

    /**
     * Make dimension of vertical legend.
     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
     * @returns {{width: (number)}} dimension of vertical legend
     * @private
     */
    _makeVerticalDimension: function() {
        var maxLabelWidth = renderUtil.getRenderedLabelsMaxWidth(this.legendLabels, this.theme.label),
            legendWidth = this._makeLegendWidth(maxLabelWidth);
        return {
            width: legendWidth,
            height: 0
        };
    },

    /**
     * Whether skipped legend sizing or not.
     * @returns {boolean} result boolean
     * @private
     */
    _isSkipLegend: function() {
        return (predicate.isPieChart(this.chartType) && predicate.isPieLegendAlign(this.options.align)) || this.options.hidden;
    },

    /**
     * Make legend dimension.
     * @param {number} chartWidth chart width
     * @returns {{width: number, height: number}} legend dimention
     */
    makeDimension: function(chartWidth) {
        var dimension = {};

        if (this._isSkipLegend()) {
            dimension.width = 0;
        } else if (predicate.isHorizontalLegend(this.options.align)) {
            dimension = this._makeHorizontalDimension(chartWidth);
        } else {
            dimension = this._makeVerticalDimension();
        }

        return dimension;
    }
});

module.exports = LegendDimensionModel;

},{"../const":19,"../helpers/predicate":41,"../helpers/renderUtil":42}],47:[function(require,module,exports){
/**
 * @fileoverview LegendModel is legend model.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var defaultTheme = require('../themes/defaultTheme');

var concat = Array.prototype.concat;

var LegendModel = tui.util.defineClass(/** @lends LegendModel.prototype */ {
    /**
     * LegendModel is legend model.
     * @constructs LegendModel
     * @param {object} params parameters
     *      @param {number} params.labels legend labels
     *      @param {object} params.bound axis bound
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * legend labels
         * @type {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}}
         */
        this.labels = params.labels;

        /**
         * label infos
         * @type {Array.<{chartType: string, label: string, index: number}>}
         */
        this.legendData = params.legendData;

        /**
         * chart types
         * @type {?Array.<string>}
         */
        this.chartTypes = params.chartTypes;

        /**
         * chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Legend data
         * @type {?Array}
         */
        this.data = null;

        /**
         * Selected legend index.
         * @type {?number}
         */
        this.selectedIndex = null;

        /**
         * sending data to series
         * @type {object}
         */
        this.checkedIndexesMap = {};

        /**
         * checked indexes
         * @type {Array}
         */
        this.checkedWholeIndexes = [];

        this._initCheckedIndexes();
        this._setData();
    },

    /**
     * Initialize checked data.
     * @private
     */
    _initCheckedIndexes: function() {
        var checkedWholeIndexes = [];
        tui.util.forEachArray(this.legendData, function(legendDatum, index) {
            checkedWholeIndexes[index] = true;
        }, this);
        this.checkedWholeIndexes = checkedWholeIndexes;
    },

    /**
     * Make label info that applied theme.
     * @param {Array.<object>} labelInfo labels
     * @param {{colors: Array.<number>, singleColor: ?string, bordercolor: ?string}} theme legend theme
     * @param {Array.<boolean>} checkedIndexes checked indexes
     * @returns {Array.<object>} labels
     * @private
     */
    _makeLabelInfoAppliedTheme: function(labelInfo, theme, checkedIndexes) {
        var seriesIndex = 0;

        return tui.util.map(labelInfo, function(item, index) {
            var itemTheme = {
                color: theme.colors[index]
            };

            if (theme.singleColors) {
                itemTheme.singleColor = theme.singleColors[index];
            }

            if (theme.borderColor) {
                itemTheme.borderColor = theme.borderColor;
            }

            item.theme = itemTheme;
            item.index = index;

            if (!checkedIndexes || !tui.util.isUndefined(checkedIndexes[index])) {
                item.seriesIndex = seriesIndex;
                seriesIndex += 1;
            } else {
                item.seriesIndex = -1;
            }

            return item;
        }, this);
    },

    /**
     * Set legend data.
     * @private
     */
    _setData: function() {
        var legendData = this.legendData,
            data, defaultLegendTheme, startIndex, startThemeIndex;

        if (!this.chartTypes) {
            data = this._makeLabelInfoAppliedTheme(legendData, this.theme, this.checkedIndexesMap[this.chartType]);
        } else {
            startIndex = 0;
            startThemeIndex = 0;
            defaultLegendTheme = {
                colors: defaultTheme.series.colors
            };
            data = concat.apply([], tui.util.map(this.chartTypes, function(chartType) {
                var chartTheme = this.theme[chartType],
                    labelLen = this.labels[chartType].length,
                    endIndex = startIndex + labelLen,
                    themeEndIndex, datum;

                if (!chartTheme) {
                    themeEndIndex = startThemeIndex + labelLen;
                    chartTheme = JSON.parse(JSON.stringify(defaultLegendTheme));
                    chartTheme.colors = chartTheme.colors.slice(startThemeIndex, themeEndIndex);
                    startThemeIndex = themeEndIndex;
                }

                datum = this._makeLabelInfoAppliedTheme(legendData.slice(startIndex, endIndex), chartTheme, this.checkedIndexesMap[chartType]);
                startIndex = endIndex;
                return datum;
            }, this));
        }

        this.data = data;
    },

    /**
     * Get legend data.
     * @returns {Array.<{chartType: string, label: string, theme: object}>} legend data
     */
    getData: function() {
        return this.data;
    },

    /**
     * Get legend datum by index.
     * @param {number} index legend index
     * @returns {{chartType: string, label: string, theme: object}} legend datum
     */
    getDatum: function(index) {
        return this.data[index];
    },

    /**
     * Get selected datum.
     * @returns {{chartType: string, label: string, theme: Object}} legend datum
     */
    getSelectedDatum: function() {
        return this.getDatum(this.selectedIndex);
    },

    /**
     * Update selected index.
     * @param {?number} value value
     */
    updateSelectedIndex: function(value) {
        this.selectedIndex = value;
    },

    /**
     * Toggle selected index.
     * @param {number} index legend index
     */
    toggleSelectedIndex: function(index) {
        var selectedIndex;

        if (this.selectedIndex === index) {
            selectedIndex = null;
        } else {
            selectedIndex = index;
        }

        this.updateSelectedIndex(selectedIndex);
    },

    /**
     * Get selected index.
     * @returns {number} selected index
     */
    getSelectedIndex: function() {
        return this.selectedIndex;
    },

    /**
     * Whether unselected index or not.
     * @param {number} index legend index
     * @returns {boolean} true if selected
     */
    isUnselectedIndex: function(index) {
        return !tui.util.isNull(this.selectedIndex) && (this.selectedIndex !== index);
    },

    /**
     * Whether checked selected index or not.
     * @returns {boolean} true if checked
     */
    isCheckedSelectedIndex: function() {
        return this.isCheckedIndex(this.selectedIndex);
    },

    /**
     * Update checked index.
     * @param {number} index legend index
     * @private
     */
    _updateCheckedIndex: function(index) {
        this.checkedWholeIndexes[index] = true;
    },

    /**
     * Whether checked index.
     * @param {number} index legend index
     * @returns {boolean} true if checked
     */
    isCheckedIndex: function(index) {
        return !!this.checkedWholeIndexes[index];
    },


    /**
     * Add sending datum.
     * @param {number} index legend index
     */
    _addSendingDatum: function(index) {
        var legendDatum = this.getDatum(index);
        if (!this.checkedIndexesMap[legendDatum.chartType]) {
            this.checkedIndexesMap[legendDatum.chartType] = [];
        }
        this.checkedIndexesMap[legendDatum.chartType][legendDatum.index] = true;
    },

    /**
     * Check selected index;
     */
    checkSelectedIndex: function() {
        this._updateCheckedIndex(this.selectedIndex);
        this._addSendingDatum(this.selectedIndex);
        this._setData();
    },

    /**
     * Get checked indexes.
     * @returns {{column: ?Array.<boolean>, line: ?Array.<boolean>} | Array.<boolean>} sending data
     */
    getCheckedIndexes: function() {
        return this.checkedIndexesMap[this.chartType] || this.checkedIndexesMap;
    },

    /**
     * Reset checked data.
     * @private
     */
    _resetCheckedData: function() {
        this.checkedWholeIndexes = [];
        this.checkedIndexesMap = {};
    },

    /**
     * Update checked data.
     * @param {Array.<number>} indexes indxes
     */
    updateCheckedData: function(indexes) {
        this._resetCheckedData();
        tui.util.forEachArray(indexes, function(index) {
            this._updateCheckedIndex(index);
            this._addSendingDatum(index);
        }, this);
        this._setData();
    }
});

module.exports = LegendModel;

},{"../themes/defaultTheme":75}],48:[function(require,module,exports){
/**
 * @fileoverview This is templates of legend view.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_CHECKBOX: '<div class="tui-chart-legend-checkbox-area"><input class="tui-chart-legend-checkbox" type="checkbox" value="{{ index }}"{{ checked }} /></div>',
    HTML_LEGEND: '<div class="tui-chart-legend{{ unselected }}" style="height:{{ height }}px">' +
        '{{ checkbox }}<div class="tui-chart-legend-rect {{ iconType }}" style="{{ rectCssText }}"></div>' +
        '<div class="tui-chart-legend-label" style="height:{{ labelHeight }}px{{ labelWidth }}" data-index="{{ index }}">{{ label }}</div></div>',
    HTML_TICK: '<div class="tui-chart-map-legend-tick" style="{{ position }}"></div>' +
        '<div class="tui-chart-map-legend-tick-label" style="{{ labelPosition }}">{{ label }}</div>'
};

module.exports = {
    tplCheckbox: templateMaker.template(htmls.HTML_CHECKBOX),
    tplLegend: templateMaker.template(htmls.HTML_LEGEND),
    tplTick: templateMaker.template(htmls.HTML_TICK)
};

},{"../helpers/templateMaker":43}],49:[function(require,module,exports){
/**
 * @fileoverview  Legend component for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    pluginFactory = require('../factories/pluginFactory'),
    legendTemplate = require('./../legends/legendTemplate');

var MapChartLegend = tui.util.defineClass(/** @lends MapChartLegend.prototype */ {
    /**
     * Legend component for map chart.
     * @constructs MapChartLegend
     * @param {object} params parameters
     *      @param {object} params.theme axis theme
     *      @param {?Array.<string>} params.options legend options
     *      @param {MapChartDataProcessor} params.dataProcessor data processor
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * class name.
         * @type {string}
         */
        this.className = 'tui-chart-legend-area';

        /**
         * legend theme
         * @type {Object}
         */
        this.theme = params.theme;

        /**
         * options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, 'mapLegend');

        /**
         * Whether horizontal legend or not.
         * @type {boolean}
         */
        this.isHorizontal = predicate.isHorizontalLegend(this.options.align);
    },

    /**
     * Make vertical legend dimension.
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalDimension: function() {
        var maxValue = Math.max.apply(null, this.dataProcessor.getValues()),
            formatFunctions = this.dataProcessor.getFormatFunctions(),
            valueStr = renderUtil.formatValue(maxValue, formatFunctions),
            labelWidth = renderUtil.getRenderedLabelWidth(valueStr, this.theme.label),
            padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width:  chartConst.MAP_LEGEND_GRAPH_SIZE + labelWidth + padding,
            height: chartConst.MAP_LEGEND_SIZE
        };
    },

    /**
     * Make horizontal legend dimension
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalDimension: function() {
        var maxValue = Math.max.apply(null, this.dataProcessor.getValues()),
            labelHeight = renderUtil.getRenderedLabelHeight(maxValue, this.theme.label),
            padding = chartConst.LEGEND_AREA_PADDING + chartConst.MAP_LEGEND_LABEL_PADDING;

        return {
            width:  chartConst.MAP_LEGEND_SIZE,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE + labelHeight + padding
        };
    },

    /**
     * Register dimension.
     */
    registerDimension: function() {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalDimension();
        } else {
            dimension = this._makeVerticalDimension();
        }

        this.boundsMaker.registerBaseDimension('legend', dimension);
    },

    /**
     * Make base data to make tick html.
     * @returns {{startPositionValue: number, step: number, positionType: string, labelSize: ?number}} base data
     * @private
     */
    _makeBaseDataToMakeTickHtml: function() {
        var dimension = this.boundsMaker.getDimension('legend'),
            stepCount = this.axesData.tickCount - 1,
            baseData = {};

        if (this.isHorizontal) {
            baseData.startPositionValue = 5;
            baseData.step = dimension.width / stepCount;
            baseData.positionType = 'left:';
        } else {
            baseData.startPositionValue = 0;
            baseData.step = dimension.height / stepCount;
            baseData.positionType = 'top:';
            baseData.labelSize = parseInt(renderUtil.getRenderedLabelHeight(this.axesData.labels[0], this.theme.label) / 2, 10) - 1;
        }

        return baseData;
    },
    /**
     * Make tick html.
     * @returns {string} tick html.
     * @private
     */
    _makeTickHtml: function() {
        var baseData = this._makeBaseDataToMakeTickHtml(),
            positionValue = baseData.startPositionValue,
            htmls;

        htmls = tui.util.map(this.axesData.labels, function(label) {
            var labelSize, html;

            if (this.isHorizontal) {
                labelSize = parseInt(renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2, 10);
            } else {
                labelSize = baseData.labelSize;
            }

            html = legendTemplate.tplTick({
                position: baseData.positionType + positionValue + 'px',
                labelPosition: baseData.positionType + (positionValue - labelSize) + 'px',
                label: label
            });

            positionValue += baseData.step;
            return html;
        }, this);

        return htmls.join('');
    },

    /**
     * Render tick area.
     * @returns {HTMLElement} tick countainer
     * @private
     */
    _renderTickArea: function() {
        var tickContainer = dom.create('div', 'tui-chart-legend-tick-area');

        tickContainer.innerHTML = this._makeTickHtml();

        if (this.isHorizontal) {
            dom.addClass(tickContainer, 'horizontal');
        }
        return tickContainer;
    },

    /**
     * Make graph dimension of vertical legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeVerticalGraphDimension: function() {
        return {
            width: chartConst.MAP_LEGEND_GRAPH_SIZE,
            height: this.boundsMaker.getDimension('legend').height
        }
    },

    /**
     * Make graph dimension of horizontal legend
     * @returns {{width: number, height: number}} dimension
     * @private
     */
    _makeHorizontalGraphDimension: function() {
        return {
            width: this.boundsMaker.getDimension('legend').width + 10,
            height: chartConst.MAP_LEGEND_GRAPH_SIZE
        }
    },

    /**
     * Render graph.
     * @param {HTMLElement} container container element
     * @private
     */
    _renderGraph: function(container) {
        var dimension;

        if (this.isHorizontal) {
            dimension = this._makeHorizontalGraphDimension();
        } else {
            dimension = this._makeVerticalGraphDimension();
        }

        this.graphRenderer.render(container, dimension, this.colorModel, this.isHorizontal);
    },

    /**
     * Render legend area.
     * @param {HTMLElement} container legend container
     * @private
     */
    _renderLegendArea: function(container) {
        var tickContainer;

        container.innerHTML = '';
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('legend'));
        this._renderGraph(container);
        tickContainer = this._renderTickArea();
        container.appendChild(tickContainer);
        container.style.cssText += ';' + renderUtil.makeFontCssText(this.theme.label);
    },

    /**
     * Render legend component.
     * @param {{colorModel: MapChartColorModel, axesData: object}} data rendering data
     * @returns {HTMLElement} legend element
     */
    render: function(data) {
        var container = dom.create('DIV', this.className);

        this.legendContainer = container;
        this.colorModel = data.colorModel;
        this.axesData = data.axesData;
        this._renderLegendArea(container);

        return container;
    },

    /**
     * Resize legend component.
     */
    resize: function() {
        this._renderLegendArea(this.legendContainer);
    },

    /**
     * On show wedge.
     * @param {number} ratio ratio
     */
    onShowWedge: function(ratio) {
        this.graphRenderer.showWedge(chartConst.MAP_LEGEND_SIZE * ratio);
    },

    /**
     * On hide wedge.
     */
    onHideWedge: function() {
        this.graphRenderer.hideWedge();
    }
});

tui.util.CustomEvents.mixin(MapChartLegend);

module.exports = MapChartLegend;

},{"../const":19,"../factories/pluginFactory":31,"../helpers/domHandler":38,"../helpers/predicate":41,"../helpers/renderUtil":42,"./../legends/legendTemplate":48}],50:[function(require,module,exports){
/**
 * @fileoverview Plot component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var dom = require('../helpers/domHandler'),
    calculator = require('../helpers/calculator'),
    renderUtil = require('../helpers/renderUtil'),
    plotTemplate = require('./plotTemplate');

var Plot = tui.util.defineClass(/** @lends Plot.prototype */ {
    /**
     * Plot component.
     * @constructs Plot
     * @param {object} params parameters
     *      @param {number} params.vTickCount vertical tick count
     *      @param {number} params.hTickCount horizontal tick count
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * Plot view className
         * @type {string}
         */
        this.className = 'tui-chart-plot-area';
    },

    /**
     * Render plot area.
     * @param {HTMLElement} plotContainer plot area element
     * @param {object} data rendering data
     * @private
     */
    _renderPlotArea: function(plotContainer, data) {
        var dimension = this.boundsMaker.getDimension('plot');
        this.data = data;

        renderUtil.renderDimension(plotContainer, dimension);
        renderUtil.renderPosition(plotContainer, this.boundsMaker.getPosition('plot'));
        this._renderLines(plotContainer, dimension);
    },

    /**
     * Render plot component.
     * @param {object} data rendering data
     * @returns {HTMLElement} plot element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);
        this._renderPlotArea(el, data);
        this.plotContainer = el;
        return el;
    },

    /**
     * Rerender.
     * @param {object} data rendering
     */
    rerender: function(data) {
        this.plotContainer.innerHTML = '';
        this._renderPlotArea(this.plotContainer, data);
    },

    /**
     * Resize plot component.
     * @param {object} data rendering data
     */
    resize: function(data) {
        this.rerender(data);
    },

    /**
     * Render plot lines.
     * @param {HTMLElement} el element
     * @param {{width: number, height: number}} dimension plot area dimension
     * @private
     */
    _renderLines: function(el, dimension) {
        var hPositions = this._makeHorizontalPixelPositions(dimension.width),
            vPositions = this._makeVerticalPixelPositions(dimension.height),
            theme = this.theme,
            lineHtml = '';

        lineHtml += this._makeLineHtml({
            positions: hPositions,
            size: dimension.height,
            className: 'vertical',
            positionType: 'left',
            sizeType: 'height',
            lineColor: theme.lineColor
        });
        lineHtml += this._makeLineHtml({
            positions: vPositions,
            size: dimension.width,
            className: 'horizontal',
            positionType: 'bottom',
            sizeType: 'width',
            lineColor: theme.lineColor
        });

        el.innerHTML = lineHtml;

        renderUtil.renderBackground(el, theme.background);
    },

    /**
     * Make html of plot line.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {number} params.size width or height
     *      @param {string} params.className line className
     *      @param {string} params.positionType position type (left or bottom)
     *      @param {string} params.sizeType size type (size or height)
     *      @param {string} params.lineColor line color
     * @returns {string} html
     * @private
     */
    _makeLineHtml: function(params) {
        var template = plotTemplate.tplPlotLine,
            lineHtml = tui.util.map(params.positions, function(position) {
                var cssTexts = [
                        renderUtil.concatStr(params.positionType, ':', position, 'px'),
                        renderUtil.concatStr(params.sizeType, ':', params.size, 'px')
                    ], data;

                if (params.lineColor) {
                    cssTexts.push(renderUtil.concatStr('background-color:', params.lineColor));
                }

                data = {className: params.className, cssText: cssTexts.join(';')};
                return template(data);
            }, this).join('');
        return lineHtml;
    },

    /**
     * Make pixel value of vertical positions
     * @param {number} height plot height
     * @returns {Array.<number>} positions
     * @private
     */
    _makeVerticalPixelPositions: function(height) {
        var positions = calculator.makeTickPixelPositions(height, this.data.vTickCount);
        positions.shift();
        return positions;
    },

    /**
     * Make pixel value of horizontal positions.
     * @param {number} width plot width
     * @returns {Array.<number>} positions
     * @private
     */
    _makeHorizontalPixelPositions: function(width) {
        var positions = calculator.makeTickPixelPositions(width, this.data.hTickCount);
        positions.shift();
        return positions;
    }
});

module.exports = Plot;

},{"../helpers/calculator":35,"../helpers/domHandler":38,"../helpers/renderUtil":42,"./plotTemplate":51}],51:[function(require,module,exports){
/**
 * @fileoverview This is templates of plot view .
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var tags = {
    HTML_PLOT_LINE: '<div class="tui-chart-plot-line {{ className }}" style="{{ cssText }}"></div>'
};

module.exports = {
    tplPlotLine: templateMaker.template(tags.HTML_PLOT_LINE)
};

},{"../helpers/templateMaker":43}],52:[function(require,module,exports){
/**
 * @fileoverview Raphael render plugin.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var BarChart = require('./raphaelBarChart'),
    LineChart = require('./raphaelLineChart'),
    AreaChart = require('./raphaelAreaChart'),
    PieChart = require('./raphaelPieChart'),
    MapChart = require('./raphaelMapChart'),
    MapLegend = require('./raphaelMapLegend');

var pluginName = 'raphael',
    pluginRaphael;

pluginRaphael = {
    bar: BarChart,
    column: BarChart,
    line: LineChart,
    area: AreaChart,
    pie: PieChart,
    map: MapChart,
    mapLegend: MapLegend
};

tui.chart.registerPlugin(pluginName, pluginRaphael);

},{"./raphaelAreaChart":53,"./raphaelBarChart":54,"./raphaelLineChart":55,"./raphaelMapChart":57,"./raphaelMapLegend":58,"./raphaelPieChart":59}],53:[function(require,module,exports){
/**
 * @fileoverview Raphael area chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

var concat = Array.prototype.concat;

var RaphaelAreaChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelAreaChart.prototype */ {
    /**
     * RaphaelAreaChart is graph renderer for area chart.
     * @constructs RaphaelAreaChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;
    },

    /**
     * Render function of area chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper;

        this.paper = paper = raphael(container, 1, dimension.height);
        this.stackedOption = data.options.stacked;
        this.spline = data.options.spline;
        this.dimension = dimension;
        this.zeroTop = data.zeroTop;

        this.groupPaths = data.options.spline ? this._getSplineAreasPath(groupPositions) : this._getAreasPath(groupPositions);
        this.groupAreas = this._renderAreas(paper, this.groupPaths, colors);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.hasSelection) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;
        }

        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.dotOpacity = opacity;
        delete this.pivotGroupDots;

        return paper;
    },

    /**
     * Render area graphs.
     * @param {object} paper paper
     * @param {Array.<object>} groupPaths group paths
     * @param {Array.<string>} colors colors
     * @returns {Array} raphael objects
     * @private
     */
    _renderAreas: function(paper, groupPaths, colors) {
        var groupAreas;

        colors = colors.slice(0, groupPaths.length);
        colors.reverse();
        groupPaths.reverse();

        groupAreas = tui.util.map(groupPaths, function(path, groupIndex) {
            var areaColor = colors[groupIndex] || 'transparent',
                lineColor = areaColor;

            return {
                area: raphaelRenderUtil.renderArea(paper, path.area.join(' '), areaColor, 0.5, areaColor),
                line: raphaelRenderUtil.renderLine(paper, path.line.join(' '), lineColor)
            };
        }, this);

        return groupAreas.reverse();
    },

    /**
     * Make height.
     * @param {number} top top
     * @param {number} startTop start top
     * @returns {number} height
     * @private
     */
    _makeHeight: function(top, startTop) {
        return Math.abs(top - startTop);
    },

    /**
     * Make areas path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} path
     * @private
     */
    _makeAreasPath: function(positions) {
        var len = positions.length * 2,
            path = [];

        tui.util.forEachArray(positions, function(position, index) {
            path[index] = ['L', position.left, position.top];
            path[len - index - 1] = ['L', position.left, position.startTop];
        });

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Get area path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _getAreasPath: function(groupPositions) {
        return tui.util.map(groupPositions, function(positions) {
            positions[0].left -= 1;

            return {
                area: this._makeAreasPath(positions),
                line: this._makeLinesPath(positions)
            };
        }, this);
    },

    /**
     * Make spline area bottom path.
     * @param {Array.<{left: number, top: number}>} positions positions
     * @param {Array.<{left: number, top: number}>} prevPositions previous positions
     * @returns {Array.<string | number>} spline area path
     * @private
     */
    _makeSplineAreaBottomPath: function(positions) {
        return tui.util.map(positions, function(position) {
            return ['L', position.left, this.zeroTop];
        }, this).reverse();
    },

    /**
     * Get spline areas path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
     * @private
     */
    _getSplineAreasPath: function(groupPositions) {
        return tui.util.map(groupPositions, function(positions) {
            var linesPath, areasBottomPath;

            positions[0].left -= 1;
            linesPath = this._makeSplineLinesPath(positions);
            areasBottomPath = this._makeSplineAreaBottomPath(positions);

            return {
                area: linesPath.concat(areasBottomPath),
                line: linesPath
            };
        }, this);
    },

    /**
     * Resize graph of area chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.groupPositions = groupPositions;
        this.groupPaths = this.spline ? this._getSplineAreasPath(groupPositions) : this._getAreasPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var area = this.groupAreas[groupIndex];
            area.area.attr({path: path.area.join(' ')});
            area.line.attr({path: path.line.join(' ')});

            tui.util.forEachArray(this.groupDots[groupIndex], function(item, index) {
                this._moveDot(item.dot, groupPositions[groupIndex][index]);
            }, this);
        }, this);
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var that = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var area = this.groupAreas[groupIndex],
                opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            area.area.attr({'fill-opacity': opacity});
            area.line.attr({'stroke-opacity': opacity});

            tui.util.forEachArray(this.groupDots[groupIndex], function(item) {
                if (that.dotOpacity) {
                    item.dot.attr({'fill-opacity': opacity});
                }
            });
        }, this);
    }
});

module.exports = RaphaelAreaChart;

},{"./raphaelLineTypeBase":56,"./raphaelRenderUtil":60}],54:[function(require,module,exports){
/**
 * @fileoverview Raphael bar chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';
var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var ANIMATION_TIME = 700,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

/**
 * @classdesc RaphaelBarChart is graph renderer for bar, column chart.
 * @class RaphaelBarChart
 */
var RaphaelBarChart = tui.util.defineClass(/** @lends RaphaelBarChart.prototype */ {
    /**
     * Render function of bar chart
     * @param {HTMLElement} container container element
     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var groupBounds = data.groupBounds,
            dimension = data.dimension,
            paper, baseParams;

        if (!groupBounds) {
            return null;
        }

        this.paper = paper = raphael(container, dimension.width, dimension.height);

        baseParams = {
            theme: data.theme,
            groupBounds: groupBounds,
            groupValues: data.groupValues,
            chartType: data.chartType
        };

        this.groupBars = this._renderBars(baseParams);
        this.groupBorders = this._renderBarBorders(baseParams);

        this.overlay = this._renderOverlay();
        this.theme = data.theme;
        this.groupBounds = groupBounds;
        this.chartType = data.chartType;

        return paper;
    },

    /**
     * Render overlay.
     * @returns {object} raphael object
     * @private
     */
    _renderOverlay: function() {
        var rect = this._renderBar({
            bound: {
                width: 1,
                height: 1,
                left: 0,
                top: 0
            },
            color: '#fff'
        }).attr({
            'fill-opacity': 0
        });

        return rect;
    },

    /**
     * Render rect
     * @param {object} params parameters
     *      @param {string} params.color series color
     *      @param {string} params.borderColor series borderColor
     *      @param {{left: number, top: number, width: number, height: number}} params.bound bound
     * @returns {object} bar rect
     * @private
     */
    _renderBar: function(params) {
        var bound = params.bound,
            rect;

        if (bound.width < 0 || bound.height < 0) {
            return null;
        }

        rect = this.paper.rect(bound.left, bound.top, bound.width, bound.height);
        rect.attr({
            fill: params.color,
            stroke: 'none'
        });

        return rect;
    },

    /**
     * Render bars.
     * @param {object} params parameters
     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme
     *      @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds
     * @returns {Array.<Array.<object>>} bars
     * @private
     */
    _renderBars: function(params) {
        var singleColors = (params.groupBounds[0].length === 1) && params.theme.singleColors || [],
            colors = params.theme.colors,
            groupBars;

        groupBars = tui.util.map(params.groupBounds, function(bounds, groupIndex) {
            var singleColor = singleColors[groupIndex];
            return tui.util.map(bounds, function(bound, index) {
                var color, rect, value;

                if (!bound) {
                    return null;
                }

                color = singleColor || colors[index];
                value = params.groupValues[groupIndex][index];

                rect = this._renderBar({
                    chartType: params.chartType,
                    color: color,
                    borderColor: params.theme.borderColor,
                    bound: bound.start,
                    value: value
                });

                return {
                    rect: rect,
                    color: color,
                    bound: bound.end,
                    value: value,
                    groupIndex: groupIndex,
                    index: index
                };
            }, this);
        }, this);

        return groupBars;
    },

    /**
     * Make rect points.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @returns {{
     *      leftTop: {left: number, top: number},
     *      rightTop: {left: number, top: number},
     *      rightBottom: {left: number, top: number},
     *      leftBottom: {left: number, top: number}
     * }} rect points
     * @private
     */
    _makeRectPoints: function(bound) {
        return {
            leftTop: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top)
            },
            rightTop: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top)
            },
            rightBottom: {
                left: Math.ceil(bound.left + bound.width),
                top: Math.ceil(bound.top + bound.height)
            },
            leftBottom: {
                left: Math.ceil(bound.left),
                top: Math.ceil(bound.top + bound.height)
            }
        };
    },

    /**
     * Make top line path.
     * @param {{left: numbrer, top: number}} leftTop left top
     * @param {{left: numbrer, top: number}} rightTop right top
     * @param {string} chartType chart type
     * @param {number} value value
     * @returns {string} top line path
     * @private
     */
    _makeTopLinePath: function(leftTop, rightTop, chartType, value) {
        var cloneLeftTop = tui.util.extend({}, leftTop);
        cloneLeftTop.left -= chartType === 'column' || value < 0 ? 1 : 0;
        return raphaelRenderUtil.makeLinePath(cloneLeftTop, rightTop).join(' ');
    },

    /**
     * Make border lines paths.
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @returns {{top: string, right: string, bottom: string, left: string}} paths
     * @private
     */
    _makeBorderLinesPaths: function(bound, chartType, value) {
        var points = this._makeRectPoints(bound),
            paths = {};

        if (chartType === 'bar' || value >= 0) {
            paths.top = this._makeTopLinePath(points.leftTop, points.rightTop, chartType, value);
        }

        if (chartType === 'column' || value >= 0) {
            paths.right = raphaelRenderUtil.makeLinePath(points.rightTop, points.rightBottom).join(' ');
        }

        if (chartType === 'bar' || value < 0) {
            paths.bottom = raphaelRenderUtil.makeLinePath(points.leftBottom, points.rightBottom).join(' ');
        }

        if (chartType === 'column' || value < 0) {
            paths.left = raphaelRenderUtil.makeLinePath(points.leftTop, points.leftBottom).join(' ');
        }

        return paths;
    },

    /**
     * Render border lines;
     * @param {object} params parameters
     *      @param {{left: number, top:number, width: number, height: number}} params.bound bar bound
     *      @param {string} params.borderColor border color
     *      @param {string} params.chartType chart type
     *      @param {number} params.value value
     * @returns {object} raphael object
     * @private
     */
    _renderBorderLines: function(params) {
        var borderLinePaths = this._makeBorderLinesPaths(params.bound, params.chartType, params.value),
            lines = {};

        tui.util.forEach(borderLinePaths, function(path, name) {
            lines[name] = raphaelRenderUtil.renderLine(this.paper, path, params.borderColor, 1);
        }, this);

        return lines;
    },

    /**
     * Render bar borders.
     * @param {object} params parameters
     *      @param {{colors: string[], singleColors: string[], borderColor: string}} params.theme bar chart theme
     *      @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} params.groupBounds bounds
     * @returns {Array.<Array.<object>>} borders
     * @private
     */
    _renderBarBorders: function(params) {
        var borderColor = params.theme.borderColor,
            groupBorders;

        if (!borderColor) {
            return null;
        }

        groupBorders = tui.util.map(params.groupBounds, function(bounds, groupIndex) {
            return tui.util.map(bounds, function(bound, index) {
                var value;

                if (!bound) {
                    return null;
                }

                value = params.groupValues[groupIndex][index];

                return this._renderBorderLines({
                    paper: this.paper,
                    bound: bound.start,
                    borderColor: borderColor,
                    chartType: params.chartType,
                    value: value
                });
            }, this);
        }, this);

        return groupBorders;
    },

    /**
     * Animate rect.
     * @param {object} rect raphael object
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @private
     */
    _animateRect: function(rect, bound) {
        rect.animate({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        }, ANIMATION_TIME);
    },

    /**
     * Animate borders.
     * @param {Array.<object>} lines raphael objects
     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @private
     */
    _animateBorders: function(lines, bound, chartType, value) {
        var paths = this._makeBorderLinesPaths(bound, chartType, value);

        tui.util.forEach(lines, function(line, name) {
            line.animate({path: paths[name]}, ANIMATION_TIME);
        });
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var that = this,
            groupBorders = this.groupBorders || [];

        if (this.callbackTimeout) {
            clearTimeout(this.callbackTimeout);
            delete this.callbackTimeout;
        }
        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            if (!bar) {
                return;
            }
            that._animateRect(bar.rect, bar.bound);
            if (lines) {
                that._animateBorders(lines, bar.bound, that.chartType, bar.value);
            }
        });

        if (callback) {
            this.callbackTimeout = setTimeout(function() {
                callback();
                delete that.callbackTimeout;
            }, ANIMATION_TIME);
        }
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var bar = this.groupBars[data.groupIndex][data.index],
            bound = bar.bound;
        this.overlay.attr({
            width: bound.width,
            height: bound.height,
            x: bound.left,
            y: bound.top,
            'fill-opacity': 0.3
        });
    },

    /**
     * Hide animation.
     */
    hideAnimation: function() {
        this.overlay.attr({
            width: 1,
            height: 1,
            x: 0,
            y: 0,
            'fill-opacity': 0
        });
    },

    /**
     * Update rect bound
     * @param {object} rect raphael object
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @private
     */
    _updateRectBound: function(rect, bound) {
        rect.attr({
            x: bound.left,
            y: bound.top,
            width: bound.width,
            height: bound.height
        });
    },

    /**
     * Update borders attribute
     * @param {Array.<object>} lines raphael objects
     * @param {{left: number, top: number, width: number, height: number}} bound bound
     * @param {string} chartType chart type
     * @param {number} value value
     * @private
     */
    _updateBordersPath: function(lines, bound, chartType, value) {
        var paths = this._makeBorderLinesPaths(bound, chartType, value);

        tui.util.forEach(lines, function(line, name) {
            line.attr({path: paths[name]});
        });
    },

    /**
     * Resize graph of bar type chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number, width: number, height: number}>>} params.groupBounds group bounds
     */
    resize: function(params) {
        var that = this,
            groupBorders = this.groupBorders || [],
            dimension = params.dimension,
            groupBounds = params.groupBounds;

        this.groupBounds = groupBounds;
        this.paper.setSize(dimension.width, dimension.height);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, bound;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            bound = groupBounds[groupIndex][index].end;
            bar.bound = bound;
            that._updateRectBound(bar.rect, bound);

            if (lines) {
                that._updateBordersPath(lines, bound, that.chartType, bar.value);
            }
        });
    },

    /**
     * Change borders color.
     * @param {Array.<object>} lines raphael objects
     * @param {borderColor} borderColor border color
     * @private
     */
    _changeBordersColor: function(lines, borderColor) {
        tui.util.forEach(lines, function(line) {
            line.attr({stroke: borderColor});
        });
    },

    /**
     * Change bar color.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} color fill color
     * @param {?string} borderColor stroke color
     * @private
     */
    _changeBarColor: function(indexes, color, borderColor) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            lines;

        bar.rect.attr({
            fill: color
        });

        if (borderColor) {
            lines = this.groupBorders[indexes.groupIndex][indexes.index];
            this._changeBordersColor(lines, borderColor);
        }
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            objColor = raphael.color(bar.color),
            color = this.theme.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2),
            borderColor = this.theme.borderColor,
            objBorderColor;

        if (borderColor) {
            objBorderColor = raphael.color(borderColor);
            borderColor = raphaelRenderUtil.makeChangedLuminanceColor(objBorderColor.hex, 0.2);
        }

        this._changeBarColor(indexes, color, borderColor);
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var bar = this.groupBars[indexes.groupIndex][indexes.index],
            borderColor = this.theme.borderColor;
        this._changeBarColor(indexes, bar.color, borderColor);
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var groupBorders = this.groupBorders || [],
            noneSelected = tui.util.isNull(legendIndex);

        raphaelRenderUtil.forEach2dArray(this.groupBars, function(bar, groupIndex, index) {
            var lines, opacity;

            if (!bar) {
                return;
            }

            lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
            opacity = (noneSelected || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            bar.rect.attr({'fill-opacity': opacity});
            if (lines) {
                tui.util.forEach(lines, function(line) {
                    line.attr({'stroke-opacity': opacity});
                });
            }
        });
    }
});

module.exports = RaphaelBarChart;

},{"./raphaelRenderUtil":60}],55:[function(require,module,exports){
/**
 * @fileoverview Raphael line chart renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var RaphaelLineBase = require('./raphaelLineTypeBase'),
    raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

var RaphaelLineChart = tui.util.defineClass(RaphaelLineBase, /** @lends RaphaelLineChart.prototype */ {
    /**
     * RaphaelLineCharts is graph renderer for line chart.
     * @constructs RaphaelLineChart
     * @extends RaphaelLineTypeBase
     */
    init: function() {
        /**
         * selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;
    },

    /**
     * Render function of line chart.
     * @param {HTMLElement} container container
     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            groupPositions = data.groupPositions,
            theme = data.theme,
            colors = theme.colors,
            opacity = data.options.hasDot ? 1 : 0,
            groupPaths = data.options.spline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions),
            borderStyle = this.makeBorderStyle(theme.borderColor, opacity),
            outDotStyle = this.makeOutDotStyle(opacity, borderStyle),
            paper;

        this.paper = paper = raphael(container, 1, dimension.height);
        this.splineOption = data.options.spline;
        this.dimension = dimension;

        this.groupLines = this._renderLines(paper, groupPaths, colors);
        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);

        if (data.options.hasSelection) {
            this.selectionDot = this._makeSelectionDot(paper);
            this.selectionColor = theme.selectionColor;
        }

        this.colors = colors;
        this.borderStyle = borderStyle;
        this.outDotStyle = outDotStyle;
        this.groupPositions = groupPositions;
        this.groupPaths = groupPaths;
        this.dotOpacity = opacity;
        delete this.pivotGroupDots;

        return paper;
    },

    /**
     * Get lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array.<Array.<string>>} path
     * @private
     */
    _getLinesPath: function(groupPositions) {
        return tui.util.map(groupPositions, function(positions) {
            positions[0].left -= 1;

            return this._makeLinesPath(positions);
        }, this);
    },

    /**
     * Get spline lines path.
     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
     * @returns {Array} path
     * @private
     */
    _getSplineLinesPath: function(groupPositions) {
        return tui.util.map(groupPositions, this._makeSplineLinesPath, this);
    },

    /**
     * Render lines.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<string>>} groupPaths paths
     * @param {string[]} colors line colors
     * @param {?number} strokeWidth stroke width
     * @returns {Array.<Array.<object>>} lines
     * @private
     */
    _renderLines: function(paper, groupPaths, colors, strokeWidth) {
        return tui.util.map(groupPaths, function(path, groupIndex) {
            var color = colors[groupIndex] || 'transparent';
            return raphaelRenderUtil.renderLine(paper, path.join(' '), color, strokeWidth);
        }, this);
    },

    /**
     * Resize graph of line chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
     */
    resize: function(params) {
        var dimension = params.dimension,
            groupPositions = params.groupPositions;

        this.groupPositions = groupPositions;
        this.groupPaths = this.splineOption ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
        this.paper.setSize(dimension.width, dimension.height);
        this.tooltipLine.attr({top: dimension.height});

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            this.groupLines[groupIndex].attr({path: path.join(' ')});

            tui.util.forEachArray(this.groupDots[groupIndex], function(item, index) {
                this._moveDot(item.dot, groupPositions[groupIndex][index]);
            }, this);
        }, this);
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var that = this,
            noneSelected = tui.util.isNull(legendIndex);

        this.selectedLegendIndex = legendIndex;

        tui.util.forEachArray(this.groupPaths, function(path, groupIndex) {
            var opacity = (noneSelected || legendIndex === groupIndex) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            that.groupLines[groupIndex].attr({'stroke-opacity': opacity});

            tui.util.forEachArray(this.groupDots[groupIndex], function(item) {
                item.opacity = opacity;

                if (that.dotOpacity) {
                    item.dot.attr({'fill-opacity': opacity});
                }
            });
        }, this);
    }
});

module.exports = RaphaelLineChart;

},{"./raphaelLineTypeBase":56,"./raphaelRenderUtil":60}],56:[function(require,module,exports){
/**
 * @fileoverview RaphaelLineTypeBase is base class for line type renderer.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var ANIMATION_TIME = 700,
    DEFAULT_DOT_RADIUS = 3,
    HOVER_DOT_RADIUS = 4,
    SELECTION_DOT_RADIUS = 7,
    DE_EMPHASIS_OPACITY = 0.3;

var concat = Array.prototype.concat;

/**
 * @classdesc RaphaelLineTypeBase is base for line type renderer.
 * @class RaphaelLineTypeBase
 */
var RaphaelLineTypeBase = tui.util.defineClass(/** @lends RaphaelLineTypeBase.prototype */ {
    /**
     * Make lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeLinesPath: function(positions) {
        var path = tui.util.map(positions, function(position) {
            return ['L', position.left, position.top];
        });

        path = concat.apply([], path);
        path[0] = 'M';

        return path;
    },

    /**
     * Get anchor. (http://raphaeljs.com/analytics.js)
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} pos position
     * @param {{left: number, top: number}} nextPos next position
     * @returns {{x1: number, y1: number, x2: number, y2: number}} anchor
     * @private
     */
    _getAnchor: function(fromPos, pos, nextPos) {
        var l1 = (pos.left - fromPos.left) / 2,
            l2 = (nextPos.left - pos.left) / 2,
            a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top)),
            b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top)),
            alpha, dx1, dy1, dx2, dy2;

        a = fromPos.top < pos.top ? Math.PI - a : a;
        b = nextPos.top < pos.top ? Math.PI - b : b;
        alpha = Math.PI / 2 - ((a + b) % (Math.PI * 2)) / 2;
        dx1 = l1 * Math.sin(alpha + a);
        dy1 = l1 * Math.cos(alpha + a);
        dx2 = l2 * Math.sin(alpha + b);
        dy2 = l2 * Math.cos(alpha + b);

        return {
            x1: pos.left - dx1,
            y1: pos.top + dy1,
            x2: pos.left + dx2,
            y2: pos.top + dy2
        };
    },

    /**
     * Make spline lines path.
     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
     * @returns {Array.<string | number>} paths
     * @private
     */
    _makeSplineLinesPath: function(positions) {
        var firstPos = positions[0],
            positionsLen = positions.length,
            fromPos = firstPos,
            lastPos = positions[positionsLen - 1],
            middlePositions = positions.slice(1).slice(0, positionsLen - 2),
            path = tui.util.map(middlePositions, function(position, index) {
                var nextPos = positions[index + 2],
                    anchor = this._getAnchor(fromPos, position, nextPos);
                fromPos = position;
                return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];
            }, this);

        firstPos.left -= 1;
        path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);
        path.unshift(['M', firstPos.left, firstPos.top, 'C', firstPos.left, firstPos.top]);

        return path;
    },

    /**
     * Render tooltip line.
     * @param {object} paper raphael paper
     * @param {number} height height
     * @returns {object} raphael object
     * @private
     */
    _renderTooltipLine: function(paper, height) {
        var linePath = raphaelRenderUtil.makeLinePath({
                left: 10,
                top: height
            }, {
                left: 10,
                top: 0
            });

        return raphaelRenderUtil.renderLine(paper, linePath, 'transparent', 1);
    },

    /**
     * Make border style.
     * @param {string} borderColor border color
     * @param {number} opacity opacity
     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style
     */
    makeBorderStyle: function(borderColor, opacity) {
        var borderStyle;

        if (borderColor) {
            borderStyle = {
                stroke: borderColor,
                'stroke-width': 1,
                'stroke-opacity': opacity
            };
        }

        return borderStyle;
    },

    /**
     * Make dot style for mouseout event.
     * @param {number} opacity opacity
     * @param {object} borderStyle border style
     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style
     */
    makeOutDotStyle: function(opacity, borderStyle) {
        var outDotStyle = {
            'fill-opacity': opacity,
            'stroke-opacity': 0,
            r: DEFAULT_DOT_RADIUS
        };

        if (borderStyle) {
            tui.util.extend(outDotStyle, borderStyle);
        }

        return outDotStyle;
    },

    /**
     * Render dot.
     * @param {object} paper raphael papaer
     * @param {{left: number, top: number}} position dot position
     * @param {string} color dot color
     * @param {number} opacity opacity
     * @returns {object} raphael dot
     */
    renderDot: function(paper, position, color, opacity) {
        var dot = paper.circle(position.left, position.top, DEFAULT_DOT_RADIUS),
            dotStyle = {
                fill: color,
                'fill-opacity': opacity,
                'stroke-opacity': 0
            };

        dot.attr(dotStyle);

        return {
            dot: dot,
            color: color
        };
    },

    /**
     * Render dots.
     * @param {object} paper raphael paper
     * @param {Array.<Array.<object>>} groupPositions positions
     * @param {string[]} colors colors
     * @param {number} opacity opacity
     * @returns {Array.<object>} dots
     * @private
     */
    _renderDots: function(paper, groupPositions, colors, opacity) {
        var dots = tui.util.map(groupPositions, function(positions, groupIndex) {
            var color = colors[groupIndex];
            return tui.util.map(positions, function(position) {
                var dot = this.renderDot(paper, position, color, opacity);
                return dot;
            }, this);
        }, this);

        return dots;
    },

    /**
     * Get center position
     * @param {{left: number, top: number}} fromPos from position
     * @param {{left: number, top: number}} toPos to position
     * @returns {{left: number, top: number}} position
     * @private
     */
    _getCenter: function(fromPos, toPos) {
        return {
            left: (fromPos.left + toPos.left) / 2,
            top: (fromPos.top + toPos.top) / 2
        };
    },

    /**
     * Show dot.
     * @param {object} dot raphael object
     * @private
     */
    _showDot: function(dot) {
        dot.attr({
            'fill-opacity': 1,
            'stroke-opacity': 0.3,
            'stroke-width': 2,
            r: HOVER_DOT_RADIUS
        });
    },

    /**
     * Update line stroke width.
     * @param {object} line raphael object
     * @param {number} strokeWidth stroke width
     * @private
     */
    _updateLineStrokeWidth: function(line, strokeWidth) {
        line.attr({
            'stroke-width': strokeWidth
        });
    },

    /**
     * Show animation.
     * @param {{groupIndex: number, index:number}} data show info
     */
    showAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex].line,
            item = this.groupDots[groupIndex][index];

        this._updateLineStrokeWidth(line, 3);
        this._showDot(item.dot);
    },

    /**
     * Get pivot group dots.
     * @returns {Array.<Array>} dots
     * @private
     */
    _getPivotGroupDots: function() {
        if (!this.pivotGroupDots) {
            this.pivotGroupDots = tui.util.pivot(this.groupDots);
        }

        return this.pivotGroupDots;
    },

    /**
     * Show group dots.
     * @param {number} index index
     * @private
     */
    _showGroupDots: function(index) {
        var groupDots = this._getPivotGroupDots();

        tui.util.forEachArray(groupDots[index], function(item) {
            this._showDot(item.dot);
        }, this);
    },

    /**
     * Show line for group tooltip.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    showGroupTooltipLine: function(bound) {
        var linePath = raphaelRenderUtil.makeLinePath({
            left: bound.position.left,
            top: bound.position.top + bound.dimension.height
        }, {
            left: bound.position.left,
            top: bound.position.top
        });

        this.tooltipLine.attr({
            path: linePath,
            stroke: '#999',
            'stroke-opacity': 1
        });
    },

    /**
     * Show group animation.
     * @param {number} index index
     */
    showGroupAnimation: function(index) {
        this._showGroupDots(index);
    },

    /**
     * Hide dot.
     * @param {object} dot raphael object
     * @param {?number} opacity opacity
     * @private
     */
    _hideDot: function(dot, opacity) {
        var outDotStyle = this.outDotStyle;

        if (!tui.util.isUndefined(opacity)) {
            outDotStyle = tui.util.extend({}, this.outDotStyle, {
                'fill-opacity': opacity
            });
        }

        dot.attr(outDotStyle);
    },

    /**
     * Hide animation.
     * @param {{groupIndex: number, index:number}} data hide info
     */
    hideAnimation: function(data) {
        var index = data.groupIndex, // Line chart has pivot values.
            groupIndex = data.index,
            line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex].line,
            item = this.groupDots[groupIndex][index],
            opacity = this.dotOpacity;

        if (opacity && !tui.util.isNull(this.selectedLegendIndex) && this.selectedLegendIndex !== groupIndex) {
            opacity = DE_EMPHASIS_OPACITY;
        }

        if (line) {
            this._updateLineStrokeWidth(line, 2);
        }

        if (item) {
            this._hideDot(item.dot, opacity);
        }
    },

    /**
     * Hide group dots.
     * @param {number} index index
     * @private
     */
    _hideGroupDots: function(index) {
        var dots = this._getPivotGroupDots(),
            hasSelectedIndex = !tui.util.isNull(this.selectedLegendIndex),
            baseOpacity = this.dotOpacity;

        tui.util.forEachArray(dots[index], function(item, groupIndex) {
            var opacity = baseOpacity;

            if (opacity && hasSelectedIndex && this.selectedLegendIndex !== groupIndex) {
                opacity = DE_EMPHASIS_OPACITY;
            }

            this._hideDot(item.dot, opacity);
        }, this);
    },

    /**
     * Hide line for group tooltip.
     */
    hideGroupTooltipLine: function() {
        this.tooltipLine.attr({
            'stroke-opacity': 0
        });
    },

    /**
     * Hide group animation.
     * @param {number} index index
     */
    hideGroupAnimation: function(index) {
        this._hideGroupDots(index);
    },

    _moveDot: function(dot, position) {
        var dotAttrs = {
                cx: position.left,
                cy: position.top
            };

        if (this.dotOpacity) {
            dotAttrs = tui.util.extend({'fill-opacity': this.dotOpacity}, dotAttrs, this.borderStyle);
        }

        dot.attr(dotAttrs);
    },

    /**
     * Animate.
     * @param {function} onFinish callback
     */
    animate: function(onFinish) {
        var that = this,
            seriesWidth = this.dimension.width,
            seriesHeight = this.dimension.height;

        tui.chart.renderUtil.cancelAnimation(this.animation);

        this.animation = tui.chart.renderUtil.startAnimation(ANIMATION_TIME, function(ratio) {
            var width = Math.min(seriesWidth * ratio, seriesWidth);

            that.paper.setSize(width, seriesHeight);

            if (ratio === 1) {
                onFinish();
            }
        });
    },

    /**
     * Make selection dot.
     * @param {object} paper raphael paper
     * @returns {object} selection dot
     * @private
     */
    _makeSelectionDot: function(paper) {
        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);

        selectionDot.attr({
            'fill': '#ffffff',
            'fill-opacity': 0,
            'stroke-opacity': 0,
            'stroke-width': 2
        });
        return selectionDot;
    },

    /**
     * Select series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    selectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex],
            position = this.groupPositions[indexes.index][indexes.groupIndex];

        this.selectedItem = item;
        this.selectionDot.attr({
            cx: position.left,
            cy: position.top,
            'fill-opacity': 0.5,
            'stroke-opacity': 1,
            stroke: this.selectionColor || item.color
        });
    },

    /**
     * Unselect series.
     * @param {{groupIndex: number, index: number}} indexes indexes
     */
    unselectSeries: function(indexes) {
        var item = this.groupDots[indexes.index][indexes.groupIndex];

        if (this.selectedItem === item) {
            this.selectionDot.attr({
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
        }
    }
});

module.exports = RaphaelLineTypeBase;

},{"./raphaelRenderUtil":60}],57:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael;

var STROKE_COLOR = 'gray';

/**
 * @classdesc RaphaelMapCharts is graph renderer for map chart.
 * @class RaphaelMapChart
 */
var RaphaelMapChart = tui.util.defineClass(/** @lends RaphaelMapChart.prototype */ {
    /**
     * Render function of map chart.
     * @param {HTMLElement} container container
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {MapChartColorModel} data.colorModel color model
     * @returns {object} paper raphael paper
     */
    render: function(container, data) {
        var dimension = data.dimension,
            mapDimension = data.mapModel.getMapDimension(),
            paper;

        this.paper = paper = raphael(container, dimension.width, dimension.height);
        this.sectors = this._renderMap(data);
        this.overColor = data.theme.overColor;

        paper.setViewBox(0, 0, mapDimension.width, mapDimension.height, false);

        return paper;
    },

    /**
     * Render map graph.
     * @param {object} data data
     *      @param {{width: number, height: number}} data.dimension series dimension
     *      @param {Array.<{code: string, path: string}>} data.map mapData
     *      @param {MapChartColorModel} data.colorModel color model
     * @returns {Array.<{sector: object, color: string, data: object}>} rendered map information
     * @private
     */
    _renderMap: function(data) {
        var colorModel = data.colorModel;

        return tui.util.map(data.mapModel.getMapData(), function(datum, index) {
            var percentValue = datum.percentValue || 0,
                color = colorModel.getColor(percentValue),
                sector = raphaelRenderUtil.renderArea(this.paper, datum.path, color, 1, STROKE_COLOR, 1);

            sector.data('index', index);

            return {
                sector: sector,
                color: color,
                percentValue: datum.percentValue
            };
        }, this);
    },

    /**
     * Find sector index.
     * @param {{left: number, top: number}} position position
     * @returns {?number} found index
     */
    findSectorIndex: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top),
            foundIndex = (sector && !tui.util.isUndefined(sector.data('index'))) ? sector.data('index') : null,
            data = foundIndex && this.sectors[foundIndex];

        return data && !tui.util.isUndefined(data.percentValue) ? foundIndex : null;
    },

    /**
     * Change color.
     * @param {number} index index
     */
    changeColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: this.overColor
        }, 100);
    },

    /**
     * Restore color.
     * @param {number} index index
     */
    restoreColor: function(index) {
        var sector = this.sectors[index];

        sector.sector.animate({
            fill: sector.color
        }, 100);
    },

    /**
     * Set size
     * @param {{width: number, height: number}} dimension dimension
     */
    setSize: function(dimension) {
        this.paper.setSize(dimension.width, dimension.height);
    }
});

module.exports = RaphaelMapChart;

},{"./raphaelRenderUtil":60}],58:[function(require,module,exports){
/**
 * @fileoverview RaphaelMapLegend is graph renderer for map chart legend.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';


var raphael = window.Raphael;

var PADDING = 10;

/**
 * @classdesc RaphaelMapLegend is graph renderer for map chart legend.
 * @class RaphaelMapLegend
 */
var RaphaelMapLegend = tui.util.defineClass(/** @lends RaphaelMapLegend.prototype */ {
    /**
     * Render function of map chart legend.
     * @param {HTMLElement} container container
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {MapChartColorModel} colorModel map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @returns {object} paper raphael paper
     */
    render: function(container, dimension, colorModel, isHorizontal) {
        var paper = raphael(container, dimension.width, dimension.height);

        this._renderGradientBar(paper, dimension, colorModel, isHorizontal);
        this.wedge = this._renderWedge(paper);

        return paper;
    },

    /**
     * Render gradient bar.
     * @param {object} paper raphael object
     * @param {{width: number, height: number}} dimension legend dimension
     * @param {MapChartColorModel} colorModel map chart color model
     * @param {boolean} isHorizontal whether horizontal legend or not
     * @private
     */
    _renderGradientBar: function(paper, dimension, colorModel, isHorizontal) {
        var rectWidth = dimension.width - PADDING,
            rectHeight = dimension.height,
            left = 0,
            degree;

        if (isHorizontal) {
            rectHeight -= PADDING;
            left = PADDING / 2;
            degree = 360;
            this._makeWedghPath = this._makeHorizontalWedgePath;
        } else {
            degree = 270;
            this._makeWedghPath = this._makeVerticalWedgePath;
        }

        paper.rect(left, 0, rectWidth, rectHeight).attr({
            fill: degree + '-' + colorModel.start + '-' + colorModel.end,
            stroke: 'none'
        });
    },

    /**
     * Render wedge.
     * @param {object} paper raphael object
     * @returns {object} raphael object
     * @private
     */
    _renderWedge: function(paper) {
        var wedge = paper.path(this.verticalBasePath).attr({
            'fill': 'gray',
            stroke: 'none',
            opacity: 0
        });

        return wedge;
    },

    /**
     * Vertical base path
     * @type {Array}
     */
    verticalBasePath: ['M', 16, 6, 'L', 24, 3, 'L', 24, 9],

    /**
     * Make vertical wedge path.
     * @param {number} top top
     * @returns {Array} path
     * @private
     */
    _makeVerticalWedgePath: function(top) {
        var path = this.verticalBasePath;

        path[2] = top;
        path[5] = top - 3;
        path[8] = top + 3;

        return path;
    },

    /**
     * Horizontal base path
     * @type {Array}
     */
    horizontalBasePath: ['M', 5, 16, 'L', 8, 24, 'L', 2, 24],

    /**
     * Make horizontal wedge path.
     * @param {number} left left
     * @returns {Array} path
     * @private
     */
    _makeHorizontalWedgePath: function(left) {
        var path = this.horizontalBasePath;

        left += PADDING / 2;

        path[1] = left;
        path[4] = left + 3;
        path[7] = left - 3;

        return path;
    },

    /**
     * Show wedge.
     * @param {number} positionValue top
     */
    showWedge: function(positionValue) {
        var path = this._makeWedghPath(positionValue);

        this.wedge.attr({
            path: path,
            opacity: 1
        });
    },

    /**
     * Hide wedge
     */
    hideWedge: function() {
        this.wedge.attr({
            opacity: 0
        });
    }
});

module.exports = RaphaelMapLegend;

},{}],59:[function(require,module,exports){
/**
 * @fileoverview RaphaelPieCharts is graph renderer for pie chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var raphaelRenderUtil = require('./raphaelRenderUtil');

var raphael = window.Raphael,
    ANGLE_180 = 180,
    RAD = Math.PI / ANGLE_180,
    ANIMATION_TIME = 500,
    LOADING_ANIMATION_TIME = 700,
    EMPHASIS_OPACITY = 1,
    DE_EMPHASIS_OPACITY = 0.3;

/**
 * @classdesc RaphaelPieCharts is graph renderer for pie chart.
 * @class RaphaelPieChart
 */
var RaphaelPieChart = tui.util.defineClass(/** @lends RaphaelPieChart.prototype */ {
    /**
     * Render function of pie chart.
     * @param {HTMLElement} container container
     * @param {{sectorData: Array.<object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data
     * @param {object} callbacks callbacks
     *      @param {function} callbacks.funcShowTooltip show tooltip function
     *      @param {function} callbacks.funcHideTooltip hide tooltip function
     *      @param {function} callbacks.funcSelectSeries select series function
     * @returns {object} paper raphael paper
     */
    render: function(container, data, callbacks) {
        var dimension = data.dimension,
            paper;

        //Raphael._oid = 0;
        this.paper = paper = raphael(container, dimension.width, dimension.height);

        if (!paper.customAttributes.sector) {
            paper.customAttributes.sector = tui.util.bind(this._makeSectorPath, this);
        }

        this.container = container;
        this.callbacks = callbacks;
        this.selectionColor = data.theme.selectionColor;
        this.circleBound = data.circleBound;

        this._renderPie(paper, data);
        return paper;
    },

    /**
     * Clear paper.
     */
    clear: function() {
        this.paper.clear();
    },
    /**
     * Make sector path.
     * @param {number} cx center x
     * @param {number} cy center y
     * @param {number} r radius
     * @param {number} startAngle start angle
     * @param {number} endAngle end angel
     * @returns {{path: Array}} sector path
     * @private
     */
    _makeSectorPath: function(cx, cy, r, startAngle, endAngle) {
        var x1 = cx + r * Math.sin(startAngle * RAD), // 원 호의 시작 x 좌표
            y1 = cy - r * Math.cos(startAngle * RAD), // 원 호의 시작 y 좌표
            x2 = cx + r * Math.sin(endAngle * RAD), // 원 호의 종료 x 좌표
            y2 = cy - r * Math.cos(endAngle * RAD), // 원 호의 종료 y 좌표
            largeArcFlag = endAngle - startAngle > ANGLE_180 ? 1 : 0,
            path = ['M', cx, cy,
                'L', x1, y1,
                'A', r, r, 0, largeArcFlag, 1, x2, y2,
                'Z'
            ];
        // path에 대한 자세한 설명은 아래 링크를 참고
        // http://www.w3schools.com/svg/svg_path.asp
        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
        return {path: path};
    },

    /**
     * Render sector
     * @param {object} params parameters
     *      @param {object} params.paper raphael paper
     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds
     *      @param {number} params.startAngle start angle
     *      @param {number} params.endAngle end angle
     *      @param {{fill: string, stroke: string, strike-width: string}} params.attrs attrs
     * @returns {object} raphael object
     * @private
     */
    _renderSector: function (params) {
        var circleBound = params.circleBound,
            angles = params.angles;

        return params.paper.path().attr({
            sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
        }).attr(params.attrs);
    },

    /**
     * Render pie graph.
     * @param {object} paper raphael paper
     * @param {{sectorData: Array.<object>, circleBound: {cx: number, cy: number, r: number}, dimension: object, theme: object, options: object}} data render data
     * @private
     */
    _renderPie: function(paper, data) {
        var circleBound = data.circleBound,
            colors = data.theme.colors,
            chartBackground = data.chartBackground,
            sectors = [];

        tui.util.forEachArray(data.sectorData, function(sectorDatum, index) {
            var percentValue = sectorDatum.percentValue,
                color = colors[index],
                sector = this._renderSector({
                    paper: paper,
                    circleBound: circleBound,
                    angles: sectorDatum.angles.start,
                    attrs: {
                        fill: color,
                        stroke: chartBackground,
                        'stroke-width': 1
                    }
                });
            sector.data('index', index);
            sectors.push({
                sector: sector,
                color: color,
                angles: sectorDatum.angles.end,
                percentValue: percentValue
            });
        }, this);

        this.sectors = sectors;
    },

    /**
     * Render legend lines.
     * @param {Array.<object>} outerPositions outer position
     */
    renderLegendLines: function(outerPositions) {
        var that = this,
            paths;

        if (this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions);
        this.legendLines = tui.util.map(paths, function(path) {
            return raphaelRenderUtil.renderLine(that.paper, path, 'transparent', 1);
        });
    },

    /**
     * Make line paths.
     * @param {Array.<object>} outerPositions outer positions
     * @returns {Array} line paths.
     * @private
     */
    _makeLinePaths: function(outerPositions) {
        var paths = tui.util.map(outerPositions, function(positions) {
            return [
                raphaelRenderUtil.makeLinePath(positions.start, positions.middle),
                raphaelRenderUtil.makeLinePath(positions.middle, positions.end),
                'Z'
            ].join('');
        }, this);

        return paths;
    },

    /**
     * Expand selector radius.
     * @param {object} sector pie sector
     */
    _expandSector: function(sector) {
        var cx = this.circleBound.cx,
            cy = this.circleBound.cy;

        sector.animate({
            transform: 's1.1 1.1 ' + cx + ' ' + cy
        }, ANIMATION_TIME, 'elastic');
    },

    /**
     * Restore selector radius.
     * @param {object} sector pie sector
     */
    _restoreSector: function(sector) {
        sector.animate({transform: ''}, ANIMATION_TIME, 'elastic');
    },

    /**
     * animate expanding.
     * @param {number} index sector index
     */
    _animateExpanding: function(index) {
        var sector = this.sectors[index].sector;

        if (this.prevMovedSector) {
            this._animateRestoring(this.prevMovedSector.data('index'));
        }

        this._expandSector(sector);
    },

    /**
     * Animate restoring.
     * @param {number} index sector index
     */
    _animateRestoring: function(index) {
        var sector = this.sectors[index].sector;
        this._restoreSector(sector);
    },

    /**
     * Animate.
     * @param {function} callback callback
     */
    animate: function(callback) {
        var delayTime = 0,
            circleBound = this.circleBound;

        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles,
                animationTime, anim;

            if (angles.startAngle === 0 && angles.endAngle === 360) {
                angles.endAngle = 360 - 0.01;
            }

            animationTime = LOADING_ANIMATION_TIME * item.percentValue;
            anim = raphael.animation({
                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
            }, animationTime);

            item.sector.animate(anim.delay(delayTime));
            delayTime += animationTime;
        }, this);

        if (callback) {
            setTimeout(callback, delayTime);
        }
    },

    /**
     * Animate legend lines.
     */
    animateLegendLines: function() {
        if (!this.legendLines) {
            return;
        }

        tui.util.forEachArray(this.legendLines, function(line) {
            line.animate({
                'stroke': 'black',
                'stroke-opacity': 1
            });
        });
    },


    /**
     * Resize graph of pie chart.
     * @param {object} params parameters
     *      @param {{width: number, height:number}} params.dimension dimension
     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound
     */
    resize: function(params) {
        var dimension = params.dimension,
            circleBound = params.circleBound;

        this.circleBound = circleBound;
        this.paper.setSize(dimension.width, dimension.height);
        delete this.containerBound;

        tui.util.forEachArray(this.sectors, function(item) {
            var angles = item.angles;
            item.sector.attr({
                sector: [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle]
            });
        }, this);
    },

    /**
     * Move legend lines.
     * @param {Array.<object>} outerPositions outer positions
     */
    moveLegendLines: function(outerPositions) {
        var paths;

        if (!this.legendLines) {
            return;
        }

        paths = this._makeLinePaths(outerPositions);
        tui.util.forEachArray(this.legendLines, function(line, index) {
            line.attr({path: paths[index]});
            return line;
        });
    },

    /**
     * Click series.
     * @param {{left: number, top: number}} position mouse position
     */
    clickSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top);

        if (sector && this.prevSelectedSector) {
            this._unselectSeries(this.prevSelectedSector.data('index'));
        }

        if (this.prevSelectedSector === sector) {
            sector = null;
            delete this.prevSelectedSector;
        } else if (sector) {
            this._selectSeries(sector.data('index'));
            this.prevSelectedSector = sector;
        }
    },


    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.container.getBoundingClientRect();
        }
        return this.containerBound;
    },

    /**
     * Whether changed or not.
     * @param {{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Move mouse on series.
     * @param {{left: number, top: number}} position mouse position
     */
    moveMouseOnSeries: function(position) {
        var sector = this.paper.getElementByPoint(position.left, position.top),
            containerBound, args, changedSector;

        if (sector && this.sectors[sector.data('index')]) {
            containerBound = this._getContainerBound();
            changedSector = this.prevMovedSector !== sector;
            args = [{}, 0, sector.data('index'), {
                left: position.left - containerBound.left,
                top: position.top - containerBound.top
            }];

            if (changedSector) {
                this._animateExpanding(sector.data('index'));
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                this.callbacks.funcShowTooltip.apply(null, args);
                this.prevMovedSector = sector;
            }
        } else if (this.prevMovedSector) {
            this._animateRestoring(this.prevMovedSector.data('index'));
            this.callbacks.funcHideTooltip();
            this.prevMovedSector = null;
        }
        this.prevPosition = position;
    },

    /**
     * Select series.
     * @param {number} index index
     * @private
     */
    _selectSeries: function(index) {
        var item = this.sectors[index],
            objColor = raphael.color(item.color),
            color = this.selectionColor || raphaelRenderUtil.makeChangedLuminanceColor(objColor.hex, 0.2);

        item.sector.attr({
            fill: color
        });
    },

    /**
     * Unelect series.
     * @param {number} index index
     * @private
     */
    _unselectSeries: function(index) {
        var sector = this.sectors[index];

        sector.sector.attr({
            fill: sector.color
        });
    },

    /**
     * Select legend.
     * @param {?number} legendIndex legend index
     */
    selectLegend: function(legendIndex) {
        var isNull = tui.util.isNull(legendIndex);

        tui.util.forEachArray(this.sectors, function(item, index) {
            var opacity;

            opacity = (isNull || legendIndex === index) ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;

            item.sector.attr({
                'fill-opacity': opacity
            });
        }, this);
    }
});

module.exports = RaphaelPieChart;

},{"./raphaelRenderUtil":60}],60:[function(require,module,exports){
/**
 * @fileoverview Util for raphael rendering.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

/**
 * Util for raphael rendering.
 * @module raphaelRenderUtil
 */
var raphaelRenderUtil = {
    /**
     * Make line path.
     * @memberOf module:raphaelRenderUtil
     * @param {{top: number, left: number}} fromPos from position
     * @param {{top: number, left: number}} toPos to position
     * @param {number} width width
     * @returns {string} path
     */
    makeLinePath: function(fromPos, toPos, width) {
        var fromPoint = [fromPos.left, fromPos.top],
            toPoint = [toPos.left, toPos.top];

        width = width || 1;

        tui.util.forEachArray(fromPoint, function(from, index) {
            if (from === toPoint[index]) {
                fromPoint[index] = toPoint[index] = Math.round(from) - (width % 2 / 2);
            }
        });
        return ['M'].concat(fromPoint).concat('L').concat(toPoint);
    },

    /**
     * Render line.
     * @memberOf module:raphaelRenderUtil
     * @param {object} paper raphael paper
     * @param {string} path line path
     * @param {string} color line color
     * @param {number} strokeWidth stroke width
     * @returns {object} raphael line
     */
    renderLine: function(paper, path, color, strokeWidth) {
        var line = paper.path([path]),
            strokeStyle = {
                stroke: color,
                'stroke-width': strokeWidth || 2
            };

        if (color === 'transparent') {
            strokeStyle.stroke = '#fff';
            strokeStyle['stroke-opacity'] = 0;
        }
        line.attr(strokeStyle);

        return line;
    },

    /**
     * Render area graph.
     * @param {object} paper paper
     * @param {{start: string}} path path
     * @param {string} color fill color
     * @param {?number} opacity fill opacity
     * @param {string} strokeColor stroke color
     * @param {?number} strokeOpacity stroke opacity
     * @returns {Array.<object>} raphael object
     */
    renderArea: function(paper, path, color, opacity, strokeColor, strokeOpacity) {
        var area = paper.path(path),
            fillStyle = {
                fill: color,
                opacity: opacity,
                stroke: strokeColor,
                'stroke-opacity': strokeOpacity || 0
            };

        area.attr(fillStyle);

        return area;
    },

    /**
     * Render items of line type chart.
     * @param {Array.<Array.<object>>} groupItems group items
     * @param {function} funcRenderItem function
     */
    forEach2dArray: function(groupItems, funcRenderItem) {
        tui.util.forEachArray(groupItems, function(items, groupIndex) {
            tui.util.forEachArray(items, function(item, index) {
                funcRenderItem(item, groupIndex, index);
            }, this);
        }, this);
    },

    /**
     * Make changed luminance color.
     * http://www.sitepoint.com/javascript-generate-lighter-darker-color/
     * @param {string} hex hax color
     * @param {number} lum luminance
     * @returns {string} changed color
     */
    makeChangedLuminanceColor: function (hex, lum) {
        // validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');

        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        lum = lum || 0;

        // convert to decimal and change luminosity
        return '#' + tui.util.map(tui.util.range(3), function(index) {
            var c = parseInt(hex.substr(index * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            return ('00' + c).substr(c.length);
        }).join('');
    }
};

module.exports = raphaelRenderUtil;

},{}],61:[function(require,module,exports){
if (!window.JSON) {
    window.JSON = {
        parse: function(sJSON) { return eval('(' + sJSON + ')'); },
        stringify: (function () {
            var toString = Object.prototype.toString;
            var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
            var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
            var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
            var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
            return function stringify(value) {
                if (value == null) {
                    return 'null';
                } else if (typeof value === 'number') {
                    return isFinite(value) ? value.toString() : 'null';
                } else if (typeof value === 'boolean') {
                    return value.toString();
                } else if (typeof value === 'object') {
                    if (typeof value.toJSON === 'function') {
                        return stringify(value.toJSON());
                    } else if (isArray(value)) {
                        var res = '[';
                        for (var i = 0; i < value.length; i++)
                            res += (i ? ', ' : '') + stringify(value[i]);
                        return res + ']';
                    } else if (toString.call(value) === '[object Object]') {
                        var tmp = [];
                        for (var k in value) {
                            if (value.hasOwnProperty(k))
                                tmp.push(stringify(k) + ': ' + stringify(value[k]));
                        }
                        return '{' + tmp.join(', ') + '}';
                    }
                }
                return '"' + value.toString().replace(escRE, escFunc) + '"';
            };
        })()
    };
}

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }
}());

},{}],62:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    chartFactory = require('./factories/chartFactory'),
    BarChart = require('./charts/barChart'),
    ColumnChart = require('./charts/columnChart'),
    LineChart = require('./charts/lineChart'),
    AreaChart = require('./charts/areaChart'),
    ComboChart = require('./charts/comboChart'),
    PieChart = require('./charts/pieChart'),
    MapChart = require('./charts/mapChart');

chartFactory.register(chartConst.CHART_TYPE_BAR, BarChart);
chartFactory.register(chartConst.CHART_TYPE_COLUMN, ColumnChart);
chartFactory.register(chartConst.CHART_TYPE_LINE, LineChart);
chartFactory.register(chartConst.CHART_TYPE_AREA, AreaChart);
chartFactory.register(chartConst.CHART_TYPE_COMBO, ComboChart);
chartFactory.register(chartConst.CHART_TYPE_PIE, PieChart);
chartFactory.register(chartConst.CHART_TYPE_MAP, MapChart);

},{"./charts/areaChart":4,"./charts/barChart":6,"./charts/columnChart":9,"./charts/comboChart":10,"./charts/lineChart":12,"./charts/mapChart":14,"./charts/pieChart":17,"./const":19,"./factories/chartFactory":29}],63:[function(require,module,exports){
'use strict';

var chartConst = require('./const'),
    themeFactory = require('./factories/themeFactory'),
    defaultTheme = require('./themes/defaultTheme');

themeFactory.register(chartConst.DEFAULT_THEME_NAME, defaultTheme);

},{"./const":19,"./factories/themeFactory":32,"./themes/defaultTheme":75}],64:[function(require,module,exports){
/**
 * @fileoverview Area chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase'),
    chartConst = require('../const');

var AreaChartSeries = tui.util.defineClass(Series, /** @lends AreaChartSeries.prototype */ {
    /**
     * Area chart series component.
     * @constructs AreaChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make position top of zero point.
     * @param {{height: number}} dimension dimension
     * @returns {number} position top
     * @private
     */
    _makePositionTopOfZeroPoint: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            limit = this.data.limit,
            limitDistance = this._getLimitDistanceFromZeroPoint(dimension.height, limit),
            top = limitDistance.toMax;

        if (limit.min >= 0 && !top) {
            top = dimension.height;
        }

        return top + chartConst.SERIES_EXPAND_SIZE;
    },

    /**
     * Make stacked positions.
     * @param {Array.<Array.<{left: number, top: number}>>} groupPositions group positions
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stacked positions
     * @private
     */
    _makeStackedPositions: function(groupPositions) {
        var height = this.boundsMaker.getDimension('series').height + chartConst.SERIES_EXPAND_SIZE,
            firstStartTop = this._makePositionTopOfZeroPoint(),
            prevPositionTops = [];

        return tui.util.map(groupPositions, function(positions) {
            return tui.util.map(positions, function(position, index) {
                var prevTop = prevPositionTops[index] || firstStartTop,
                    stackedHeight = height - position.top,
                    top = prevTop - stackedHeight;

                position.startTop = prevTop;
                position.top = top;

                prevPositionTops[index] = top;
                return position;
            });
        });
    },

    /**
     * Make normal positions.
     * @param {Array.<Array.<{left: number, top: number}>>} groupPositions group positions
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stacked positions
     * @private
     */
    _makeNormalPositions: function(groupPositions) {
        var startTop = this._makePositionTopOfZeroPoint();

        return tui.util.map(groupPositions, function(positions) {
            return tui.util.map(positions, function(position) {
                position.startTop = startTop;
                return position;
            });
        });
    },

    /**
     * Make positions.
     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stacked positions
     * @private
     */
    _makePositions: function() {
        var groupPositions = this._makeBasicPositions();

        if (this.options.stacked) {
            groupPositions = this._makeStackedPositions(groupPositions);
        } else {
            groupPositions = this._makeNormalPositions(groupPositions);
        }

        return groupPositions;
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            zeroTop = this._getLimitDistanceFromZeroPoint(dimension.height, this.data.limit).toMax;

        return {
            groupPositions: this._makePositions(),
            zeroTop: zeroTop + chartConst.SERIES_EXPAND_SIZE
        };
    }
});

LineTypeSeriesBase.mixin(AreaChartSeries);

module.exports = AreaChartSeries;

},{"../const":19,"./lineTypeSeriesBase":69,"./series":72}],65:[function(require,module,exports){
/**
 * @fileoverview Bar chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    calculator = require('../helpers/calculator');

var BarChartSeries = tui.util.defineClass(Series, /** @lends BarChartSeries.prototype */ {
    /**
     * Bar chart series component.
     * @constructs BarChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make bound of bar chart.
     * @param {object} params parameters
     *      @param {{top: number, height: number}} params.baseBound base bound
     *      @param {number} params.startLeft start left
     *      @param {number} params.endLeft end left
     *      @param {number} params.endWidth end width
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeBarChartBound: function(params) {
        return {
            start: tui.util.extend({
                left: params.startLeft,
                width: 0
            }, params.baseBound),
            end: tui.util.extend({
                left: params.endLeft,
                width: params.endWidth
            }, params.baseBound)
        };
    },

    /**
     * Make normal bar chart bound.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupValues: Array.<Array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} baseInfo base info
     * @param {number} value value
     * @param {number} paddingTop padding top
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeNormalBarChartBound: function(baseInfo, value, paddingTop, index) {
        var startLeft, endWidth, bound, baseBound;

        startLeft = baseInfo.distance.toMin + chartConst.SERIES_EXPAND_SIZE;
        endWidth = Math.abs(value * baseInfo.dimension.width);
        baseBound = {
            top: paddingTop + ((baseInfo.step) * index) + chartConst.SERIES_EXPAND_SIZE,
            height: baseInfo.barSize
        };
        bound = this._makeBarChartBound({
            baseBound: baseBound,
            startLeft: startLeft,
            endLeft: startLeft + (value < 0 ? -endWidth : 0),
            endWidth: endWidth
        });

        return bound;
    },

    /**
     * Make bounds of normal bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeNormalBarChartBounds: function(dimension) {
        var baseInfo = this._makeBaseInfoForNormalChartBounds(dimension, 'width', 'height'),
            bounds = this._makeNormalBounds(baseInfo, tui.util.bind(this._makeNormalBarChartBound, this));

        return bounds;
    },

    /**
     * Make bounds of stacked bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeStackedBarChartBounds: function(dimension) {
        var that = this,
            baseInfo = this._makeBaseInfoForStackedChartBounds(dimension, 'width');

        return this._makeStackedBounds(dimension, baseInfo, function(baseBound, endSize, endPosition) {
            return that._makeBarChartBound({
                baseBound: baseBound,
                startLeft: baseInfo.distance.toMin + chartConst.SERIES_EXPAND_SIZE,
                endLeft: baseInfo.distance.toMin + endPosition,
                endWidth: endSize
            });
        });
    },

    /**
     * Make bounds of bar chart.
     * @param {{width: number, height:number}} dimension bar chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function(dimension) {
        var bounds;

        if (predicate.isValidStackedOption(this.options.stacked)) {
            bounds = this._makeStackedBarChartBounds(dimension);
        } else {
            bounds = this._makeNormalBarChartBounds(dimension);
        }

        return bounds;
    },

    /**
     * Make series rendering position
     * @param {obeject} params parameters
     *      @param {number} params.value value
     *      @param {{left: number, top: number, width:number, height: number}} params.bound bound
     *      @param {string} params.formattedValue formatted value
     *      @param {number} params.labelHeight label height
     * @returns {{left: number, top: number}} rendering position
     */
    makeSeriesRenderingPosition: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.formattedValue, this.theme.label),
            bound = params.bound,
            left = bound.left,
            top = bound.top + (bound.height - params.labelHeight + chartConst.TEXT_PADDING) / 2;

        if (params.value >= 0) {
            left += bound.width + chartConst.SERIES_LABEL_PADDING;
        } else {
            left -= labelWidth + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Calculate sum label top position.
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {number} top position value
     * @private
     */
    _calculateSumLabelTopPosition: function(bound, labelHeight) {
        return bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make plus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions());
            html = this._makeSeriesLabelHtml({
                left: bound.left + bound.width + chartConst.SERIES_LABEL_PADDING,
                top: this._calculateSumLabelTopPosition(bound, labelHeight)
            }, formattedSum, -1, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum, labelWidth,
            html = '';

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions());
            labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);
            html = this._makeSeriesLabelHtml({
                left: bound.left - labelWidth - chartConst.SERIES_LABEL_PADDING,
                top: this._calculateSumLabelTopPosition(bound, labelHeight)
            }, formattedSum, -1, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(BarChartSeries);

module.exports = BarChartSeries;

},{"../const":19,"../helpers/calculator":35,"../helpers/predicate":41,"../helpers/renderUtil":42,"./barTypeSeriesBase":66,"./series":72}],66:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');

var BarTypeSeriesBase = tui.util.defineClass(/** @lends BarTypeSeriesBase.prototype */ {
    /**
     * Make series data.
     * @returns {object} add data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        this.groupBounds = this._makeBounds(this.boundsMaker.getDimension('series'));

        return {
            groupBounds: this.groupBounds,
            groupValues: this._getPercentValues()
        };
    },

    /**
     * Make bar gutter.
     * @param {number} groupSize bar group size
     * @param {number} itemCount group item count
     * @returns {number} bar gutter
     * @private
     */
    _makeBarGutter: function(groupSize, itemCount) {
        var baseSize = groupSize / (itemCount + 1) / 2,
            gutter;

        if (baseSize <= 2) {
            gutter = 0;
        } else if (baseSize <= 6) {
            gutter = 2;
        } else {
            gutter = 4;
        }
        return gutter;
    },

    /**
     * Make bar size.
     * @param {number} groupSize bar group size
     * @param {number} barGutter bar padding
     * @param {number} itemCount group item count
     * @returns {number} bar size (width or height)
     * @private
     */
    _makeBarSize: function(groupSize, barGutter, itemCount) {
        return (groupSize - (barGutter * (itemCount - 1))) / (itemCount + 1);
    },

    /**
     * Make option size.
     * @param {number} barSize bar size
     * @param {?number} optionBarWidth barWidth option
     * @returns {number} option size
     * @private
     */
    _makeOptionSize: function(barSize, optionBarWidth) {
        var optionsSize = 0;
        if (optionBarWidth) {
            optionsSize = tui.util.min([barSize, optionBarWidth]);
        }
        return optionsSize;
    },

    /**
     * Make addition padding.
     * @param {number} barSize bar size
     * @param {number} optionSize option size
     * @param {number} itemCount item count
     * @returns {number} addition padding
     * @private
     */
    _makeAdditionPadding: function(barSize, optionSize, itemCount) {
        var padding = 0;

        if (optionSize && optionSize < barSize) {
            padding = (barSize - optionSize) * itemCount / 2;
        }

        return (barSize / 2) + padding;
    },

    /**
     * Make base info for normal chart bounds.
     * @param {{width: number, height: number}} dimension series dimension
     * @param {string} sizeType size type (width or height)
     * @param {string} anotherSizeType another size type (width or height)
     * @returns {{
     *      dimension: {width: number, height: number},
     *      groupValues: Array.<Array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} base info
     * @private
     */
    _makeBaseInfoForNormalChartBounds: function(dimension, sizeType, anotherSizeType) {
        var groupValues = this._getPercentValues(),
            groupSize = dimension[anotherSizeType] / groupValues.length,
            itemCount = groupValues[0] && groupValues[0].length || 0,
            barGutter = this._makeBarGutter(groupSize, itemCount),
            barSize = this._makeBarSize(groupSize, barGutter, itemCount),
            optionSize = this._makeOptionSize(barSize, this.options.barWidth),
            additionPadding = this._makeAdditionPadding(barSize, optionSize, itemCount),
            limitDistance = this._getLimitDistanceFromZeroPoint(dimension[sizeType], this.data.limit);

        barSize = optionSize || barSize;

        return {
            dimension: dimension,
            groupSize: groupSize,
            barSize: barSize,
            additionPadding: additionPadding,
            step: barSize + barGutter,
            distance: limitDistance,
            isMinus: this.data.limit.min < 0 && this.data.limit.max <= 0
        };
    },

    /**
     * Make normal bounds.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupValues: Array.<Array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} baseInfo base info
     * @param {function} iteratee iteratee
     * @returns {Array} bounds
     * @private
     */
    _makeNormalBounds: function(baseInfo, iteratee) {
        return tui.util.map(this._getPercentValues(), function(values, groupIndex) {
            var padding = (baseInfo.groupSize * groupIndex) + baseInfo.additionPadding;
            return tui.util.map(values, function (value, index) {
                return iteratee(baseInfo, value, padding, index);
            }, this);
        }, this);
    },

    /**
     * Make base info for stacked chart bounds.
     * @param {{width: number, height: number}} dimension dimension
     * @param {string} sizeType size type (width or height)
     * @returns {{groupSize: (number), baseBound: object, additionPadding: number, dimensionSize: number, positionType: string, baseEndPosition: number}} base info
     * @private
     */
    _makeBaseInfoForStackedChartBounds: function(dimension, sizeType) {
        var limitDistance = this._getLimitDistanceFromZeroPoint(dimension[sizeType], this.data.limit),
            baseBound = {},
            groupSize, barWidth, optionWidth, additionPadding,
            anotherSizeType, positionTop, baseEndPosition;

        if (sizeType === 'height') {
            anotherSizeType = 'width';
            positionTop = 'left';
            baseEndPosition = -chartConst.SERIES_EXPAND_SIZE;
        } else {
            anotherSizeType = 'height';
            positionTop = 'top';
            baseEndPosition = chartConst.SERIES_EXPAND_SIZE;
        }

        groupSize = (dimension[anotherSizeType] / this._getPercentValues().length);
        barWidth = groupSize / 2;
        optionWidth = this._makeOptionSize(barWidth, this.options.barWidth);
        additionPadding = this._makeAdditionPadding(barWidth, optionWidth, 1);
        baseBound[anotherSizeType] = optionWidth || barWidth;

        return {
            groupSize: groupSize,
            baseBound: baseBound,
            additionPadding: additionPadding + chartConst.SERIES_EXPAND_SIZE,
            dimensionSize: dimension[sizeType],
            positionType: positionTop,
            baseEndPosition: baseEndPosition,
            distance: limitDistance
        };
    },

    /**
     * Make bounds of stacked column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @param {{groupSize: (number), baseBound: object, additionPadding: number, dimensionSize: number, positionType: string, baseEndPosition: number}} baseInfo base info
     * @param {function} makeBoundFunc make bound function
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeStackedBounds: function(dimension, baseInfo, makeBoundFunc) {
        var bounds = tui.util.map(this._getPercentValues(), function(values, groupIndex) {
            var padding = (baseInfo.groupSize * groupIndex) + baseInfo.additionPadding,
                endPlusPosition = baseInfo.baseEndPosition,
                endMinusPosition = baseInfo.baseEndPosition;

            return tui.util.map(values, function (value) {
                var bound = null,
                    endSize = Math.abs(value * baseInfo.dimensionSize);
                baseInfo.baseBound[baseInfo.positionType] = padding;

                if (value >= 0) {
                    bound = makeBoundFunc(baseInfo.baseBound, endSize, endPlusPosition);
                    endPlusPosition += endSize;
                } else {
                    endMinusPosition -= endSize;
                    bound = makeBoundFunc(baseInfo.baseBound, endSize, endMinusPosition);
                }

                return bound;
            }, this);
        }, this);

        return bounds;
    },

    /**
     * Render normal series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderNormalSeriesLabel: function(elSeriesLabelArea) {
        var groupBounds = this.seriesData.groupBounds,
            firstFormattedValue = this.dataProcessor.getFirstFormattedValue(this.chartType),
            labelHeight = renderUtil.getRenderedLabelHeight(firstFormattedValue, this.theme.label),
            html;

        html = tui.util.map(this.dataProcessor.getGroupValues(this.chartType), function(values, groupIndex) {
            return tui.util.map(values, function(value, index) {
                var bound, formattedValue, renderingPosition;
                bound = groupBounds[groupIndex][index].end;
                formattedValue = this.dataProcessor.getFormattedValue(groupIndex, index, this.chartType);
                renderingPosition = this.makeSeriesRenderingPosition({
                    value: value,
                    bound: bound,
                    formattedValue: formattedValue,
                    labelHeight: labelHeight
                });
                return this._makeSeriesLabelHtml(renderingPosition, formattedValue, groupIndex, index);
            }, this).join('');
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Make sum values.
     * @param {Array.<number>} values values
     * @returns {number} sum result.
     */
    _makeSumValues: function(values) {
        var sum = tui.util.sum(values);

        return renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions());
    },

    /**
     * Make stacked label position.
     * @param {{width: number, height: number, left: number, top: number}} bound element bound
     * @param {string} formattedValue formatted value
     * @param {number} labelHeight label height
     * @returns {{left: number, top: number}} position
     * @private
     */
    _makeStackedLabelPosition: function(bound, formattedValue, labelHeight) {
        var labelWidth = renderUtil.getRenderedLabelWidth(formattedValue, this.theme.label),
            left = bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2),
            top = bound.top + ((bound.height - labelHeight + chartConst.TEXT_PADDING) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Make stacked labels html.
     * @param {object} params parameters
     *      @param {number} params.groupIndex group index
     *      @param {Array.<object>} params.bounds bounds,
     *      @param {number} params.labelHeight label height
     * @returns {string} labels html
     * @private
     */
    _makeStackedLabelsHtml: function(params) {
        var values = params.values,
            labelHeight = params.labelHeight,
            htmls, plusBound, minusBound;

        htmls = tui.util.map(values, function(value, index) {
            var bound = params.bounds[index],
                labelHtml = '',
                boundEnd, formattedValue, position;

            if (bound && value) {
                boundEnd = bound.end;
                formattedValue = this.dataProcessor.getFormattedValue(params.groupIndex, index, this.chartType);
                position = this._makeStackedLabelPosition(boundEnd, formattedValue, params.labelHeight);
                labelHtml = this._makeSeriesLabelHtml(position, formattedValue, params.groupIndex, index);
            }

            if (value > 0) {
                plusBound = boundEnd;
            } else if (value < 0) {
                minusBound = boundEnd;
            }

            return labelHtml;
        }, this);

        if (this.options.stacked === 'normal') {
            htmls.push(this._makePlusSumLabelHtml(values, plusBound, labelHeight));
            htmls.push(this._makeMinusSumLabelHtml(values, minusBound, labelHeight));
        }

        return htmls.join('');
    },

    /**
     * Render stacked series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderStackedSeriesLabel: function(elSeriesLabelArea) {
        var groupBounds = this.seriesData.groupBounds,
            groupValues = this.dataProcessor.getGroupValues(this.chartType),
            firstFormattedValue = this.dataProcessor.getFirstFormattedValue(this.chartType),
            labelHeight = renderUtil.getRenderedLabelHeight(firstFormattedValue, this.theme.label),
            html;

        html = tui.util.map(groupValues, function(values, index) {
            var labelsHtml = this._makeStackedLabelsHtml({
                groupIndex: index,
                values: values,
                bounds: groupBounds[index],
                labelHeight: labelHeight
            });
            return labelsHtml;
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        if (this.options.stacked) {
            this._renderStackedSeriesLabel(elSeriesLabelArea);
        } else {
            this._renderNormalSeriesLabel(elSeriesLabelArea);
        }
    }
});

BarTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, BarTypeSeriesBase.prototype);
};

module.exports = BarTypeSeriesBase;

},{"../const":19,"../helpers/renderUtil":42}],67:[function(require,module,exports){
/**
 * @fileoverview Column chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    BarTypeSeriesBase = require('./barTypeSeriesBase'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil'),
    calculator = require('../helpers/calculator');

var ColumnChartSeries = tui.util.defineClass(Series, /** @lends ColumnChartSeries.prototype */ {
    /**
     * Column chart series component.
     * @constructs ColumnChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make start end tops.
     * @param {number} endTop end top
     * @param {number} endHeight end height
     * @param {number} value value
     * @param {boolean} isMinus whether minus or not
     * @returns {{startTop: number, endTop: number}} start end tops
     * @private
     */
    _makeStartEndTops: function(endTop, endHeight, value) {
        var startTop;

        if (value < 0) {
            startTop = endTop;
        } else {
            startTop = endTop;
            endTop -= endHeight;
        }

        return {
            startTop: startTop,
            endTop: endTop
        };
    },

    /**
     * Make bound of column chart.
     * @param {object} params parameters
     *      @param {{left: number, width: number}} params.baseBound base bound
     *      @param {number} params.startTop start top
     *      @param {number} params.endTop end top
     *      @param {number} params.endHeight end height
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeColumnChartBound: function(params) {
        return {
            start: tui.util.extend({
                top: params.startTop,
                height: 0
            }, params.baseBound),
            end: tui.util.extend({
                top: params.endTop,
                height: params.endHeight
            }, params.baseBound)
        };
    },

    /**
     * Make normal column chart bound.
     * @param {{
     *      dimension: {width: number, height: number},
     *      groupValues: Array.<Array.<number>>,
     *      groupSize: number, barSize: number, step: number,
     *      distanceToMin: number, isMinus: boolean
     * }} baseInfo base info
     * @param {number} value value
     * @param {number} paddingLeft padding left
     * @param {number} index index
     * @returns {{
     *      start: {left: number, top: number, width: number, height: number},
     *      end: {left: number, top: number, width: number, height: number}
     * }} column chart bound
     * @private
     */
    _makeNormalColumnChartBound: function(baseInfo, value, paddingLeft, index) {
        var endHeight, endTop, startEndTops, bound;

        endHeight = Math.abs(value * baseInfo.dimension.height);
        endTop = (baseInfo.isMinus ? 0 : (baseInfo.distance.toMax || baseInfo.dimension.height)) + chartConst.SERIES_EXPAND_SIZE;
        startEndTops = this._makeStartEndTops(endTop, endHeight, value);
        bound = this._makeColumnChartBound(tui.util.extend({
            baseBound: {
                left: paddingLeft + (baseInfo.step * index) + chartConst.SERIES_EXPAND_SIZE,
                width: baseInfo.barSize
            },
            endHeight: endHeight
        }, startEndTops));

        return bound;
    },

    /**
     * Make bounds of normal column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeNormalColumnChartBounds: function(dimension) {
        var baseInfo = this._makeBaseInfoForNormalChartBounds(dimension, 'height', 'width'),
            bounds = this._makeNormalBounds(baseInfo, tui.util.bind(this._makeNormalColumnChartBound, this));

        return bounds;
    },

    /**
     * Make bounds of stacked column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeStackedColumnChartBounds: function(dimension) {
        var that = this,
            baseInfo = this._makeBaseInfoForStackedChartBounds(dimension, 'height'),
            bounds = this._makeStackedBounds(dimension, baseInfo, function(baseBound, endSize, endPosition) {
                return that._makeColumnChartBound({
                    baseBound: baseBound,
                    startTop: baseInfo.distance.toMax + chartConst.SERIES_EXPAND_SIZE,
                    endTop: baseInfo.distance.toMax - endSize - endPosition,
                    endHeight: endSize
                });
            });

        return bounds;
    },

    /**
     * Make bounds of column chart.
     * @param {{width: number, height:number}} dimension column chart dimension
     * @returns {Array.<Array.<object>>} bounds
     * @private
     */
    _makeBounds: function(dimension) {
        var bounds;

        if (predicate.isValidStackedOption(this.options.stacked)) {
            bounds = this._makeStackedColumnChartBounds(dimension);
        } else {
            bounds = this._makeNormalColumnChartBounds(dimension);
        }

        return bounds;
    },

    /**
     * Make series rendering position
     * @param {obeject} params parameters
     *      @param {number} params.value value
     *      @param {{left: number, top: number, width:number, width:number, height: number}} params.bound bound
     *      @param {string} params.formattedValue formatted value
     *      @param {number} params.labelHeight label height
     * @returns {{left: number, top: number}} rendering position
     */
    makeSeriesRenderingPosition: function(params) {
        var labelWidth = renderUtil.getRenderedLabelWidth(params.formattedValue, this.theme.label),
            bound = params.bound,
            top = bound.top,
            left = bound.left + (bound.width - labelWidth) / 2;

        if (params.value >= 0) {
            top -= params.labelHeight + chartConst.SERIES_LABEL_PADDING;
        } else {
            top += bound.height + chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Calculate sum label left position.
     * @param {{left: number, top: number}} bound bound
     * @param {string} formattedSum formatted sum.
     * @returns {number} left position value
     * @private
     */
    _calculateSumLabelLeftPosition: function(bound, formattedSum) {
        var labelWidth = renderUtil.getRenderedLabelWidth(formattedSum, this.theme.label);
        return bound.left + ((bound.width - labelWidth + chartConst.TEXT_PADDING) / 2);
    },

    /**
     * Make plus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @param {number} labelHeight label height
     * @returns {string} plus sum label html
     * @private
     */
    _makePlusSumLabelHtml: function(values, bound, labelHeight) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumPlusValues(values);
            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions());
            html = this._makeSeriesLabelHtml({
                left: this._calculateSumLabelLeftPosition(bound, formattedSum),
                top: bound.top - labelHeight - chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1, -1);
        }

        return html;
    },

    /**
     * Make minus sum label html.
     * @param {Array.<number>} values values
     * @param {{left: number, top: number}} bound bound
     * @returns {string} plus minus label html
     * @private
     */
    _makeMinusSumLabelHtml: function(values, bound) {
        var sum, formattedSum,
            html = '';

        if (bound) {
            sum = calculator.sumMinusValues(values);

            if (this.options.diverging) {
                sum = Math.abs(sum);
            }

            formattedSum = renderUtil.formatValue(sum, this.dataProcessor.getFormatFunctions());
            html = this._makeSeriesLabelHtml({
                left: this._calculateSumLabelLeftPosition(bound, formattedSum),
                top: bound.top + bound.height + chartConst.SERIES_LABEL_PADDING
            }, formattedSum, -1, -1);
        }

        return html;
    }
});

BarTypeSeriesBase.mixin(ColumnChartSeries);

module.exports = ColumnChartSeries;

},{"../const":19,"../helpers/calculator":35,"../helpers/predicate":41,"../helpers/renderUtil":42,"./barTypeSeriesBase":66,"./series":72}],68:[function(require,module,exports){
/**
 * @fileoverview Line chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    LineTypeSeriesBase = require('./lineTypeSeriesBase');

var LineChartSeries = tui.util.defineClass(Series, /** @lends LineChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs LineChartSeries
     * @extends Series
     * @mixes LineTypeSeriesBase
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function() {
        Series.apply(this, arguments);
    },

    /**
     * Make positions.
     * @returns {Array.<Array.<{left: number, top: number}>>} positions
     * @private
     */
    _makePositions: function() {
        return this._makeBasicPositions();
    },

    /**
     * Make series data.
     * @returns {object} series data
     * @private
     * @override
     */
    _makeSeriesData: function() {
        return {
            groupPositions: this._makePositions()
        };
    }
});

LineTypeSeriesBase.mixin(LineChartSeries);

module.exports = LineChartSeries;

},{"./lineTypeSeriesBase":69,"./series":72}],69:[function(require,module,exports){
/**
 * @fileoverview LineTypeSeriesBase is base class for line type series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    renderUtil = require('../helpers/renderUtil');
/**
 * @classdesc LineTypeSeriesBase is base class for line type series.
 * @class LineTypeSeriesBase
 * @mixin
 */
var LineTypeSeriesBase = tui.util.defineClass(/** @lends LineTypeSeriesBase.prototype */ {
    /**
     * Make positions of line chart.
     * @returns {Array.<Array.<object>>} positions
     * @private
     */
    _makeBasicPositions: function() {
        var dimension = this.boundsMaker.getDimension('series'),
            groupValues = this._getPercentValues(),
            width = dimension.width,
            height = dimension.height,
            len = groupValues[0].length,
            start = chartConst.SERIES_EXPAND_SIZE,
            step;

        if (this.data.aligned) {
            step = width / (len - 1);
        } else {
            step = width / len;
            start += (step / 2);
        }

        return tui.util.map(groupValues, function(values) {
            return tui.util.map(values, function(value, index) {
                return {
                    left: start + (step * index),
                    top: height - (value * height) + chartConst.SERIES_EXPAND_SIZE
                };
            });
        });
    },

    /**
     * Make label position top.
     * @param {{top: number, startTop: number}} position position
     * @param {number} value value
     * @param {number} labelHeight label height
     * @returns {number} position top
     * @private
     */
    _makeLabelPositionTop: function(position, value, labelHeight) {
        var positionTop;

        if (this.options.stacked && position.startTop) {
            positionTop = (position.startTop + position.top - labelHeight) / 2 + 1;
        } else if (value < 0 && !tui.util.isUndefined(position.startTop)) {
            positionTop = position.top + chartConst.SERIES_LABEL_PADDING;
        } else {
            positionTop = position.top - labelHeight - chartConst.SERIES_LABEL_PADDING;
        }

        return positionTop;
    },

    /**
     * Render series label.
     * @param {HTMLElement} elSeriesLabelArea series label area element
     * @private
     */
    _renderSeriesLabel: function(elSeriesLabelArea) {
        var formattedValues, firstFormattedValue, groupPositions, labelHeight, html;

        groupPositions = this.seriesData.groupPositions;
        formattedValues = tui.util.pivot(this.dataProcessor.getFormattedGroupValues(this.chartType));
        firstFormattedValue = this.dataProcessor.getFirstFormattedValue(this.chartType);
        labelHeight = renderUtil.getRenderedLabelHeight(firstFormattedValue, this.theme.label);

        html = tui.util.map(formattedValues, function(values, groupIndex) {
            return tui.util.map(values, function(value, index) {
                var position = groupPositions[groupIndex][index],
                    labelHtml = '',
                    labelWidth;

                if (position.top !== position.startTop) {
                    labelWidth = renderUtil.getRenderedLabelWidth(value, this.theme.label);
                    labelHtml = this._makeSeriesLabelHtml({
                        left: position.left - (labelWidth / 2),
                        top: this._makeLabelPositionTop(position, value, labelHeight)
                    }, value, index, groupIndex);
                }
                return labelHtml;
            }, this).join('');
        }, this).join('');

        elSeriesLabelArea.innerHTML = html;
    },

    /**
     * Whether changed or not.
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChanged: function(groupIndex, index) {
        var prevIndexes = this.prevIndexes;

        this.prevIndexes = {
            groupIndex: groupIndex,
            index: index
        };

        return !prevIndexes || (prevIndexes.groupIndex !== groupIndex) || (prevIndexes.index !== index);
    },

    /**
     * To call showGroupTooltipLine function of graphRenderer.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound bound
     */
    onShowGroupTooltipLine: function(bound) {
        if (!this.graphRenderer.showGroupTooltipLine) {
            return;
        }
        this.graphRenderer.showGroupTooltipLine(bound);
    },

    /**
     * To call hideGroupTooltipLine function of graphRenderer.
     */
    onHideGroupTooltipLine: function() {
        if (!this.graphRenderer.hideGroupTooltipLine) {
            return;
        }
        this.graphRenderer.hideGroupTooltipLine();
    }
});

LineTypeSeriesBase.mixin = function(func) {
    tui.util.extend(func.prototype, LineTypeSeriesBase.prototype);
};

module.exports = LineTypeSeriesBase;

},{"../const":19,"../helpers/renderUtil":42}],70:[function(require,module,exports){
/**
 * @fileoverview Map chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

var MapChartSeries = tui.util.defineClass(Series, /** @lends MapChartSeries.prototype */ {
    /**
     * Map chart series component.
     * @constructs MapChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     *      @param {MapChartDataProcessor} params.dataProcessor data processor for map chart
     */
    init: function(params) {
        /**
         * Base position.
         * @type {{left: number, top: number}}
         */
        this.basePosition = {
            left: 0,
            top: 0
        };

        /**
         * Zoom magnification.
         * @type {number}
         */
        this.zoomMagn = 1;

        /**
         * Map ratio.
         * @type {number}
         */
        this.mapRatio = 1;

        /**
         * Graph dimension.
         * @type {{}}
         */
        this.graphDimension = {};

        /**
         * Limit position.
         * @type {{}}
         */
        this.limitPosition = {};

        /**
         * Map model.
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        /**
         * Previous mouse position.
         * @type {?{left: number, top: number}}
         */
        this.prevPosition = null;


        /**
         * Previous moved index.
         * @type {?number}
         */
        this.prevMovedIndex = null;

        /**
         * Whether drag or not.
         * @type {boolean}
         */
        this.isDrag = false;

        Series.call(this, params);
    },

    /**
     * Set map ratio.
     * @private
     */
    _setMapRatio: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            mapDimension = this.mapModel.getMapDimension(),
            widthRatio = seriesDimension.width / mapDimension.width,
            heightRatio = seriesDimension.height / mapDimension.height;

        this.mapRatio = Math.min(widthRatio, heightRatio);
    },

    /**
     * Set graph dimension.
     * @private
     */
    _setGraphDimension: function() {
        var seriesDimension = this.boundsMaker.getDimension('series');

        this.graphDimension = {
            width: seriesDimension.width * this.zoomMagn,
            height: seriesDimension.height * this.zoomMagn
        };
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var container;

        this.mapModel = data.mapModel;
        this._setMapRatio();

        container = Series.prototype.render.call(this, data);
        return container;
    },

    /**
     * Set limit position to move map.
     * @private
     */
    _setLimitPositionToMoveMap: function() {
        var seriesDimension = this.boundsMaker.getDimension('series'),
            graphDimension = this.graphDimension;

        this.limitPosition = {
            left: seriesDimension.width - graphDimension.width,
            top: seriesDimension.height - graphDimension.height
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @private
     * @override
     */
    _renderGraph: function() {
        if (!this.graphContainer) {
            this.graphContainer = dom.create('DIV', 'tui-chart-series-graph-area');
            this.seriesContainer.appendChild(this.graphContainer);
        }

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);

        this._setLimitPositionToMoveMap();

        this.graphRenderer.render(this.graphContainer, {
            colorModel: this.data.colorModel,
            mapModel: this.mapModel,
            dimension: this.graphDimension,
            theme: this.theme
        });
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        var html = tui.util.map(this.mapModel.getLabelData(this.zoomMagn * this.mapRatio), function(datum, index) {
            var label = datum.name || datum.code,
                left = datum.labelPosition.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),
                top = datum.labelPosition.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);
            return this._makeSeriesLabelHtml({
                left: left,
                top: top
            }, datum.name, 0, index);
        }, this).join('');
        seriesLabelContainer.innerHTML = html;
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        Series.prototype._renderSeriesArea.call(this, seriesContainer, data, funcRenderGraph);
        this.graphContainer.appendChild(this.seriesLabelContainer);
    },

    /**
     * Adjust map position.
     * @param {{left: number, top: number}} targetPosition target position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustMapPosition: function(targetPosition) {
        return {
            left: Math.max(Math.min(targetPosition.left, 0), this.limitPosition.left),
            top: Math.max(Math.min(targetPosition.top, 0), this.limitPosition.top)
        };
    },

    /**
     * Update base position for zoom.
     * @param {{width: number, height: number}} prevDimension previous dimension
     * @param {{left: number, top: number}} prevLimitPosition previous limit position
     * @param {number} changedRatio changed ratio
     * @private
     */
    _updateBasePositionForZoom: function(prevDimension, prevLimitPosition, changedRatio) {
        var prevBasePosition = this.basePosition,
            prevLeft = prevBasePosition.left - (prevLimitPosition.left / 2),
            prevTop = prevBasePosition.top - (prevLimitPosition.top / 2),
            newBasePosition = {
                left: (prevLeft * changedRatio) + (this.limitPosition.left / 2),
                top: (prevTop * changedRatio) + (this.limitPosition.top / 2)
            };

        this.basePosition = this._adjustMapPosition(newBasePosition);
    },

    /**
     * Zoom.
     * @param {number} changedRatio changed ratio
     * @private
     */
    _zoom: function(changedRatio) {
        var prevDimension = this.graphDimension,
            prevLimitPosition = this.limitPosition;

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._setLimitPositionToMoveMap();
        this._updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        this._renderSeriesLabel(this.seriesLabelContainer);
    },

    /**
     * Update positions to resize.
     * @param {number} prevMapRatio previous ratio
     * @private
     */
    _updatePositionsToResize: function(prevMapRatio) {
        var changedRatio = this.mapRatio / prevMapRatio;

        this.basePosition.left *= changedRatio;
        this.basePosition.top *= changedRatio;

        this.limitPosition.left *= changedRatio;
        this.limitPosition.top *= changedRatio;
    },

    /**
     * Resize graph.
     * @private
     */
    _resizeGraph: function() {
        var prevRatio = this.mapRatio;

        this._setMapRatio();

        this._setGraphDimension();
        renderUtil.renderDimension(this.graphContainer, this.graphDimension);
        this.graphRenderer.setSize(this.graphDimension);

        this._updatePositionsForResizing(prevRatio);
        renderUtil.renderPosition(this.graphContainer, this.basePosition);

        this._renderSeriesLabel(this.seriesLabelContainer);
    },

    /**
     * On click series.
     */
    onClickSeries: function() {},

    /**
     * Whether changed or not.
     * @param {?{left: number, top: number}} prevPosition previous position
     * @param {{left: number, top: number}} position position
     * @returns {boolean} result boolean
     * @private
     */
    _isChangedPosition: function(prevPosition, position) {
        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
    },

    /**
     * Show wedge.
     * @param {number} index map data index
     * @private
     */
    _showWedge: function(index) {
        var datum = this.mapModel.getDatum(index);

        if (!tui.util.isUndefined(datum.percentValue)) {
            this.fire('showWedge', datum.percentValue);
        }
    },

    /**
     * Show tooltip
     * @param {number} index map data index
     * @param {{left: number, top: number}} mousePosition mouse position
     * @private
     */
    _showTooltip: function(index, mousePosition) {
        this.fire('showTooltip', {
            chartType: this.chartType,
            indexes: {
                index: index
            },
            mousePosition: mousePosition
        });
    },

    /**
     * Get series container bound.
     * @returns {{left: number, top: number}} container bound
     * @private
     */
    _getContainerBound: function() {
        if (!this.containerBound) {
            this.containerBound = this.seriesContainer.getBoundingClientRect();
        }
        return this.containerBound;
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position position
     */
    onMoveSeries: function(position) {
        var foundIndex = this._executeGraphRenderer(position, 'findSectorIndex'),
            containerBound;

        if (!tui.util.isNull(foundIndex)) {
            if (this.prevMovedIndex !== foundIndex) {
                if (this.prevMovedIndex) {
                    this.graphRenderer.restoreColor(this.prevMovedIndex);
                    this.fire('hideWedge');
                    this.fire('hideTooltip');
                }

                this.graphRenderer.changeColor(foundIndex);
            }

            if (this._isChangedPosition(this.prevPosition, position)) {
                containerBound = this._getContainerBound();
                this._showTooltip(foundIndex, {
                    left: position.left - containerBound.left,
                    top: position.top - containerBound.top
                });
                this.prevMovedIndex = foundIndex;
            }

            this._showWedge(foundIndex);
        } else if (!tui.util.isNull(this.prevMovedIndex)) {
            this.graphRenderer.restoreColor(this.prevMovedIndex);
            this.fire('hideWedge');
            this.fire('hideTooltip');
            this.prevMovedIndex = null;
        }
        this.prevPosition = position;
    },

    /**
     * On drag start series.
     * @param {{left: number, top: number}} position position
     */
    onDragStartSeries: function(position) {
        this.startPosition = {
            left: position.left - this.basePosition.left,
            top: position.top - this.basePosition.top
        };
    },

    /**
     * On drag series.
     * @param {{left: number, top: number}} position position
     */
    onDragSeries: function(position) {
        var movePosition = this._adjustMapPosition({
            left: position.left - this.startPosition.left,
            top: position.top - this.startPosition.top
        });

        renderUtil.renderPosition(this.graphContainer, movePosition);
        this.basePosition = movePosition;

        if (!this.isDrag) {
            this.isDrag = true;
            this.fire('hideTooltip');
        }
    },

    /**
     * On drag end series.
     */
    onDragEndSeries: function() {
        this.isDrag = false;
    },

    /**
     * On zoom.
     * @param {number} newMagn new zoom magnification
     */
    onZoom: function(newMagn) {
        var changedRatio = newMagn / this.zoomMagn;

        this.zoomMagn = newMagn;

        this._zoom(changedRatio);
        this.userEvent.fire('zoom', newMagn);
    },

    /**
     * Animate component.
     */
    animateComponent: function() {
        this.animateShowingAboutSeriesLabelArea();
    }
});

tui.util.CustomEvents.mixin(MapChartSeries);

module.exports = MapChartSeries;

},{"../helpers/domHandler":38,"../helpers/renderUtil":42,"./series":72}],71:[function(require,module,exports){
/**
 * @fileoverview Pie chart series component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var Series = require('./series'),
    chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var PieChartSeries = tui.util.defineClass(Series, /** @lends PieChartSeries.prototype */ {
    /**
     * Line chart series component.
     * @constructs PieChartSeries
     * @extends Series
     * @param {object} params parameters
     *      @param {object} params.model series model
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        /**
         * legend align option.
         * @type {boolean}
         */
        this.legendAlign = params.legendAlign;

        /**
         * chart background.
         * @type {string}
         */
        this.chartBackground = params.chartBackground;

        Series.call(this, params);
    },

    /**
     * Make sectors information.
     * @param {Array.<number>} percentValues percent values
     * @param {{cx: number, cy: number, r: number}} circleBound circle bound
     * @returns {Array.<object>} sectors information
     * @private
     */
    _makeSectorData: function(percentValues, circleBound) {
        var cx = circleBound.cx,
            cy = circleBound.cy,
            r = circleBound.r,
            angle = 0,
            delta = 10,
            paths;

        paths = tui.util.map(percentValues, function(percentValue) {
            var addAngle = chartConst.ANGLE_360 * percentValue,
                endAngle = angle + addAngle,
                popupAngle = angle + (addAngle / 2),
                angles = {
                    start: {
                        startAngle: angle,
                        endAngle: angle
                    },
                    end: {
                        startAngle: angle,
                        endAngle: endAngle
                    }
                },
                positionData = {
                    cx: cx,
                    cy: cy,
                    angle: popupAngle
                };

            angle = endAngle;

            return {
                percentValue: percentValue,
                angles: angles,
                centerPosition: this._getArcPosition(tui.util.extend({
                    r: (r / 2) + delta
                }, positionData)),
                outerPosition: {
                    start: this._getArcPosition(tui.util.extend({
                        r: r
                    }, positionData)),
                    middle: this._getArcPosition(tui.util.extend({
                        r: r + delta
                    }, positionData))
                }
            };
        }, this);

        return paths;
    },

    /**
     * Make series data.
     * @returns {{
     *      chartBackground: string,
     *      circleBound: ({cx: number, cy: number, r: number}),
     *      sectorData: Array.<object>
     * }} add data for graph rendering
     * @private
     * @override
     */
    _makeSeriesData: function() {
        var circleBound = this._makeCircleBound(this.boundsMaker.getDimension('series'), {
                showLabel: this.options.showLabel,
                legendAlign: this.legendAlign
            }),
            sectorData = this._makeSectorData(this._getPercentValues()[0], circleBound);

        return {
            chartBackground: this.chartBackground,
            circleBound: circleBound,
            sectorData: sectorData
        };
    },

    /**
     * Make circle bound
     * @param {{width: number, height:number}} dimension chart dimension
     * @param {{showLabel: boolean, legendAlign: string}} options options
     * @returns {{cx: number, cy: number, r: number}} circle bounds
     * @private
     */
    _makeCircleBound: function(dimension, options) {
        var width = dimension.width,
            height = dimension.height,
            isSmallPie = predicate.isOuterLegendAlign(options.legendAlign) && options.showLabel,
            radiusRate = isSmallPie ? chartConst.PIE_GRAPH_SMALL_RATE : chartConst.PIE_GRAPH_DEFAULT_RATE,
            diameter = tui.util.multiplication(tui.util.min([width, height]), radiusRate);

        return {
            cx: tui.util.division(width, 2),
            cy: tui.util.division(height, 2),
            r: tui.util.division(diameter, 2)
        };
    },

    /**
     * Get arc position.
     * @param {object} params parameters
     *      @param {number} params.cx center x
     *      @param {number} params.cy center y
     *      @param {number} params.r radius
     *      @param {number} params.angle angle(degree)
     * @returns {{left: number, top: number}} arc position
     * @private
     */
    _getArcPosition: function(params) {
        return {
            left: params.cx + (params.r * Math.sin(params.angle * chartConst.RAD)),
            top: params.cy - (params.r * Math.cos(params.angle * chartConst.RAD))
        };
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     * @override
     */
    _renderGraph: function(dimension, seriesData) {
        var funcShowTooltip = tui.util.bind(this.showTooltip, this, {
                allowNegativeTooltip: !!this.allowNegativeTooltip,
                chartType: this.chartType
            }),
            callbacks = {
                funcShowTooltip: funcShowTooltip,
                funcHideTooltip: tui.util.bind(this.hideTooltip, this),
                funcSelectSeries: tui.util.bind(this.selectSeries, this)
            },
            params = this._makeParamsForGraphRendering(dimension, seriesData);

        this.graphRenderer.render(this.seriesContainer, params, callbacks);
    },

    /**
     * Resize.
     * @override
     */
    resize: function() {
        Series.prototype.resize.apply(this, arguments);
        this._moveLegendLines();
    },

    /**
     * showTooltip is mouseover event callback on series graph.
     * @param {object} params parameters
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
     * @param {number} groupIndex group index
     * @param {number} index index
     * @param {{left: number, top: number}} mousePosition mouse position
     */
    showTooltip: function(params, bound, groupIndex, index, mousePosition) {
        this.fire('showTooltip', tui.util.extend({
            indexes: {
                groupIndex: groupIndex,
                index: index
            },
            mousePosition: mousePosition
        }, params));
    },

    /**
     * hideTooltip is mouseout event callback on series graph.
     * @param {string} id tooltip id
     */
    hideTooltip: function() {
        this.fire('hideTooltip');
    },

    /**
     * Make series data by selection.
     * @param {number} index index
     * @returns {{indexes: {index: number, groupIndex: number}}} series data
     * @private
     */
    _makeSeriesDataBySelection: function(index) {
        return {
            indexes: {
                index: index,
                groupIndex: index
            }
        };
    },

    /**
     * selectSeries is click event callback on series graph.
     * @param {number} index index
     */
    selectSeries: function(index) {
        var seriesData = this._makeSeriesDataBySelection(index);
        if (this.selectedIndex === index) {
            this.onUnselectSeries(seriesData);
            delete this.selectedIndex;
        } else {
            if (!tui.util.isUndefined(this.selectedIndex)) {
                this.onUnselectSeries(this._makeSeriesDataBySelection(this.selectedIndex));
            }
            this.onSelectSeries(seriesData);
            this.selectedIndex = index;
        }
    },

    /**
     * Get series label.
     * @param {object} params parameters
     *      @param {string} params.legend legend
     *      @param {string} params.label label
     *      @param {string} params.separator separator
     *      @param {{legendAlign: ?string, showLabel: boolean}} params.options options
     * @returns {string} series label
     * @private
     */
    _getSeriesLabel: function(params) {
        var seriesLabel = '';

        if (this.legendAlign) {
            seriesLabel = '<span class="tui-chart-series-legend">' + params.legend + '</span>';
        }

        if (this.options.showLabel) {
            seriesLabel += (seriesLabel ? params.separator : '') + params.label;
        }

        return seriesLabel;
    },

    /**
     * Render center legend.
     * @param {object} params parameters
     *      @param {Array.<object>} params.positions positions
     *      @param {string} params.separator separator
     *      @param {object} params.options options
     *      @param {function} params.funcMoveToPosition function
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderLegendLabel: function(params, seriesLabelContainer) {
        var positions = params.positions,
            htmls;

        htmls = tui.util.map(this.dataProcessor.getLegendLabels(), function(legend, index) {
            var html = '',
                label, position;

            if (positions[index]) {
                label = this._getSeriesLabel({
                    legend: legend,
                    label: this.dataProcessor.getFormattedValue(0, index, this.chartType),
                    separator: params.separator
                });
                position = params.funcMoveToPosition(positions[index], label);
                html = this._makeSeriesLabelHtml(position, label, 0, index);
            }

            return html;
        }, this);
        seriesLabelContainer.innerHTML = htmls.join('');
    },

    /**
     * Move to center position.
     * @param {{left: number, top: number}} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} center position
     * @private
     */
    _moveToCenterPosition: function(position, label) {
        var left = position.left - (renderUtil.getRenderedLabelWidth(label, this.theme.label) / 2),
            top = position.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        return {
            left: left,
            top: top
        };
    },

    /**
     * Pick poistions from sector data.
     * @param {string} positionType position type
     * @returns {Array} positions
     * @private
     */
    _pickPositionsFromSectorData: function(positionType) {
        return tui.util.map(this.seriesData.sectorData, function(datum) {
            return datum.percentValue ? datum[positionType] : null;
        });
    },

    /**
     * Render center legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderCenterLegend: function(seriesLabelContainer) {
        this._renderLegendLabel({
            positions: this._pickPositionsFromSectorData('centerPosition'),
            funcMoveToPosition: tui.util.bind(this._moveToCenterPosition, this),
            separator: '<br>'
        }, seriesLabelContainer);
    },

    /**
     * Add end position.
     * @param {number} centerLeft center left
     * @param {Array.<object>} positions positions
     * @private
     */
    _addEndPosition: function(centerLeft, positions) {
        tui.util.forEachArray(positions, function(position) {
            var end;

            if (!position) {
                return;
            }

            end = tui.util.extend({}, position.middle);
            if (end.left < centerLeft) {
                end.left -= chartConst.SERIES_OUTER_LABEL_PADDING;
            } else {
                end.left += chartConst.SERIES_OUTER_LABEL_PADDING;
            }
            position.end = end;
        });
    },

    /**
     * Move to outer position.
     * @param {number} centerLeft center left
     * @param {object} position position
     * @param {string} label label
     * @returns {{left: number, top: number}} outer position
     * @private
     */
    _moveToOuterPosition: function(centerLeft, position, label) {
        var positionEnd = position.end,
            left = positionEnd.left,
            top = positionEnd.top - (renderUtil.getRenderedLabelHeight(label, this.theme.label) / 2);

        if (left < centerLeft) {
            left -= renderUtil.getRenderedLabelWidth(label, this.theme.label) + chartConst.SERIES_LABEL_PADDING;
        } else {
            left += chartConst.SERIES_LABEL_PADDING;
        }

        return {
            left: left,
            top: top
        };
    },

    /**
     * Render outer legend.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderOuterLegend: function(seriesLabelContainer) {
        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,
            outerPositions = this._pickPositionsFromSectorData('outerPosition'),
            filteredPositions = tui.util.filter(outerPositions, function(position) {
                return position;
            });

        this._addEndPosition(centerLeft, filteredPositions);
        this._renderLegendLabel({
            positions: outerPositions,
            funcMoveToPosition: tui.util.bind(this._moveToOuterPosition, this, centerLeft),
            separator: ':&nbsp;'
        }, seriesLabelContainer);

        this.graphRenderer.renderLegendLines(filteredPositions);
    },

    /**
     * Render series label.
     * @param {HTMLElement} seriesLabelContainer series label area element
     * @private
     */
    _renderSeriesLabel: function(seriesLabelContainer) {
        var legendAlign = this.legendAlign;

        if (predicate.isOuterLegendAlign(legendAlign)) {
            this._renderOuterLegend(seriesLabelContainer);
        } else {
            this._renderCenterLegend(seriesLabelContainer);
        }
    },

    /**
     * Animate showing about series label area.
     * @override
     */
    animateShowingAboutSeriesLabelArea: function() {
        this.graphRenderer.animateLegendLines();
        Series.prototype.animateShowingAboutSeriesLabelArea.call(this);
    },

    /**
     * Move legend lines.
     * @private
     * @override
     */
    _moveLegendLines: function() {
        var centerLeft = this.boundsMaker.getDimension('chart').width / 2,
            outerPositions = this._pickPositionsFromSectorData('outerPosition'),
            filteredPositions = tui.util.filter(outerPositions, function(position) {
                return position;
            });

        this._addEndPosition(centerLeft, filteredPositions);
        this.graphRenderer.moveLegendLines(filteredPositions);
    },

    /**
     * On click series.
     * @param {{left: number, top: number}} position mouse position
     */
    onClickSeries: function(position) {
        this._executeGraphRenderer(position, 'clickSeries');
    },

    /**
     * On move series.
     * @param {{left: number, top: number}} position mouse position
     */
    onMoveSeries: function(position) {
        this._executeGraphRenderer(position, 'moveMouseOnSeries');
    }
});

tui.util.CustomEvents.mixin(PieChartSeries);

module.exports = PieChartSeries;

},{"../const":19,"../helpers/predicate":41,"../helpers/renderUtil":42,"./series":72}],72:[function(require,module,exports){
/**
 * @fileoverview Series base component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    pluginFactory = require('../factories/pluginFactory');

var Series = tui.util.defineClass(/** @lends Series.prototype */ {
    /**
     * Series base component.
     * @constructs Series
     * @param {object} params parameters
     *      @param {object} params.options series options
     *      @param {object} params.theme series theme
     */
    init: function(params) {
        var libType = params.libType || chartConst.DEFAULT_PLUGIN;

        /**
         * Chart type
         * @type {string}
         */
        this.chartType = params.chartType;

        /**
         * Component type
         * @type {string}
         */
        this.componentType = params.componentType;

        /**
         * Data processor
         * @type {DataProcessor}
         */
        this.dataProcessor = params.dataProcessor;

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * User event listener
         * @type {UserEventListener}
         */
        this.userEvent = params.userEvent;

        /**
         * Options
         * @type {object}
         */
        this.options = params.options || {};

        /**
         * Theme
         * @type {object}
         */
        this.orgTheme = this.theme = params.theme;

        /**
         * whether chart has axes or not
         * @type {boolean}
         */
        this.hasAxes = !!params.hasAxes;

        /**
         * Graph renderer
         * @type {object}
         */
        this.graphRenderer = pluginFactory.get(libType, params.chartType);

        /**
         * Series view className
         * @type {string}
         */
        this.className = 'tui-chart-series-area';

        /**
         * series container
         * @type {HTMLElement}
         */
        this.seriesContainer = null;

        /**
         * series label container
         * @type {HTMLElement}
         */
        this.seriesLabelContainer = null;

        /**
         * series data
         * @type {Array.<object>}
         */
        this.seriesData = [];

        /**
         * Selected legend index
         * @type {?number}
         */
        this.selectedLegendIndex = null;
    },

    /**
     * Make series data.
     * @private
     * @abstract
     */
    _makeSeriesData: function() {},

    /**
     * Get seriesData
     * @returns {object} series data
     */
    getSeriesData: function() {
        return this.seriesData;
    },

    /**
     * Render series label.
     * @private
     * @abstract
     */
    _renderSeriesLabel: function() {},

    /**
     * Get percent values.
     * @returns {Array.<Array.<number>>} percent values.
     * @private
     */
    _getPercentValues: function() {
        return this.dataProcessor.getPercentValues(this.chartType);
    },
    /**
     * Render series label area
     * @param {?HTMLElement} seriesLabelContainer series label area element
     * @returns {HTMLElement} series label area element
     * @private
     */
    _renderSeriesLabelArea: function(seriesLabelContainer) {
        if (!seriesLabelContainer) {
            seriesLabelContainer = dom.create('div', 'tui-chart-series-label-area');
        }

        this._renderSeriesLabel(seriesLabelContainer);
        return seriesLabelContainer;
    },

    /**
     * Render series area.
     * @param {HTMLElement} seriesContainer series area element
     * @param {object} data data for rendering
     * @param {function} funcRenderGraph function for graph rendering
     * @private
     */
    _renderSeriesArea: function(seriesContainer, data, funcRenderGraph) {
        var bound = this.boundsMaker.getBound('series'),
            expandedBound, seriesData, seriesLabelContainer;

        this.data = data;

        expandedBound = this.hasAxes ? renderUtil.expandBound(bound) : bound;
        this.seriesData = seriesData = this._makeSeriesData();

        renderUtil.renderDimension(seriesContainer, expandedBound.dimension);
        this._renderPosition(seriesContainer, expandedBound.position);

        if (funcRenderGraph) {
            funcRenderGraph(expandedBound.dimension, seriesData);
        }

        seriesLabelContainer = this._renderSeriesLabelArea(this.seriesLabelContainer);

        if (!this.seriesLabelContainer) {
            this.seriesLabelContainer = seriesLabelContainer;
            dom.append(seriesContainer, seriesLabelContainer);
        }
    },

    /**
     * Make parameters for graph rendering.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @returns {object} parameters for graph rendering
     * @private
     */
    _makeParamsForGraphRendering: function(dimension, seriesData) {
        return tui.util.extend({
            dimension: dimension,
            chartType: this.chartType,
            theme: this.theme,
            options: this.options
        }, seriesData);
    },

    /**
     * Render raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _renderGraph: function(dimension, seriesData) {
        var params = this._makeParamsForGraphRendering(dimension, seriesData);
        this.graphRenderer.render(this.seriesContainer, params);
    },

    /**
     * Render series component.
     * @param {object} data data for rendering
     * @returns {HTMLElement} series element
     */
    render: function(data) {
        var el = dom.create('DIV', this.className);

        this.seriesContainer = el;
        this._renderSeriesArea(el, data, tui.util.bind(this._renderGraph, this));

        return el;
    },

    /**
     * Update theme.
     * @param {object} theme legend theme
     * @param {?Array.<?boolean>} checkedLegends checked legends
     * @returns {object} updated theme
     * @private
     */
    _updateTheme: function(theme, checkedLegends) {
        var cloneTheme;

        if (!checkedLegends.length) {
            return theme;
        }

        cloneTheme = JSON.parse(JSON.stringify(theme));
        cloneTheme.colors = tui.util.filter(cloneTheme.colors, function(color, index) {
            return checkedLegends[index];
        });

        return cloneTheme;
    },

    /**
     * Rerender
     * @param {object} data data for rendering
     */
    rerender: function(data) {
        var groupValues = this.dataProcessor.getGroupValues(this.chartType),
            that = this;

        if (this.graphRenderer.clear) {
            this.graphRenderer.clear();
        }
        this.seriesContainer.innerHTML = '';
        this.seriesLabelContainer = null;
        this.selectedLegendIndex = null;
        this.seriesData = [];

        if (groupValues && groupValues.length) {
            this.theme = this._updateTheme(this.orgTheme, data.checkedLegends);
            this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(that._renderGraph, this));
            if (this.labelShower) {
                clearInterval(this.labelShower.timerId);
            }
            this.animateComponent();
        }
    },

    /**
     * Resize raphael graph.
     * @param {{width: number, height: number}} dimension dimension
     * @param {object} seriesData series data
     * @private
     */
    _resizeGraph: function(dimension, seriesData) {
        this.graphRenderer.resize(tui.util.extend({
            dimension: dimension
        }, seriesData));
    },

    /**
     * Resize series component.
     * }} bound series bound
     * @param {object} data data for rendering
     */
    resize: function(data) {
        this._renderSeriesArea(this.seriesContainer, data, tui.util.bind(this._resizeGraph, this));
    },

    /**
     * Render bounds
     * @param {HTMLElement} el series element
     * @param {{top: number, left: number}} position series position
     * @private
     */
    _renderPosition: function(el, position) {
        var hiddenWidth = renderUtil.isOldBrowser() ? chartConst.HIDDEN_WIDTH : 0;

        renderUtil.renderPosition(el, {
            top: position.top - (hiddenWidth * 2),
            left: position.left - hiddenWidth
        });
    },

    /**
     * Get limit distance from zero point.
     * @param {number} size chart size (width or height)
     * @param {{min: number, max: number}} limit limit
     * @returns {{toMax: number, toMin: number}} pixel distance
     * @private
     */
    _getLimitDistanceFromZeroPoint: function(size, limit) {
        var min = limit.min,
            max = limit.max,
            distance = max - min,
            toMax = 0,
            toMin = 0;

        if (min <= 0 && max >= 0) {
            toMax = (distance + min) / distance * size;
            toMin = (distance - max) / distance * size;
        }

        return {
            toMax: toMax,
            toMin: toMin
        };
    },

    /**
     * Find label element.
     * @param {HTMLElement} elTarget target element
     * @returns {HTMLElement} label element
     * @private
     */
    _findLabelElement: function(elTarget) {
        var elLabel = null;

        if (dom.hasClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL)) {
            elLabel = elTarget;
        } else {
            elLabel = dom.findParentByClass(elTarget, chartConst.CLASS_NAME_SERIES_LABEL);
        }

        return elLabel;
    },

    /**
     * To call showAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onShowAnimation: function(data) {
        if (!this.graphRenderer.showAnimation) {
            return;
        }
        this.graphRenderer.showAnimation(data);
    },

    /**
     * To call hideAnimation function of graphRenderer.
     * @param {{groupIndex: number, index: number}} data data
     */
    onHideAnimation: function(data) {
        if (!this.graphRenderer.hideAnimation) {
            return;
        }
        this.graphRenderer.hideAnimation(data);
    },

    /**
     * To call showGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onShowGroupAnimation: function(index) {
        if (!this.graphRenderer.showGroupAnimation) {
            return;
        }
        this.graphRenderer.showGroupAnimation(index);
    },

    /**
     * To call hideGroupAnimation function of graphRenderer.
     * @param {number} index index
     */
    onHideGroupAnimation: function(index) {
        if (!this.graphRenderer.hideGroupAnimation) {
            return;
        }
        this.graphRenderer.hideGroupAnimation(index);
    },

    /**
     * Animate component.
     */
    animateComponent: function() {
        if (this.graphRenderer.animate) {
            this.graphRenderer.animate(tui.util.bind(this.animateShowingAboutSeriesLabelArea, this));
        }
    },

    /**
     * Make opacity cssText.
     * @param {number} opacity opacity
     * @returns {string} cssText
     * @private
     */
    _makeOpacityCssText: (function() {
        var funcMakeOpacityCssText;
        if (renderUtil.isOldBrowser()) {
            funcMakeOpacityCssText = function(opacity) {
                return ';filter: alpha(opacity=' + (opacity * 100) + ')';
            };
        } else {
            funcMakeOpacityCssText = function(_opacity) {
                return ';opacity: ' + _opacity;
            };
        }
        return funcMakeOpacityCssText;
    })(),

    /**
     * Make html about series label.
     * @param {{left: number, top: number}} position position
     * @param {string} value value
     * @param {number} groupIndex group index
     * @param {number} index index
     * @returns {string} html string
     * @private
     */
    _makeSeriesLabelHtml: function(position, value, groupIndex, index) {
        var cssObj = tui.util.extend(position, this.theme.label);
        if (!tui.util.isNull(this.selectedLegendIndex) && this.selectedLegendIndex !== index) {
            cssObj.opacity = this._makeOpacityCssText(0.3);
        } else {
            cssObj.opacity = '';
        }
        return seriesTemplate.tplSeriesLabel({
            cssText: seriesTemplate.tplCssText(cssObj),
            value: value,
            groupIndex: groupIndex,
            index: index
        });
    },

    /**
     * Animate showing about series label area.
     */
    animateShowingAboutSeriesLabelArea: function() {
        var that = this;

        if ((!this.options.showLabel && !this.legendAlign) || !this.seriesLabelContainer) {
            return;
        }

        dom.addClass(this.seriesLabelContainer, 'show');

        if (renderUtil.isIE7()) {
            this.seriesLabelContainer.style.filter = '';
        } else {
            this.labelShower = new tui.component.Effects.Fade({
                element: this.seriesLabelContainer,
                duration: 300
            });
            this.labelShower.action({
                start: 0,
                end: 1,
                complete: function() {
                    clearInterval(that.labelShower.timerId);
                    delete that.labelShower;
                }
            });
        }
    },

    /**
     * Make exportation data for series type userEvent.
     * @param {object} seriesData series data
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
     * @private
     */
    _makeExportationSeriesData: function(seriesData) {
        var legendIndex = seriesData.indexes.index,
            legendData = this.dataProcessor.getLegendData(legendIndex);

        return {
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: seriesData.indexes.groupIndex
        };
    },

    /**
     * Execute graph renderer.
     * @param {{left: number, top: number}} position mouse position
     * @param {string} funcName function name
     * @returns {*} result.
     * @private
     */
    _executeGraphRenderer: function(position, funcName) {
        var result;

        this.fire('hideTooltipContainer');

        if (this.options.showLabel) {
            dom.removeClass(this.seriesLabelContainer, 'show');
        }

        result = this.graphRenderer[funcName](position);

        if (this.options.showLabel) {
            dom.addClass(this.seriesLabelContainer, 'show');
        }

        this.fire('showTooltipContainer');

        return result;
    },

    /**
     * To call selectSeries callback of userEvent.
     * @param {object} seriesData series data
     */
    onSelectSeries: function(seriesData) {
        this.userEvent.fire('selectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.hasSelection) {
            this.graphRenderer.selectSeries(seriesData.indexes);
        }
    },

    /**
     * To call unselectSeries callback of userEvent.
     * @param {object} seriesData series data.
     */
    onUnselectSeries: function(seriesData) {
        this.userEvent.fire('unselectSeries', this._makeExportationSeriesData(seriesData));
        if (this.options.hasSelection) {
            this.graphRenderer.unselectSeries(seriesData.indexes);
        }
    },

    /**
     *On select legend.
     * @param {string} chartType chart type
     * @param {?number} legendIndex legend index
     */
    onSelectLegend: function(chartType, legendIndex) {
        var groupValues = this.dataProcessor.getGroupValues(this.chartType);

        if (this.chartType !== chartType && !tui.util.isNull(legendIndex)) {
            legendIndex = -1;
        }

        this.selectedLegendIndex = legendIndex;

        if (groupValues && groupValues.length) {
            this._renderSeriesArea(this.seriesContainer, this.data);
            this.graphRenderer.selectLegend(legendIndex);
        }
    },

    /**
     * Show label.
     */
    showLabel: function() {
        this.options.showLabel = true;
        dom.addClass(this.seriesLabelContainer, 'show opacity');
    },

    /**
     * Hide label.
     */
    hideLabel: function() {
        this.options.showLabel = false;
        dom.removeClass(this.seriesLabelContainer, 'show');
    }
});

module.exports = Series;

},{"../const":19,"../factories/pluginFactory":31,"../helpers/domHandler":38,"../helpers/renderUtil":42,"./seriesTemplate":73}],73:[function(require,module,exports){
/**
 * @fileoverview This is templates of series.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}" data-group-index="{{ groupIndex }}" data-index="{{ index }}">{{ value }}</div>',
    TEXT_CSS_TEXT: 'left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};font-size:{{ fontSize }}px{{opacity}}',
    HTML_ZOOM_BUTTONS: '<a class="tui-chart-zoom-btn" href="#" data-magn="2"><div class="horizontal-line"></div><div class="vertical-line"></div></a>' +
            '<a class="tui-chart-zoom-btn" href="#" data-magn="0.5"><div class="horizontal-line"></div></a>'
};

module.exports = {
    tplSeriesLabel: templateMaker.template(htmls.HTML_SERIES_LABEL),
    tplCssText: templateMaker.template(htmls.TEXT_CSS_TEXT),
    ZOOM_BUTTONS: htmls.HTML_ZOOM_BUTTONS
};

},{"../helpers/templateMaker":43}],74:[function(require,module,exports){
/**
 * @fileoverview Zoom component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var seriesTemplate = require('./seriesTemplate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    eventListener = require('../helpers/eventListener');

var Zoom = tui.util.defineClass(/** @lends Zoom.prototype */{
    /**
     * Zoom component.
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     * @constructs Zoom
     */
    init: function(params) {
        this.className = 'tui-chart-zoom-area';

        /**
         * Bounds maker
         * @type {BoundsMaker}
         */
        this.boundsMaker = params.boundsMaker;

        /**
         * Magnification.
         * @type {number}
         */
        this.magn = 1;
    },

    /**
     * Render.
     * @returns {HTMLElement} zoom container
     */
    render: function() {
        var container = dom.create('DIV', this.className);

        container.innerHTML += seriesTemplate.ZOOM_BUTTONS;
        renderUtil.renderPosition(container, this.boundsMaker.getPosition('series'));
        this._attachEvent(container);

        return container;
    },

    /**
     * Find button element.
     * @param {HTMLElement} target target element.
     * @returns {?HTMLElement} button element
     * @private
     */
    _findBtnElement: function(target) {
        var btnClassName = 'tui-chart-zoom-btn',
            btnElement = target;

        if (!dom.hasClass(target, btnClassName)) {
            btnElement = dom.findParentByClass(target, btnClassName);
        }

        return btnElement;
    },

    /**
     * On click.
     * @param {MouseEvent} e mouse event
     * @returns {?boolean} prevent default for ie
     * @private
     */
    _onClick: function(e) {
        var target = e.target || e.srcElement,
            btnElement = this._findBtnElement(target),
            changedMagn = 0,
            magn;

        if (btnElement) {
            magn = parseFloat(btnElement.getAttribute('data-magn'));
            changedMagn = this.magn * magn;
        }

        if (changedMagn >= 1) {
            this.magn = changedMagn;
            this.fire('zoom', this.magn);
        }

        if (e.preventDefault) {
            e.preventDefault();
        } else {
            return false;
        }
    },

    /**
     * Attach event.
     * @param {HTMLElement} container container
     * @private
     */
    _attachEvent: function(container) {
        eventListener.bindEvent('click', container, tui.util.bind(this._onClick, this));
    }
});

tui.util.CustomEvents.mixin(Zoom);

module.exports = Zoom;

},{"../helpers/domHandler":38,"../helpers/eventListener":39,"../helpers/renderUtil":42,"./seriesTemplate":73}],75:[function(require,module,exports){
'use strict';

var DEFAULT_COLOR = '#000000',
    DEFAULT_BACKGROUND = '#ffffff',
    EMPTY = '',
    DEFAULT_AXIS = {
        tickColor: DEFAULT_COLOR,
        title: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    };

var defaultTheme = {
    chart: {
        background: DEFAULT_BACKGROUND,
        fontFamily: 'Verdana'
    },
    title: {
        fontSize: 18,
        fontFamily: EMPTY,
        color: DEFAULT_COLOR
    },
    yAxis: DEFAULT_AXIS,
    xAxis: DEFAULT_AXIS,
    plot: {
        lineColor: '#dddddd',
        background: '#ffffff'
    },
    series: {
        label: {
            fontSize: 11,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        },
        colors: ['#ac4142', '#d28445', '#f4bf75', '#90a959', '#75b5aa', '#6a9fb5', '#aa759f', '#8f5536'],
        borderColor: EMPTY,
        selectionColor: EMPTY,
        startColor: '#F4F4F4',
        endColor: '#345391',
        overColor: '#F0C952'
    },
    legend: {
        label: {
            fontSize: 12,
            fontFamily: EMPTY,
            color: DEFAULT_COLOR
        }
    },
    tooltip: {}
};

module.exports = defaultTheme;

},{}],76:[function(require,module,exports){
/**
 * @fileoverview Group tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    GroupTooltipPositionModel = require('./groupTooltipPositionModel'),
    chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil'),
    defaultTheme = require('../themes/defaultTheme'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc GroupTooltip component.
 * @class GroupTooltip
 */
var GroupTooltip = tui.util.defineClass(TooltipBase, /** @lends GroupTooltip.prototype */ {
    /**
     * Group tooltip component.
     * @constructs GroupTooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} items items data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, items) {
        var template = tooltipTemplate.tplGroupItem,
            cssTextTemplate = tooltipTemplate.tplGroupCssText,
            colors = this._makeColors(this.theme),
            itemsHtml = tui.util.map(items, function(item, index) {
                return template(tui.util.extend({
                    cssText: cssTextTemplate({color: colors[index]})
                }, item));
            }, this).join('');

        return tooltipTemplate.tplGroup({
            category: category,
            items: itemsHtml
        });
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     * @override
     */
    render: function() {
        var el = TooltipBase.prototype.render.call(this),
            chartDimension = this.boundsMaker.getDimension('chart'),
            bound = this.boundsMaker.getBound('tooltip');

        this.positionModel = new GroupTooltipPositionModel(chartDimension, bound, this.isVertical, this.options);
        this.orgWholeLegendData = this.dataProcessor.getWholeLegendData();

        return el;
    },

    /**
     * Rerender.
     * @param {{checkedLegends: Array.<boolean>}} data rendering data
     * @override
     */
    rerender: function(data) {
        TooltipBase.prototype.rerender.call(this, data);

        this.theme = this._updateLegendTheme(data.checkedLegends);
    },

    /**
     * Update legend theme.
     * @param {object | Array.<boolean>}checkedLegends checked legends
     * @returns {{colors: Array.<string>}} legend theme
     * @private
     */
    _updateLegendTheme: function(checkedLegends) {
        var colors = [];

        tui.util.forEachArray(this.orgWholeLegendData, function(item) {
            var _checkedLegends = checkedLegends[item.chartType] || checkedLegends;
            if (_checkedLegends[item.index]) {
                colors.push(item.theme.color);
            }
        });

        return {
            colors: colors
        };
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        return tui.util.map(this.dataProcessor.getWholeFormattedValues(), function(values, index) {
            return {
                category: this.dataProcessor.getCategory(index),
                values: values
            };
        }, this);
    },

    /**
     * Make colors.
     * @param {object} theme tooltip theme
     * @returns {Array.<string>} colors
     * @private
     */
    _makeColors: function(theme) {
        var colorIndex = 0,
            legendLabels = this.dataProcessor.getWholeLegendData(),
            defaultColors, colors, prevChartType;

        if (theme.colors) {
            return theme.colors;
        }

        defaultColors = defaultTheme.series.colors.slice(0, legendLabels.length);

        return tui.util.map(tui.util.pluck(legendLabels, 'chartType'), function(chartType) {
            var color;
            if (prevChartType !== chartType) {
                colors = theme[chartType] ? theme[chartType].colors : defaultColors;
                colorIndex = 0;
            }
            prevChartType = chartType;
            color = colors[colorIndex];
            colorIndex += 1;
            return color;
        });
    },

    /**
     * Make rendering data about legend item.
     * @param {Array.<string>} values values
     * @returns {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} legend item data.
     * @private
     */
    _makeItemRenderingData: function(values) {
        return tui.util.map(values, function(value, index) {
            var legendLabel = this.dataProcessor.getLegendData(index);

            return {
                value: value,
                legend: legendLabel.label,
                chartType: legendLabel.chartType,
                suffix: this.suffix
            };
        }, this);
    },

    /**
     * Make tooltip.
     * @param {number} groupIndex group index
     * @returns {string} tooltip html
     * @private
     */
    _makeGroupTooltipHtml: function(groupIndex) {
        var data = this.data[groupIndex],
            items = this._makeItemRenderingData(data.values);

        return this.templateFunc(data.category, items);
    },

    /**
     * Get tooltip sector element.
     * @returns {HTMLElement} sector element
     * @private
     */
    _getTooltipSectorElement: function() {
        var groupTooltipSector;

        if (!this.groupTooltipSector) {
            this.groupTooltipSector = groupTooltipSector = dom.create('DIV', 'tui-chart-group-tooltip-sector');
            dom.append(this.tooltipContainer, groupTooltipSector);
        }

        return this.groupTooltipSector;
    },

    /**
     * Make bound about tooltip sector of vertical type chart.
     * @param {number} height height
     * @param {{start: number, end: number}} range range
     * @param {boolean} isLine whether line or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeVerticalTooltipSectorBound: function(height, range, isLine) {
        var width;

        if (isLine) {
            width = 1;
            height += 6;
        } else {
            width = range.end - range.start;
        }

        return {
            dimension: {
                width: width,
                height: height
            },
            position: {
                left: range.start + chartConst.SERIES_EXPAND_SIZE,
                top: chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector of horizontal type chart.
     * @param {number} width width
     * @param {{start: number, end:number}} range range
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeHorizontalTooltipSectorBound: function(width, range) {
        return {
            dimension: {
                width: width,
                height: range.end - range.start + chartConst.HIDDEN_WIDTH
            },
            position: {
                left: chartConst.SERIES_EXPAND_SIZE - chartConst.HIDDEN_WIDTH,
                top: range.start + chartConst.SERIES_EXPAND_SIZE
            }
        };
    },

    /**
     * Make bound about tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {boolean} isLine whether line type or not
     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
     * @private
     */
    _makeTooltipSectorBound: function(size, range, isVertical, isLine) {
        var bound;

        if (isVertical) {
            bound = this._makeVerticalTooltipSectorBound(size, range, isLine);
        } else {
            bound = this._makeHorizontalTooltipSectorBound(size, range);
        }

        return bound;
    },

    /**
     * Show tooltip sector.
     * @param {number} size width or height
     * @param {{start: number, end:number}} range range
     * @param {boolean} isVertical whether vertical or not
     * @param {number} index index
     * @private
     */
    _showTooltipSector: function(size, range, isVertical, index) {
        var groupTooltipSector = this._getTooltipSectorElement(),
            isLine = (range.start === range.end),
            bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);

        if (isLine) {
            this.fire('showGroupTooltipLine', bound);
        } else {
            renderUtil.renderDimension(groupTooltipSector, bound.dimension);
            renderUtil.renderPosition(groupTooltipSector, bound.position);
            dom.addClass(groupTooltipSector, 'show');
        }

        this.fire('showGroupAnimation', index);
    },

    /**
     * Hide tooltip sector.
     * @param {number} index index
     * @private
     */
    _hideTooltipSector: function(index) {
        var groupTooltipSector = this._getTooltipSectorElement();

        dom.removeClass(groupTooltipSector, 'show');
        this.fire('hideGroupAnimation', index);
        this.fire('hideGroupTooltipLine');
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{index: number, range: {start: number, end: number},
     *          size: number, direction: string, isVertical: boolean
     *        }} params coordinate event parameters
     * @param {{left: number, top: number}} prevPosition prev position
     */
    showTooltip: function(elTooltip, params, prevPosition) {
        var dimension, position;

        if (!tui.util.isUndefined(this.prevIndex)) {
            this.fire('hideGroupAnimation', this.prevIndex);
        }

        elTooltip.innerHTML = this._makeGroupTooltipHtml(params.index);

        this._fireBeforeShowTooltip(params.index, params.range);

        dom.addClass(elTooltip, 'show');

        this._showTooltipSector(params.size, params.range, params.isVertical, params.index);

        dimension = this.getTooltipDimension(elTooltip);
        position = this.positionModel.calculatePosition(dimension, params.range);

        this.moveToPosition(elTooltip, position, prevPosition);

        this._fireAfterShowTooltip(params.index, params.range, {
            element: elTooltip,
            position: position
        });

        this.prevIndex = params.index;
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @private
     */
    _fireBeforeShowTooltip: function(index, range) {
        this.userEvent.fire('beforeShowTooltip', {
            index: index,
            range: range
        });
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {number} index index
     * @param {{start: number, end: number}} range range
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(index, range, additionParams) {
        this.userEvent.fire('afterShowTooltip', tui.util.extend({
            index: index,
            range: range
        }, additionParams));
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {number} index index
     */
    hideTooltip: function(elTooltip, index) {
        delete this.prevIndex;
        this._hideTooltipSector(index);
        dom.removeClass(elTooltip, 'show');
        elTooltip.style.cssText = '';
    }
});

module.exports = GroupTooltip;

},{"../const":19,"../helpers/domHandler":38,"../helpers/renderUtil":42,"../themes/defaultTheme":75,"./groupTooltipPositionModel":77,"./tooltipBase":81,"./tooltipTemplate":82}],77:[function(require,module,exports){
/**
 * @fileoverview GroupTooltipPositionModel is position model for group tooltip..
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const');

var GroupTooltipPositionModel = tui.util.defineClass(/** @lends GroupTooltipPositionModel.prototype */ {
    /**
     * GroupTooltipPositionModel is position model for group tooltip.
     * @constructs GroupTooltipPositionModel
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    init: function(chartDimension, areaBound, isVertical, options) {
        /**
         * chart dimension
         * @type {{width: number, height: number}}
         */
        this.chartDimension = chartDimension;

        /**
         * tooltip area bound
         * @type {{dimension: {width: number, height: number}, position: {left: number, top: number}}}
         */
        this.areaBound = areaBound;

        /**
         * Whether vertical or not
         * @type {boolean}
         */
        this.isVertical = isVertical;

        /**
         * tooltip options
         * @type {{align: ?string, position: {left: number, top: number}}}
         */
        this.options = options;

        /**
         * For caching
         * @type {object}
         */
        this.positions = {};

        this._setData(chartDimension, areaBound, isVertical, options);
    },

    /**
     * Get horizontal direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getHorizontalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';
        if (alignOption.indexOf('left') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('center') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        }

        return direction;
    },

    /**
     * Make vertical data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} vertical data
     * @private
     */
    _makeVerticalData: function(chartDimension, areaBound, alignOption) {
        var hDirection = this._getHorizontalDirection(alignOption);

        return {
            positionType: 'left',
            sizeType: 'width',
            direction: hDirection,
            areaPosition: areaBound.position.left,
            areaSize: areaBound.dimension.width,
            chartSize: chartDimension.width,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Get vertical direction.
     * @param {?string} alignOption align option
     * @returns {string} direction
     * @private
     */
    _getVerticalDirection: function(alignOption) {
        var direction;

        alignOption = alignOption || '';

        if (alignOption.indexOf('top') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_BACKWARD;
        } else if (alignOption.indexOf('bottom') > -1) {
            direction = chartConst.TOOLTIP_DIRECTION_FORWARD;
        } else {
            direction = chartConst.TOOLTIP_DIRECTION_CENTER;
        }

        return direction;
    },

    /**
     * Make horizontal data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {?string} alignOption align option
     * @returns {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} horizontal data
     * @private
     */
    _makeHorizontalData: function(chartDimension, areaBound, alignOption) {
        var vDirection = this._getVerticalDirection(alignOption);

        return {
            positionType: 'top',
            sizeType: 'height',
            direction: vDirection,
            areaPosition: areaBound.position.top,
            areaSize: areaBound.dimension.height,
            chartSize: chartDimension.height,
            basePosition: chartConst.SERIES_EXPAND_SIZE
        };
    },

    /**
     * Set data.
     * @param {{width: number, height: number}} chartDimension chart dimension
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} areaBound tooltip area bound
     * @param {boolean} isVertical whether vertical or not
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     * @private
     */
    _setData: function(chartDimension, areaBound, isVertical, options) {
        var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align),
            horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);

        if (isVertical) {
            this.mainData = verticalData;
            this.subData = horizontalData;
        } else {
            this.mainData = horizontalData;
            this.subData = verticalData;
        }

        this.positionOption = tui.util.extend({
            left: 0,
            top: 0
        }, options.position);

        this.positions = {};
    },

    /**
     * Calculate main position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {{start: number, end: number}} range range
     * @param {object} data data
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateMainPositionValue: function(tooltipSize, range, data) {
        var isLine = (range.start === range.end),
            padding = isLine ? 9 : 5,
            value = data.basePosition;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value += range.end + padding;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value += range.start - tooltipSize - padding;
        } else if (isLine) {
            value += range.start - tooltipSize / 2;
        } else {
            value += range.start + ((range.end - range.start - tooltipSize) / 2);
        }

        return value;
    },

    /**
     * Calculate sub position value.
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.areaSize tooltip area size (width or height)
     *      @param {string} data.direction direction
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _calculateSubPositionValue: function(tooltipSize, data) {
        var middle = data.areaSize / 2,
            value;

        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = middle + data.basePosition;
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = middle - tooltipSize + data.basePosition;
        } else {
            value = middle - (tooltipSize / 2) + data.basePosition;
        }

        return value;
    },

    /**
     * Make position value diff.
     * @param {number} value positoin value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} diff
     * @private
     */
    _makePositionValueDiff: function(value, tooltipSize, data) {
        return value + data.areaPosition + tooltipSize - data.chartSize;
    },

    /**
     * Adjust backward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustBackwardPositionValue: function(value, range, tooltipSize, data) {
        var changedValue;

        if (value < -data.areaPosition) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_FORWARD,
                basePosition: data.basePosition
            });
            if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
                value = -data.areaPosition;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust forward position value.
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustForwardPositionValue: function(value, range, tooltipSize, data) {
        var diff = this._makePositionValueDiff(value, tooltipSize, data),
            changedValue;

        if (diff > 0) {
            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
                direction: chartConst.TOOLTIP_DIRECTION_BACKWARD,
                basePosition: data.basePosition
            });
            if (changedValue < -data.areaPosition) {
                value -= diff;
            } else {
                value = changedValue;
            }
        }

        return value;
    },

    /**
     * Adjust main position value
     * @param {number} value position value
     * @param {{start: number, end: number}} range range
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     * @returns {number} position value
     * @private
     */
    _adjustMainPositionValue: function(value, range, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_BACKWARD) {
            value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
        } else if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
        } else {
            value = tui.util.max([value, -data.areaPosition]);
            value = tui.util.min([value, data.chartSize - data.areaPosition - tooltipSize]);
        }

        return value;
    },

    /**
     * Adjust sub position value.
     * @param {number} value position value
     * @param {number} tooltipSize tooltip size (width or height)
     * @param {object} data data
     *      @param {number} data.chartSize chart size (width or height)
     *      @param {number} data.areaPosition tooltip area position (left or top)
     *      @param {number} data.basePosition basePosition
     * @returns {number} position value
     * @private
     */
    _adjustSubPositionValue: function(value, tooltipSize, data) {
        if (data.direction === chartConst.TOOLTIP_DIRECTION_FORWARD) {
            value = tui.util.min([value, data.chartSize - data.areaPosition - tooltipSize]);
        } else {
            value = tui.util.max([value, -data.areaPosition]);
        }

        return value;
    },

    /**
     * Make caching key.
     * @param {{start: number, end: number}} range range
     * @returns {string} key
     * @private
     */
    _makeCachingKey: function(range) {
        return range.start + '-' + range.end;
    },

    /**
     * Add position option.
     * @param {number} position position
     * @param {string} positionType position type (left or top)
     * @returns {number} position
     * @private
     */
    _addPositionOptionValue: function(position, positionType) {
        return position + this.positionOption[positionType];
    },

    /**
     * Make main position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} main main data
     * @returns {number} position value
     * @private
     */
    _makeMainPositionValue: function(tooltipDimension, range, main) {
        var value;

        value = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
        value = this._addPositionOptionValue(value, main.positionType);
        value = this._adjustMainPositionValue(value, range, tooltipDimension[main.sizeType], main);

        return value;
    },

    /**
     * Make sub position value.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{
     *      positionType: string, sizeType: string, direction: (string),
     *      areaPosition: number, areaSize: number, chartSize: number,
     *      basePosition: (number)
     * }} sub sub data
     * @returns {number} position value
     * @private
     */
    _makeSubPositionValue: function(tooltipDimension, sub) {
        var value;

        value = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);
        value = this._addPositionOptionValue(value, sub.positionType);
        value = this._adjustSubPositionValue(value, tooltipDimension[sub.sizeType], sub);

        return value;
    },

    /**
     * Calculate group tooltip position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{start: number, end: number}} range tooltip sector range
     * @returns {{left: number, top: number}} group tooltip position
     */
    calculatePosition: function(tooltipDimension, range) {
        var key = this._makeCachingKey(range),
            main = this.mainData,
            sub = this.subData,
            position = this.positions[key];

        if (!position) {
            position = {};
            position[main.positionType] = this._makeMainPositionValue(tooltipDimension, range, main);
            position[sub.positionType] = this._makeSubPositionValue(tooltipDimension, sub);
            this.positions[key] = position;
        }

        return position;
    },

    /**
     * Update tooltip options for position calculation.
     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
     */
    updateOptions: function(options) {
        this.options = options;
        this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
    },

    /**
     * Update tooltip bound for position calculation.
     * @param {{
     *      dimension: {width: number, height: number},
     *      position: {left: number, top: number}
     * }} bound tooltip area bound
     */
    updateBound: function(bound) {
        this.areaBound = bound;
        this._setData(this.chartDimension, bound, this.isVertical, this.options);
    }
});

module.exports = GroupTooltipPositionModel;

},{"../const":19}],78:[function(require,module,exports){
/**
 * @fileoverview Tooltip component for map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    TooltipBase = require('./tooltipBase'),
    singleTooltipMixer = require('./singleTooltipMixer'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc MapChartTooltip component.
 * @class MapChartTooltip
 */
var MapChartTooltip = tui.util.defineClass(TooltipBase, /** @lends MapChartTooltip.prototype */ {
    /**
     * Map chart tooltip component.
     * @constructs MapChartTooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        /**
         * Map model
         * @type {MapChartMapModel}
         */
        this.mapModel = null;

        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {{name: string, value: number}} datum tooltip datum
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(datum) {
        return tooltipTemplate.tplMapChartDefault(datum);
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var datum = this.mapModel.getDatum(indexes.index);

        return this.templateFunc({
            name: datum.name || datum.code,
            value: datum.formattedValue
        });
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var datum = this.mapModel.getDatum(indexes.index),
            params;

        params = tui.util.extend({
            chartType: this.chartType,
            code: datum.code,
            name: datum.name,
            value: datum.formattedValue,
            index: indexes.index
        }, additionParams);

        return params;
    },


    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (!this.options.align) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        }
    },

    /**
     * Render.
     * @param {{mapModel: MapChartMapModel}} data data for rendering
     * @returns {HTMLElement} tooltip element
     */
    render: function(data) {
        this.mapModel = data.mapModel;

        return TooltipBase.prototype.render.call(this);
    }
});

singleTooltipMixer.mixin(MapChartTooltip);
module.exports = MapChartTooltip;

},{"../const":19,"./singleTooltipMixer":79,"./tooltipBase":81,"./tooltipTemplate":82}],79:[function(require,module,exports){
/**
 * @fileoverview singleTooltipMixer is single tooltip mixer of map chart.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    predicate = require('../helpers/predicate'),
    dom = require('../helpers/domHandler'),
    renderUtil = require('../helpers/renderUtil');

/**
 * singleTooltipMixer is single tooltip mixer of map chart.
 * @mixin
 */
var singleTooltipMixer = {

    /**
     * Fire custom event showAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireShowAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('show', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Fire custom event hideAnimation.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {string} chartType chart type
     * @private
     */
    _fireHideAnimation: function(indexes, chartType) {
        var eventName = renderUtil.makeCustomEventName('hide', chartType, 'animation');

        this.fire(eventName, indexes);
    },

    /**
     * Set data indexes.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{groupIndex: number, index:number}} indexes indexes
     * @private
     */
    _setIndexesCustomAttribute: function(elTooltip, indexes) {
        elTooltip.setAttribute('data-groupIndex', indexes.groupIndex);
        elTooltip.setAttribute('data-index', indexes.index);
    },

    /**
     * Get data indexes
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {{groupIndex: number, index: number}} indexes
     * @private
     */
    _getIndexesCustomAttribute: function(elTooltip) {
        var groupIndex = elTooltip.getAttribute('data-groupIndex'),
            index = elTooltip.getAttribute('data-index'),
            indexes = null;

        if (!tui.util.isNull(groupIndex) && !tui.util.isNull(index)) {
            indexes = {
                groupIndex: parseInt(groupIndex, 10),
                index: parseInt(index, 10)
            };
        }
        return indexes;
    },

    /**
     * Set showed custom attribute.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {boolean} status whether showed or not
     * @private
     */
    _setShowedCustomAttribute: function(elTooltip, status) {
        elTooltip.setAttribute('data-showed', status);
    },

    /**
     * Whether showed tooltip or not.
     * @param {HTMLElement} elTooltip tooltip element
     * @returns {boolean} whether showed tooltip or not
     * @private
     */
    _isShowedTooltip: function(elTooltip) {
        var isShowed = elTooltip.getAttribute('data-showed');

        return isShowed === 'true' || isShowed === true; // ie7에서는 boolean형태의 true를 반환함
    },

    /**
     * Calculate tooltip position to event position.
     * @param {object} params parameters
     *      @param {{left: number, top: number}} params.bound bound
     *      @param {{left: number, top: number}} params.mousePosition mouse position
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionToMousePosition: function(params) {
        params.bound = params.bound || {};
        tui.util.extend(params.bound, params.mousePosition);
        return this._calculateTooltipPositionAboutNotBarChart(params);
    },

    /**
     * Calculate tooltip position about not bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionAboutNotBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusWidth = params.dimension.width - (bound.width || 0),
            lineGap = bound.width ? 0 : chartConst.TOOLTIP_GAP,
            alignOption = params.alignOption || '',
            tooltipHeight = params.dimension.height,
            result = {};

        result.left = bound.left + positionOption.left;
        result.top = bound.top - tooltipHeight + positionOption.top;

        if (alignOption.indexOf('left') > -1) {
            result.left -= minusWidth + lineGap;
        } else if (alignOption.indexOf('center') > -1) {
            result.left -= minusWidth / 2;
        } else {
            result.left += lineGap;
        }

        if (alignOption.indexOf('bottom') > -1) {
            result.top += tooltipHeight + lineGap;
        } else if (alignOption.indexOf('middle') > -1) {
            result.top += tooltipHeight / 2;
        } else {
            result.top -= chartConst.TOOLTIP_GAP;
        }

        return result;
    },

    /**
     * Calculate tooltip position about bar chart.
     * @param {object} params parameters
     *      @param {{bound: object}} params.data graph information
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPositionAboutBarChart: function(params) {
        var bound = params.bound,
            positionOption = params.positionOption,
            minusHeight = params.dimension.height - (bound.height || 0),
            alignOption = params.alignOption || '',
            tooltipWidth = params.dimension.width,
            result = {};

        result.left = bound.left + bound.width + positionOption.left;
        result.top = bound.top + positionOption.top;

        if (alignOption.indexOf('left') > -1) {
            result.left -= tooltipWidth;
        } else if (alignOption.indexOf('center') > -1) {
            result.left -= tooltipWidth / 2;
        } else {
            result.left += chartConst.TOOLTIP_GAP;
        }

        if (alignOption.indexOf('top') > -1) {
            result.top -= minusHeight;
        } else if (alignOption.indexOf('middle') > -1) {
            result.top -= minusHeight / 2;
        }

        return result;
    },

    /**
     * Adjust position.
     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
     * @param {{left: number, top: number}} position position
     * @returns {{left: number, top: number}} adjusted position
     * @private
     */
    _adjustPosition: function(tooltipDimension, position) {
        var chartDimension = this.boundsMaker.getDimension('chart'),
            areaPosition = this.boundsMaker.getPosition('tooltip');

        position.left = Math.max(position.left, -areaPosition.left);
        position.left = Math.min(position.left, chartDimension.width - areaPosition.left - tooltipDimension.width);
        position.top = Math.max(position.top, -areaPosition.top);
        position.top = Math.min(position.top, chartDimension.height - areaPosition.top - tooltipDimension.height);
        return position;
    },

    /**
     * Calculate tooltip position.
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.chartType chart type
     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.alignOption position option (ex: 'left top')
     * @returns {{top: number, left: number}} position
     * @private
     */
    _calculateTooltipPosition: function(params) {
        var position = {},
            sizeType, positionType, addPadding;

        if (params.mousePosition) {
            position = this._calculateTooltipPositionToMousePosition(params);
        } else {
            if (predicate.isBarChart(params.chartType)) {
                position = this._calculateTooltipPositionAboutBarChart(params);
                sizeType = 'width';
                positionType = 'left';
                addPadding = 1;
            } else {
                position = this._calculateTooltipPositionAboutNotBarChart(params);
                sizeType = 'height';
                positionType = 'top';
                addPadding = -1;
            }

            if (params.allowNegativeTooltip) {
                position = this._moveToSymmetry(position, {
                    bound: params.bound,
                    indexes: params.indexes,
                    dimension: params.dimension,
                    chartType: params.chartType,
                    sizeType: sizeType,
                    positionType: positionType,
                    addPadding: addPadding
                });
            }

            position = this._adjustPosition(params.dimension, position);
        }

        return position;
    },

    /**
     * Move to symmetry.
     * @param {{left: number, top: number}} position tooltip position
     * @param {object} params parameters
     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
     *      @param {string} params.id tooltip id
     *      @param {{width: number, height: number}} params.dimension tooltip dimension
     *      @param {string} params.sizeType size type (width or height)
     *      @param {string} params.positionType position type (left or top)
     *      @param {number} params.addPadding add padding
     * @returns {{left: number, top: number}} moved position
     * @private
     */
    _moveToSymmetry: function(position, params) {
        var bound = params.bound,
            sizeType = params.sizeType,
            positionType = params.positionType,
            value = this.dataProcessor.getValue(params.indexes.groupIndex, params.indexes.index, params.chartType),
            tooltipSizeHalf, barPosition, barSizeHalf, movedPositionValue;

        if (value < 0) {
            tooltipSizeHalf = params.dimension[sizeType] / 2;
            barPosition = bound[positionType];
            barSizeHalf = bound[sizeType] / 2;
            movedPositionValue = (barPosition + barSizeHalf - tooltipSizeHalf) * 2 - position[positionType];
            position[positionType] = movedPositionValue;
        }

        return position;
    },

    /**
     * Whether changed indexes or not.
     * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {boolean} whether changed or not
     * @private
     */
    _isChangedIndexes: function(prevIndexes, indexes) {
        return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
    },

    /**
     * Show tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
     * @param {{left: number, top: number}} prevPosition prev position
     */
    showTooltip: function(elTooltip, params, prevPosition) {
        var indexes = params.indexes,
            prevIndexes = this._getIndexesCustomAttribute(elTooltip),
            prevChartType, position;

        if (this._isChangedIndexes(prevIndexes, indexes)) {
            prevChartType = elTooltip.getAttribute('data-chart-type');
            this._fireHideAnimation(prevIndexes, prevChartType);
        }

        elTooltip.innerHTML = this._makeSingleTooltipHtml(params.chartType, indexes);

        elTooltip.setAttribute('data-chart-type', params.chartType);
        this._setIndexesCustomAttribute(elTooltip, indexes);
        this._setShowedCustomAttribute(elTooltip, true);

        this._fireBeforeShowTooltip(indexes);

        dom.addClass(elTooltip, 'show');

        position = this._calculateTooltipPosition(tui.util.extend({
            dimension: this.getTooltipDimension(elTooltip),
            positionOption: tui.util.extend({
                left: 0,
                top: 0
            }, this.options.position),
            alignOption: this.options.align || ''
        }, params));

        this.moveToPosition(elTooltip, position, prevPosition);
        this._fireShowAnimation(indexes, params.chartType);
        this._fireAfterShowTooltip(indexes, {
            element: elTooltip,
            position: position
        });
    },

    /**
     * To call beforeShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @private
     */
    _fireBeforeShowTooltip: function(indexes) {
        var params = this._makeShowTooltipParams(indexes);

        this.userEvent.fire('beforeShowTooltip', params);
    },

    /**
     * To call afterShowTooltip callback of userEvent.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @private
     */
    _fireAfterShowTooltip: function(indexes, additionParams) {
        var params = this._makeShowTooltipParams(indexes, additionParams);

        this.userEvent.fire('afterShowTooltip', params);
    },

    /**
     * Hide tooltip.
     * @param {HTMLElement} elTooltip tooltip element
     * @param {function} callback callback
     */
    hideTooltip: function(elTooltip) {
        var that = this,
            indexes = this._getIndexesCustomAttribute(elTooltip),
            chartType = elTooltip.getAttribute('data-chart-type');

        if (chartType) {
            this._setShowedCustomAttribute(elTooltip, false);
            this._fireHideAnimation(indexes, chartType);

            if (this._isChangedIndexes(this.prevIndexes, indexes)) {
                delete this.prevIndexes;
            }

            setTimeout(function() {
                if (that._isShowedTooltip(elTooltip)) {
                    return;
                }

                dom.removeClass(elTooltip, 'show');
                elTooltip.style.cssText = '';

                that = null;
                indexes = null;
            }, chartConst.HIDE_DELAY);
        }
    },

    /**
     * On show tooltip container.
     */
    onShowTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = chartConst.TOOLTIP_ZINDEX;
    },

    /**
     * On hide tooltip container.
     */
    onHideTooltipContainer: function() {
        this.tooltipContainer.style.zIndex = 0;
    },

    /**
     * Mix in.
     * @param {function} func target function
     * @ignore
     */
    mixin: function(func) {
        tui.util.extend(func.prototype, this);
    }
};

module.exports = singleTooltipMixer;

},{"../const":19,"../helpers/domHandler":38,"../helpers/predicate":41,"../helpers/renderUtil":42}],80:[function(require,module,exports){
/**
 * @fileoverview Tooltip component.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var TooltipBase = require('./tooltipBase'),
    singleTooltipMixer = require('./singleTooltipMixer'),
    chartConst = require('../const'),
    tooltipTemplate = require('./tooltipTemplate');

/**
 * @classdesc Tooltip component.
 * @class Tooltip
 */
var Tooltip = tui.util.defineClass(TooltipBase, /** @lends Tooltip.prototype */ {
    /**
     * Tooltip component.
     * @constructs Tooltip
     * @param {object} params parameters
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        TooltipBase.call(this, params);
    },

    /**
     * Make tooltip html.
     * @param {string} category category
     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
     * @returns {string} tooltip html
     * @private
     */
    _makeTooltipHtml: function(category, item) {
        return tooltipTemplate.tplDefault(tui.util.extend({
            category: category || ''
        }, item));
    },

    /**
     * Make single tooltip html.
     * @param {string} chartType chart type
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @returns {string} tooltip html
     * @private
     */
    _makeSingleTooltipHtml: function(chartType, indexes) {
        var data = tui.util.pick(this.data, chartType, indexes.groupIndex, indexes.index);
        return this.templateFunc(data.category, {
            value: data.value,
            legend: data.legend,
            suffix: this.suffix
        });
    },

    /**
     * Set default align option of tooltip.
     * @private
     * @override
     */
    _setDefaultTooltipPositionOption: function() {
        if (this.options.align) {
            return;
        }

        if (this.isVertical) {
            this.options.align = chartConst.TOOLTIP_DEFAULT_ALIGN_OPTION;
        } else {
            this.options.align = chartConst.TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
        }
    },

    /**
     * Make parameters for show tooltip user event.
     * @param {{groupIndex: number, index: number}} indexes indexes
     * @param {object} additionParams addition parameters
     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
     * @private
     */
    _makeShowTooltipParams: function(indexes, additionParams) {
        var legendIndex = indexes.index,
            legendData = this.dataProcessor.getLegendData(legendIndex),
            params;

        params = tui.util.extend({
            chartType: legendData.chartType,
            legend: legendData.label,
            legendIndex: legendIndex,
            index: indexes.groupIndex
        }, additionParams);
        return params;
    },

    /**
     * Make tooltip data.
     * @returns {Array.<object>} tooltip data
     * @override
     */
    _makeTooltipData: function() {
        var categories = this.dataProcessor.getCategories(),
            orgFormattedValues = this.dataProcessor.getFormattedGroupValues(),
            orgLegendLabels = this.dataProcessor.getLegendLabels(),
            formattedValues = {},
            legendLabels = {},
            tooltipData = {};

        if (tui.util.isArray(orgFormattedValues)) {
            formattedValues[this.chartType] = orgFormattedValues;
            legendLabels[this.chartType] = orgLegendLabels;
        } else {
            formattedValues = orgFormattedValues;
            legendLabels = orgLegendLabels;
        }

        tui.util.forEach(formattedValues, function(groupValues, chartType) {
            tooltipData[chartType] = tui.util.map(groupValues, function(values, groupIndex) {
                return tui.util.map(values, function(value, index) {
                    return {
                        category: categories ? categories[groupIndex] : '',
                        legend: legendLabels[chartType][index],
                        value: value
                    };
                });
            });
        });

        return tooltipData;
    }
});

singleTooltipMixer.mixin(Tooltip);
module.exports = Tooltip;

},{"../const":19,"./singleTooltipMixer":79,"./tooltipBase":81,"./tooltipTemplate":82}],81:[function(require,module,exports){
/**
 * @fileoverview TooltipBase is base class of tooltip components.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var chartConst = require('../const'),
    dom = require('../helpers/domHandler'),
    predicate = require('../helpers/predicate'),
    renderUtil = require('../helpers/renderUtil');

var TooltipBase = tui.util.defineClass(/** @lends TooltipBase.prototype */ {
    /**
     * TooltipBase is base class of tooltip components.
     * @constructs TooltipBase
     * @param {object} params parameters
     *      @param {Array.<number>} params.values converted values
     *      @param {BoundsMaker} params.boundsMaker bounds maker
     *      @param {object} params.theme axis theme
     */
    init: function(params) {
        tui.util.extend(this, params);
        /**
         * className
         * @type {string}
         */
        this.className = 'tui-chart-tooltip-area';

        /**
         * Tooltip container.
         * @type {HTMLElement}
         */
        this.tooltipContainer = null;

        /**
         * Tooltip suffix.
         * @type {string}
         */
        this.suffix = this.options.suffix ? '&nbsp;' + this.options.suffix : '';

        /**
         * Tooltip template function.
         * @type {function}
         */
        this.templateFunc = this.options.template || tui.util.bind(this._makeTooltipHtml, this);

        /**
         * Tooltip animation time.
         * @type {number}
         */
        this.animationTime = predicate.isPieChart(params.chartType) ? chartConst.TOOLTIP_PIE_ANIMATION_TIME : chartConst.TOOLTIP_ANIMATION_TIME;

        /**
         * TooltipBase base data.
         * @type {Array.<Array.<object>>}
         */
        this.data = [];

        this._setDefaultTooltipPositionOption();
        this._saveOriginalPositionOptions();
    },

    /**
     * Make tooltip html.
     * @private
     * @abstract
     */
    _makeTooltipHtml: function() {},

    /**
     * Set default align option of tooltip.
     * @private
     * @abstract
     */
    _setDefaultTooltipPositionOption: function() {},

    /**
     * Save position options.
     * @private
     */
    _saveOriginalPositionOptions: function() {
        this.orgPositionOptions = {
            align: this.options.align,
            position: this.options.position
        };
    },

    /**
     * Make tooltip data.
     * @private
     * @abstract
     */
    _makeTooltipData: function() {},

    /**
     * Render tooltip component.
     * @returns {HTMLElement} tooltip element
     */
    render: function() {
        var el = dom.create('DIV', this.className);

        this.data = this._makeTooltipData();

        renderUtil.renderPosition(el, this.boundsMaker.getPosition('tooltip'));

        this.tooltipContainer = el;

        return el;
    },

    /**
     * Rerender.
     */
    rerender: function() {
        this.data = this._makeTooltipData();
        if (this.positionModel) {
            this.positionModel.updateBound(this.boundsMaker.getBound('tooltip'));
        }
    },

    /**
     * Resize tooltip component.
     * @override
     */
    resize: function() {
        renderUtil.renderPosition(this.tooltipContainer, this.boundsMaker.getPosition('tooltip'));
        if (this.positionModel) {
            this.positionModel.updateBound(this.boundsMaker.getBound('tooltip'));
        }
    },

    /**
     * Get tooltip element.
     * @returns {HTMLElement} tooltip element
     * @private
     */
    _getTooltipElement: function() {
        var tooltipElement;

        if (!this.tooltipElement) {
            this.tooltipElement = tooltipElement = dom.create('DIV', 'tui-chart-tooltip');
            dom.append(this.tooltipContainer, tooltipElement);
        }

        return this.tooltipElement;
    },

    /**
     * onShow is callback of custom event showTooltip for SeriesView.
     * @param {object} params coordinate event parameters
     */
    onShow: function(params) {
        var tooltipElement = this._getTooltipElement(),
            prevPosition;

        if (!predicate.isMousePositionChart(params.chartType) && tooltipElement.offsetWidth) {
            prevPosition = {
                left: tooltipElement.offsetLeft,
                top: tooltipElement.offsetTop
            };
        }

        this.showTooltip(tooltipElement, params, prevPosition);
    },

    /**
     * Get tooltip dimension
     * @param {HTMLElement} tooltipElement tooltip element
     * @returns {{width: number, height: number}} rendered tooltip dimension
     */
    getTooltipDimension: function(tooltipElement) {
        return {
            width: tooltipElement.offsetWidth,
            height: tooltipElement.offsetHeight
        };
    },

    /**
     * Move to Position.
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} position position
     * @param {{left: number, top: number}} prevPosition prev position
     */
    moveToPosition: function(tooltipElement, position, prevPosition) {
        if (prevPosition) {
            this._slideTooltip(tooltipElement, prevPosition, position);
        } else {
            renderUtil.renderPosition(tooltipElement, position);
        }
    },

    /**
     * Slide tooltip
     * @param {HTMLElement} tooltipElement tooltip element
     * @param {{left: number, top: number}} prevPosition prev position
     * @param {{left: number, top: number}} position position
     * @private
     */
    _slideTooltip: function(tooltipElement, prevPosition, position) {
        var moveTop = position.top - prevPosition.top,
            moveLeft = position.left - prevPosition.left;

        renderUtil.cancelAnimation(this.slidingAnimation);

        this.slidingAnimation = renderUtil.startAnimation(this.animationTime, function(ratio) {
            var left = moveLeft * ratio,
                top = moveTop * ratio;
            tooltipElement.style.left = (prevPosition.left + left) + 'px';
            tooltipElement.style.top = (prevPosition.top + top) + 'px';
        });
    },

    /**
     * onHide is callback of custom event hideTooltip for SeriesView
     * @param {number} index index
     */
    onHide: function(index) {
        var tooltipElement = this._getTooltipElement();

        this.hideTooltip(tooltipElement, index);
    },

    /**
     * Set tooltip align option.
     * @param {string} align align
     */
    setAlign: function(align) {
        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Set position option.
     * @param {{left: number, top: number}} position moving position
     */
    setPosition: function(position) {
        this.options.position = tui.util.extend({}, this.options.position, position);
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip align option.
     */
    resetAlign: function() {
        var align = this.orgPositionOptions.align;

        this.options.align = align;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    },

    /**
     * Reset tooltip position.
     */
    resetPosition: function() {
        var position = this.orgPositionOptions.position;

        this.options.position = position;
        if (this.positionModel) {
            this.positionModel.updateOptions(this.options);
        }
    }
});

tui.util.CustomEvents.mixin(TooltipBase);

module.exports = TooltipBase;

},{"../const":19,"../helpers/domHandler":38,"../helpers/predicate":41,"../helpers/renderUtil":42}],82:[function(require,module,exports){
/**
 * @fileoverview This is templates of tooltip.
 * @author NHN Ent.
 *         FE Development Team <dl_javascript@nhnent.com>
 */

'use strict';

var templateMaker = require('../helpers/templateMaker');

var htmls = {
    HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ category }}</div>' +
        '<div>' +
            '<span>{{ legend }}</span>:' +
            '&nbsp;<span>{{ value }}</span>' +
            '<span>{{ suffix }}</span>' +
        '</div>' +
    '</div>',
    HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">' +
        '<div>{{ category }}</div>' +
        '{{ items }}' +
    '</div>',
    HTML_GROUP_ITEM: '<div>' +
        '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>&nbsp;<span>{{ legend }}</span>:' +
        '&nbsp;<span>{{ value }}</span>' +
        '<span>{{ suffix }}</span>' +
    '</div>',
    GROUP_CSS_TEXT: 'background-color:{{ color }}',
    HTML_MAP_CHART_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' +
        '<div>{{ name }}: {{ value }}</div>' +
    '</div>'
};

module.exports = {
    tplDefault: templateMaker.template(htmls.HTML_DEFAULT_TEMPLATE),
    tplGroup: templateMaker.template(htmls.HTML_GROUP),
    tplGroupItem: templateMaker.template(htmls.HTML_GROUP_ITEM),
    tplGroupCssText: templateMaker.template(htmls.GROUP_CSS_TEXT),
    tplMapChartDefault: templateMaker.template(htmls.HTML_MAP_CHART_DEFAULT_TEMPLATE)
};

},{"../helpers/templateMaker":43}]},{},[3,52])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXhlcy9heGlzLmpzIiwic3JjL2pzL2F4ZXMvYXhpc1RlbXBsYXRlLmpzIiwic3JjL2pzL2NoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9hcmVhQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2F4aXNUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2JhckNoYXJ0LmpzIiwic3JjL2pzL2NoYXJ0cy9iYXJUeXBlTWl4ZXIuanMiLCJzcmMvanMvY2hhcnRzL2NoYXJ0QmFzZS5qcyIsInNyYy9qcy9jaGFydHMvY29sdW1uQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2NvbWJvQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL2NvbXBvbmVudE1hbmFnZXIuanMiLCJzcmMvanMvY2hhcnRzL2xpbmVDaGFydC5qcyIsInNyYy9qcy9jaGFydHMvbGluZVR5cGVNaXhlci5qcyIsInNyYy9qcy9jaGFydHMvbWFwQ2hhcnQuanMiLCJzcmMvanMvY2hhcnRzL21hcENoYXJ0Q29sb3JNb2RlbC5qcyIsInNyYy9qcy9jaGFydHMvbWFwQ2hhcnRNYXBNb2RlbC5qcyIsInNyYy9qcy9jaGFydHMvcGllQ2hhcnQuanMiLCJzcmMvanMvY29kZS1zbmlwcGV0LXV0aWwuanMiLCJzcmMvanMvY29uc3QuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2FyZWFUeXBlQ3VzdG9tRXZlbnQuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2FyZWFUeXBlRGF0YU1vZGVsLmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9jdXN0b21FdmVudEJhc2UuanMiLCJzcmMvanMvY3VzdG9tRXZlbnRzL2dyb3VwVHlwZUN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9tYXBDaGFydEN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9waWVDaGFydEN1c3RvbUV2ZW50LmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy9wb2ludFR5cGVDdXN0b21FdmVudC5qcyIsInNyYy9qcy9jdXN0b21FdmVudHMvcG9pbnRUeXBlRGF0YU1vZGVsLmpzIiwic3JjL2pzL2N1c3RvbUV2ZW50cy90aWNrQmFzZURhdGFNb2RlbC5qcyIsInNyYy9qcy9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9tYXBGYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy9wbHVnaW5GYWN0b3J5LmpzIiwic3JjL2pzL2ZhY3Rvcmllcy90aGVtZUZhY3RvcnkuanMiLCJzcmMvanMvaGVscGVycy9heGlzRGF0YU1ha2VyLmpzIiwic3JjL2pzL2hlbHBlcnMvYm91bmRzTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy9jYWxjdWxhdG9yLmpzIiwic3JjL2pzL2hlbHBlcnMvY29sb3J1dGlsLmpzIiwic3JjL2pzL2hlbHBlcnMvZGF0YVByb2Nlc3Nvci5qcyIsInNyYy9qcy9oZWxwZXJzL2RvbUhhbmRsZXIuanMiLCJzcmMvanMvaGVscGVycy9ldmVudExpc3RlbmVyLmpzIiwic3JjL2pzL2hlbHBlcnMvbWFwQ2hhcnREYXRhUHJvY2Vzc29yLmpzIiwic3JjL2pzL2hlbHBlcnMvcHJlZGljYXRlLmpzIiwic3JjL2pzL2hlbHBlcnMvcmVuZGVyVXRpbC5qcyIsInNyYy9qcy9oZWxwZXJzL3RlbXBsYXRlTWFrZXIuanMiLCJzcmMvanMvaGVscGVycy91c2VyRXZlbnRMaXN0ZW5lci5qcyIsInNyYy9qcy9sZWdlbmRzL2xlZ2VuZC5qcyIsInNyYy9qcy9sZWdlbmRzL2xlZ2VuZERpbWVuc2lvbk1vZGVsLmpzIiwic3JjL2pzL2xlZ2VuZHMvbGVnZW5kTW9kZWwuanMiLCJzcmMvanMvbGVnZW5kcy9sZWdlbmRUZW1wbGF0ZS5qcyIsInNyYy9qcy9sZWdlbmRzL21hcENoYXJ0TGVnZW5kLmpzIiwic3JjL2pzL3Bsb3RzL3Bsb3QuanMiLCJzcmMvanMvcGxvdHMvcGxvdFRlbXBsYXRlLmpzIiwic3JjL2pzL3BsdWdpbnMvcGx1Z2luUmFwaGFlbC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxBcmVhQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsQmFyQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsTGluZUNoYXJ0LmpzIiwic3JjL2pzL3BsdWdpbnMvcmFwaGFlbExpbmVUeXBlQmFzZS5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxNYXBDaGFydC5qcyIsInNyYy9qcy9wbHVnaW5zL3JhcGhhZWxNYXBMZWdlbmQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsUGllQ2hhcnQuanMiLCJzcmMvanMvcGx1Z2lucy9yYXBoYWVsUmVuZGVyVXRpbC5qcyIsInNyYy9qcy9wb2x5ZmlsbC5qcyIsInNyYy9qcy9yZWdpc3RlckNoYXJ0cy5qcyIsInNyYy9qcy9yZWdpc3RlclRoZW1lcy5qcyIsInNyYy9qcy9zZXJpZXMvYXJlYUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9iYXJDaGFydFNlcmllcy5qcyIsInNyYy9qcy9zZXJpZXMvYmFyVHlwZVNlcmllc0Jhc2UuanMiLCJzcmMvanMvc2VyaWVzL2NvbHVtbkNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9saW5lQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL2xpbmVUeXBlU2VyaWVzQmFzZS5qcyIsInNyYy9qcy9zZXJpZXMvbWFwQ2hhcnRTZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3BpZUNoYXJ0U2VyaWVzLmpzIiwic3JjL2pzL3Nlcmllcy9zZXJpZXMuanMiLCJzcmMvanMvc2VyaWVzL3Nlcmllc1RlbXBsYXRlLmpzIiwic3JjL2pzL3Nlcmllcy96b29tLmpzIiwic3JjL2pzL3RoZW1lcy9kZWZhdWx0VGhlbWUuanMiLCJzcmMvanMvdG9vbHRpcHMvZ3JvdXBUb29sdGlwLmpzIiwic3JjL2pzL3Rvb2x0aXBzL2dyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwuanMiLCJzcmMvanMvdG9vbHRpcHMvbWFwQ2hhcnRUb29sdGlwLmpzIiwic3JjL2pzL3Rvb2x0aXBzL3NpbmdsZVRvb2x0aXBNaXhlci5qcyIsInNyYy9qcy90b29sdGlwcy90b29sdGlwLmpzIiwic3JjL2pzL3Rvb2x0aXBzL3Rvb2x0aXBCYXNlLmpzIiwic3JjL2pzL3Rvb2x0aXBzL3Rvb2x0aXBUZW1wbGF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgIEF4aXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsY3VsYXRvcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBheGlzVGVtcGxhdGUgPSByZXF1aXJlKCcuL2F4aXNUZW1wbGF0ZScpO1xuXG52YXIgQXhpcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgQXhpcy5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEF4aXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIEF4aXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e1xuICAgICAqICAgICAgICAgIGxhYmVsczogQXJyYXkuPHN0cmluZz4sXG4gICAgICogICAgICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICAgICAgaXNMYWJlbEF4aXM6IGJvb2xlYW4sXG4gICAgICogICAgICAgICAgaXNWZXJ0aWNhbDogYm9vbGVhblxuICAgICAqICAgICAgfX0gcGFyYW1zLmRhdGEgYXhpcyBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgcGFyYW1zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF4aXMgdmlldyBjbGFzc05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC1heGlzLWFyZWEnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGhlaWdodCBvZiB4IGF4aXMgYXJlYS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWEF4aXNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICB0aXRsZUFyZWFIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoaXMudGhlbWUudGl0bGUpICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HLFxuICAgICAgICAgICAgaGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGNoYXJ0Q29uc3QuTUFYX0hFSUdIVF9XT1JMRCwgdGhpcy50aGVtZS5sYWJlbCkgKyB0aXRsZUFyZWFIZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugd2lkdGggb2YgeSBheGlzIGFyZWEuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlBeGlzV2lkdGg6IGZ1bmN0aW9uKGxhYmVscykge1xuICAgICAgICB2YXIgdGl0bGUgPSB0aGlzLm9wdGlvbnMudGl0bGUgfHwgJycsXG4gICAgICAgICAgICB0aXRsZUFyZWFXaWR0aCwgd2lkdGg7XG5cbiAgICAgICAgdGl0bGVBcmVhV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoaXMudGhlbWUudGl0bGUpICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HO1xuICAgICAgICB3aWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aChsYWJlbHMsIHRoaXMudGhlbWUubGFiZWwpICsgdGl0bGVBcmVhV2lkdGggKyBjaGFydENvbnN0LkFYSVNfTEFCRUxfUEFERElORztcblxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdmFsaWQgYXhpcyBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdmFsaWQgYXhpcyBvciBub3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNWYWxpZEF4aXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNJbnZhbGlkID0gdHJ1ZSxcbiAgICAgICAgICAgIGdyb3VwVmFsdWVzO1xuXG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdyaWdodFlBeGlzJykge1xuICAgICAgICAgICAgZ3JvdXBWYWx1ZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0R3JvdXBWYWx1ZXMoKTtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goZ3JvdXBWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzSW52YWxpZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbGVnZW5kIGRpbWVuc2lvbiB0byBib3VuZHNNYWtlci5cbiAgICAgKi9cbiAgICByZWdpc3RlckRpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5faXNWYWxpZEF4aXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50VHlwZSA9PT0gJ3hBeGlzJykge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbi5oZWlnaHQgPSB0aGlzLl9tYWtlWEF4aXNIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kc01ha2VyLnJlZ2lzdGVyQmFzZURpbWVuc2lvbih0aGlzLm5hbWUsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMYWJlbCkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbi53aWR0aCA9IHRoaXMuX21ha2VZQXhpc1dpZHRoKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKHRoaXMubmFtZSwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBsZWdlbmQgYWRkaXRpb25hbCBkaW1lbnNpb24gdG8gYm91bmRzTWFrZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJBZGRpdGlvbmFsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbixcbiAgICAgICAgICAgIGF4ZXNEYXRhID0gdGhpcy5ib3VuZHNNYWtlci5heGVzRGF0YTtcblxuICAgICAgICBpZiAodGhpcy5faXNWYWxpZEF4aXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50VHlwZSA9PT0gJ3lBeGlzJyAmJiAhdGhpcy5pc0xhYmVsKSB7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fbWFrZVlBeGlzV2lkdGgoYXhlc0RhdGEueUF4aXMubGFiZWxzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJhc2VEaW1lbnNpb24odGhpcy5uYW1lLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBheGlzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYXhpc0NvbnRhaW5lciBheGlzIGFyZWEgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2lzVmVydGljYWw6IGJvb2xlYW4sIGlzUG9zaXRpb25SaWdodDogYm9vbGVhbiwgYWxpZ25lZDogYWxpZ25lZH19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBeGlzQXJlYTogZnVuY3Rpb24oYXhpc0NvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbCA9ICEhZGF0YS5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0ID0gISFkYXRhLmlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbih0aGlzLm5hbWUpLFxuICAgICAgICAgICAgc2l6ZSA9IGlzVmVydGljYWwgPyBkaW1lbnNpb24uaGVpZ2h0IDogZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgZWxUaXRsZUFyZWEgPSB0aGlzLl9yZW5kZXJUaXRsZUFyZWEoe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBvcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZS50aXRsZSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiBpc1ZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIGlzUG9zaXRpb25SaWdodDogaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZWxMYWJlbEFyZWEgPSB0aGlzLl9yZW5kZXJMYWJlbEFyZWEoZGF0YSwgc2l6ZSwgZGltZW5zaW9uLndpZHRoKSxcbiAgICAgICAgICAgIGVsVGlja0FyZWE7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICBpZiAoIWlzVmVydGljYWwgfHwgIWRhdGEuYWxpZ25lZCkge1xuICAgICAgICAgICAgZWxUaWNrQXJlYSA9IHRoaXMuX3JlbmRlclRpY2tBcmVhKHNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oYXhpc0NvbnRhaW5lciwgZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihheGlzQ29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKHRoaXMubmFtZSkpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXhpc0NvbnRhaW5lciwgaXNWZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcpO1xuICAgICAgICBkb20uYWRkQ2xhc3MoYXhpc0NvbnRhaW5lciwgaXNQb3NpdGlvblJpZ2h0ID8gJ3JpZ2h0JyA6ICcnKTtcbiAgICAgICAgZG9tLmFwcGVuZChheGlzQ29udGFpbmVyLCBbZWxUaXRsZUFyZWEsIGVsVGlja0FyZWEsIGVsTGFiZWxBcmVhXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBheGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge3tpc1ZlcnRpY2FsOiBib29sZWFuLCBpc1Bvc2l0aW9uUmlnaHQ6IGJvb2xlYW4sIGFsaWduZWQ6IGFsaWduZWR9fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBheGlzIGFyZWEgYmFzZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJBeGlzQXJlYShlbCwgZGF0YSk7XG4gICAgICAgIHRoaXMuYXhpc0NvbnRhaW5lciA9IGVsO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcmVuZGVyIGF4aXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5heGlzQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkQXhpcygpKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gZGF0YS5vcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQXhpc0FyZWEodGhpcy5heGlzQ29udGFpbmVyLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgYXhpcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmQgYXhpcyBib3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihib3VuZCwgZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGJvdW5kLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNzcyBzdHlsZSBvZiB0aXRsZSBhcmVhXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUaXRsZUFyZWEgdGl0bGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bvc2l0aW9uUmlnaHQgd2hldGhlciByaWdodCBwb3NpdGlvbiBvciBub3Q/XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGl0bGVBcmVhU3R5bGU6IGZ1bmN0aW9uKGVsVGl0bGVBcmVhLCBzaXplLCBpc1Bvc2l0aW9uUmlnaHQpIHtcbiAgICAgICAgdmFyIGNzc1RleHRzID0gW1xuICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIoJ3dpZHRoOicsIHNpemUsICdweCcpXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGlzUG9zaXRpb25SaWdodCkge1xuICAgICAgICAgICAgaWYgKHJlbmRlclV0aWwuaXNJRTcoKSkge1xuICAgICAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ3JpZ2h0OicsICcwcHgnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ3JpZ2h0OicsIC1zaXplLCAncHgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKCd0b3A6MHB4Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKCdsZWZ0OjBweCcpO1xuICAgICAgICAgICAgaWYgKCFyZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cigndG9wOicsIHNpemUsICdweCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsVGl0bGVBcmVhLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzVGV4dHMuam9pbignOycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaXRsZSBhcmVhIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnRpdGxlIGF4aXMgdGl0bGVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgdGl0bGUgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLmlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3Q/XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1Bvc2l0aW9uUmlnaHQgd2hldGhlciByaWdodCBwb3NpdGlvbiBvciBub3Q/XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpdGxlIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaXRsZUFyZWE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgZWxUaXRsZUFyZWEgPSByZW5kZXJVdGlsLnJlbmRlclRpdGxlKHBhcmFtcy50aXRsZSwgcGFyYW1zLnRoZW1lLCAndHVpLWNoYXJ0LXRpdGxlLWFyZWEnKTtcblxuICAgICAgICBpZiAoZWxUaXRsZUFyZWEgJiYgcGFyYW1zLmlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRpdGxlQXJlYVN0eWxlKGVsVGl0bGVBcmVhLCBwYXJhbXMuc2l6ZSwgcGFyYW1zLmlzUG9zaXRpb25SaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxUaXRsZUFyZWE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZG5lciB0aWNrIGFyZWEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgc2l6ZSBvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpY2sgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVGlja0FyZWE6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0aWNrQ291bnQgPSBkYXRhLnRpY2tDb3VudCxcbiAgICAgICAgICAgIHRpY2tDb2xvciA9IHRoaXMudGhlbWUudGlja0NvbG9yLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHNpemUsIHRpY2tDb3VudCksXG4gICAgICAgICAgICBlbFRpY2tBcmVhID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC10aWNrLWFyZWEnKSxcbiAgICAgICAgICAgIHBvc1R5cGUgPSBkYXRhLmlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIHZlcnRpY2FsQm9yZGVyQ29sb3JUeXBlID0gZGF0YS5pc1Bvc2l0aW9uUmlnaHQgPyAnYm9yZGVyTGVmdENvbG9yJyA6ICdib3JkZXJSaWdodENvbG9yJyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yVHlwZSA9IGRhdGEuaXNWZXJ0aWNhbCA/IHZlcnRpY2FsQm9yZGVyQ29sb3JUeXBlIDogJ2JvcmRlclRvcENvbG9yJyxcbiAgICAgICAgICAgIHRlbXBsYXRlID0gYXhpc1RlbXBsYXRlLnRwbEF4aXNUaWNrLFxuICAgICAgICAgICAgdGlja3NIdG1sID0gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzc1RleHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuYWxpZ25lZCAmJiBkYXRhLmxhYmVsc1tpbmRleF0gPT09IGNoYXJ0Q29uc3QuRU1QVFlfQVhJU19MQUJFTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNzc1RleHQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKCdiYWNrZ3JvdW5kLWNvbG9yOicsIHRpY2tDb2xvciksXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBvc1R5cGUsICc6ICcsIHBvc2l0aW9uLCAncHgnKVxuICAgICAgICAgICAgICAgIF0uam9pbignOycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7Y3NzVGV4dDogY3NzVGV4dH0pO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgZWxUaWNrQXJlYS5pbm5lckhUTUwgPSB0aWNrc0h0bWw7XG4gICAgICAgIGVsVGlja0FyZWEuc3R5bGVbYm9yZGVyQ29sb3JUeXBlXSA9IHRpY2tDb2xvcjtcblxuICAgICAgICByZXR1cm4gZWxUaWNrQXJlYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IG9mIHZlcnRpY2FsIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBheGlzV2lkdGggYXhpcyB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aXRsZUFyZWFXaWR0aCB0aXRsZSBhcmVhIHdpZHRoXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3NzVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWZXJ0aWNhbExhYmVsQ3NzVGV4dDogZnVuY3Rpb24oYXhpc1dpZHRoLCB0aXRsZUFyZWFXaWR0aCkge1xuICAgICAgICByZXR1cm4gJzt3aWR0aDonICsgKGF4aXNXaWR0aCAtIHRpdGxlQXJlYVdpZHRoICsgY2hhcnRDb25zdC5WX0xBQkVMX1JJR0hUX1BBRERJTkcpICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxhYmVsIGFyZWEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBsYWJlbCBhcmVhIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXhpc1dpZHRoIGF4aXMgYXJlYSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGFiZWxBcmVhOiBmdW5jdGlvbihkYXRhLCBzaXplLCBheGlzV2lkdGgpIHtcbiAgICAgICAgdmFyIHRpY2tQaXhlbFBvc2l0aW9ucyA9IGNhbGN1bGF0b3IubWFrZVRpY2tQaXhlbFBvc2l0aW9ucyhzaXplLCBkYXRhLnRpY2tDb3VudCksXG4gICAgICAgICAgICBsYWJlbFNpemUgPSB0aWNrUGl4ZWxQb3NpdGlvbnNbMV0gLSB0aWNrUGl4ZWxQb3NpdGlvbnNbMF0sXG4gICAgICAgICAgICBwb3NUeXBlID0gJ2xlZnQnLFxuICAgICAgICAgICAgY3NzVGV4dHMgPSB0aGlzLl9tYWtlTGFiZWxDc3NUZXh0cyh7XG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogZGF0YS5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgICAgIGlzTGFiZWxBeGlzOiBkYXRhLmlzTGFiZWxBeGlzLFxuICAgICAgICAgICAgICAgIGxhYmVsU2l6ZTogbGFiZWxTaXplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVsTGFiZWxBcmVhID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1sYWJlbC1hcmVhJyksXG4gICAgICAgICAgICBhcmVhQ3NzVGV4dCA9IHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IGRhdGEubGFiZWxzLFxuICAgICAgICAgICAgbGFiZWxzSHRtbCwgdGl0bGVBcmVhV2lkdGg7XG5cbiAgICAgICAgaWYgKGRhdGEuaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgcG9zVHlwZSA9IGRhdGEuaXNMYWJlbEF4aXMgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgICAgICAgdGl0bGVBcmVhV2lkdGggPSB0aGlzLl9nZXRSZW5kZXJlZFRpdGxlSGVpZ2h0KCkgKyBjaGFydENvbnN0LlRJVExFX0FSRUFfV0lEVEhfUEFERElORztcbiAgICAgICAgICAgIGFyZWFDc3NUZXh0ICs9IHRoaXMuX21ha2VWZXJ0aWNhbExhYmVsQ3NzVGV4dChheGlzV2lkdGgsIHRpdGxlQXJlYVdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmlzTGFiZWxBeGlzICYmIHRoaXMub3B0aW9ucy5yb3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TXVsdGlsaW5lQ2F0ZWdvcmllcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlja1BpeGVsUG9zaXRpb25zLmxlbmd0aCA9IGNhdGVnb3JpZXMubGVuZ3RoO1xuICAgICAgICBsYWJlbHNIdG1sID0gdGhpcy5fbWFrZUxhYmVsc0h0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiB0aWNrUGl4ZWxQb3NpdGlvbnMsXG4gICAgICAgICAgICBsYWJlbHM6IGNhdGVnb3JpZXMsXG4gICAgICAgICAgICBwb3NUeXBlOiBwb3NUeXBlLFxuICAgICAgICAgICAgY3NzVGV4dHM6IGNzc1RleHRzLFxuICAgICAgICAgICAgbGFiZWxTaXplOiBsYWJlbFNpemUsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZS5sYWJlbFxuICAgICAgICB9KTtcblxuICAgICAgICBlbExhYmVsQXJlYS5pbm5lckhUTUwgPSBsYWJlbHNIdG1sO1xuICAgICAgICBlbExhYmVsQXJlYS5zdHlsZS5jc3NUZXh0ID0gYXJlYUNzc1RleHQ7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlTGFiZWxBcmVhUG9zaXRpb24oe1xuICAgICAgICAgICAgZWxMYWJlbEFyZWE6IGVsTGFiZWxBcmVhLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogZGF0YS5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgaXNMYWJlbEF4aXM6IGRhdGEuaXNMYWJlbEF4aXMsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZS5sYWJlbCxcbiAgICAgICAgICAgIGxhYmVsU2l6ZTogbGFiZWxTaXplLFxuICAgICAgICAgICAgYWxpZ25lZDogZGF0YS5hbGlnbmVkXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbExhYmVsQXJlYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhlaWdodCBvZiB0aXRsZSBhcmVhIDtcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZFRpdGxlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLnRpdGxlLFxuICAgICAgICAgICAgcmVzdWx0ID0gdGl0bGUgPyByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQodGl0bGUsIHRoZW1lKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0cyBvZiBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlclxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNMYWJlbEF4aXMgd2hldGhlciBsYWJlbCBheGlzIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbFNpemUgbGFiZWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gY3NzVGV4dHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxDc3NUZXh0czogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBjc3NUZXh0cyA9IFtdO1xuXG4gICAgICAgIGlmIChwYXJhbXMuaXNWZXJ0aWNhbCAmJiBwYXJhbXMuaXNMYWJlbEF4aXMpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2gocmVuZGVyVXRpbC5jb25jYXRTdHIoJ2hlaWdodDonLCBwYXJhbXMubGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCdsaW5lLWhlaWdodDonLCBwYXJhbXMubGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmFtcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHJlbmRlclV0aWwuY29uY2F0U3RyKCd3aWR0aDonLCBwYXJhbXMubGFiZWxTaXplLCAncHgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3RhdGlvbiBtb3ZpbmcgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmRlZ3JlZSByb3RhdGlvbiBkZWdyZWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxlZnQgbm9ybWFsIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubW92ZUxlZnQgbW92ZSBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnRvcCB0b3BcbiAgICAgKiBAcmV0dXJucyB7e3RvcDpudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlUm90YXRpb25Nb3ZpbmdQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBtb3ZlTGVmdCA9IHBhcmFtcy5tb3ZlTGVmdDtcblxuICAgICAgICBpZiAocGFyYW1zLmRlZ3JlZSA9PT0gY2hhcnRDb25zdC5BTkdMRV84NSkge1xuICAgICAgICAgICAgbW92ZUxlZnQgKz0gY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gcGFyYW1zLmRlZ3JlZSwgcGFyYW1zLmxhYmVsSGVpZ2h0IC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwYXJhbXMudG9wLFxuICAgICAgICAgICAgbGVmdDogcGFyYW1zLmxlZnQgLSBtb3ZlTGVmdFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgcm90YXRpb24gbW92aW5nIHBvc2l0aW9uIGZvciBpZTguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmRlZ3JlZSByb3RhdGlvbiBkZWdyZWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxXaWR0aCBsYWJlbCB3aWR0aFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGVmdCBub3JtYWwgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyKX0gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7e3RvcDpudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlUm90YXRpb25Nb3ZpbmdQb3NpdGlvbkZvcklFODogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgocGFyYW1zLmxhYmVsLCBwYXJhbXMudGhlbWUpLFxuICAgICAgICAgICAgc21hbGxBcmVhV2lkdGggPSBjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGNoYXJ0Q29uc3QuQU5HTEVfOTAgLSBwYXJhbXMuZGVncmVlLCBwYXJhbXMubGFiZWxIZWlnaHQgLyAyKSxcbiAgICAgICAgICAgIG5ld0xhYmVsV2lkdGggPSAoY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChwYXJhbXMuZGVncmVlLCBsYWJlbFdpZHRoIC8gMikgKyBzbWFsbEFyZWFXaWR0aCkgKiAyLFxuICAgICAgICAgICAgY29sbGVjdExlZnQgPSBsYWJlbFdpZHRoIC0gbmV3TGFiZWxXaWR0aCxcbiAgICAgICAgICAgIG1vdmVMZWZ0ID0gKHBhcmFtcy5sYWJlbFdpZHRoIC8gMikgLSAoc21hbGxBcmVhV2lkdGggKiAyKTtcblxuICAgICAgICBpZiAocGFyYW1zLmRlZ3JlZSA9PT0gY2hhcnRDb25zdC5BTkdMRV84NSkge1xuICAgICAgICAgICAgbW92ZUxlZnQgKz0gc21hbGxBcmVhV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBjaGFydENvbnN0LlhBWElTX0xBQkVMX1RPUF9NQVJHSU4sXG4gICAgICAgICAgICBsZWZ0OiBwYXJhbXMubGVmdCArIGNvbGxlY3RMZWZ0IC0gbW92ZUxlZnRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjc3NUZXh0IGZvciByb3RhdGlvbiBtb3ZpbmcuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmRlZ3JlZSByb3RhdGlvbiBkZWdyZWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxXaWR0aCBsYWJlbCB3aWR0aFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGVmdCBub3JtYWwgbGVmdFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5tb3ZlTGVmdCBtb3ZlIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudG9wIHRvcFxuICAgICAqICAgICAgQHBhcmFtIHsoc3RyaW5nIHwgbnVtYmVyKX0gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjc3NUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNzc1RleHRGb3JSb3RhdGlvbk1vdmluZzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbjtcblxuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVSb3RhdGlvbk1vdmluZ1Bvc2l0aW9uRm9ySUU4KHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZVJvdGF0aW9uTW92aW5nUG9zaXRpb24ocGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJVdGlsLmNvbmNhdFN0cignbGVmdDonLCBwb3NpdGlvbi5sZWZ0LCAncHgnLCAnO3RvcDonLCBwb3NpdGlvbi50b3AsICdweCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGh0bWwgb2Ygcm90YXRpb24gbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBsYWJlbCBwb3NpdGlvbiBhcnJheVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmxhYmVscyBsYWJlbCBhcnJheVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wb3NUeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgYm90dG9tKVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLmNzc1RleHRzIGNzcyBhcnJheVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGxhYmVscyBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJvdGF0aW9uTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGF4aXNUZW1wbGF0ZS50cGxBeGlzTGFiZWwsXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChwYXJhbXMubGFiZWxzWzBdLCBwYXJhbXMudGhlbWUpLFxuICAgICAgICAgICAgbGFiZWxDc3NUZXh0ID0gcGFyYW1zLmNzc1RleHRzLmxlbmd0aCA/IHBhcmFtcy5jc3NUZXh0cy5qb2luKCc7JykgKyAnOycgOiAnJyxcbiAgICAgICAgICAgIGFkZENsYXNzID0gJyB0dWktY2hhcnQteGF4aXMtcm90YXRpb24gdHVpLWNoYXJ0LXhheGlzLXJvdGF0aW9uJyArIHRoaXMuYm91bmRzTWFrZXIueEF4aXNEZWdyZWUsXG4gICAgICAgICAgICBoYWxmV2lkdGggPSBwYXJhbXMubGFiZWxTaXplIC8gMixcbiAgICAgICAgICAgIG1vdmVMZWZ0ID0gY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudCh0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlLCBoYWxmV2lkdGgpLFxuICAgICAgICAgICAgdG9wID0gY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZSh0aGlzLmJvdW5kc01ha2VyLnhBeGlzRGVncmVlLCBoYWxmV2lkdGgpICsgY2hhcnRDb25zdC5YQVhJU19MQUJFTF9UT1BfTUFSR0lOLFxuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHR1aS51dGlsLm1hcChwYXJhbXMucG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBwYXJhbXMubGFiZWxzW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgcm90YXRpb25Dc3NUZXh0ID0gdGhpcy5fbWFrZUNzc1RleHRGb3JSb3RhdGlvbk1vdmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWdyZWU6IHBhcmFtcy5kZWdyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbEhlaWdodDogbGFiZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFdpZHRoOiBwYXJhbXMubGFiZWxTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVMZWZ0OiBtb3ZlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lOiBwYXJhbXMudGhlbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IGxhYmVsQ3NzVGV4dCArIHJvdGF0aW9uQ3NzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gbGFiZWxzSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBodG1sIG9mIG5vcm1hbCBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIGxhYmVsIHBvc2l0aW9uIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMubGFiZWxzIGxhYmVsIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBvc1R5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciBib3R0b20pXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuY3NzVGV4dHMgY3NzIGFycmF5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGF4aXNUZW1wbGF0ZS50cGxBeGlzTGFiZWwsXG4gICAgICAgICAgICBsYWJlbENzc1RleHQgPSBwYXJhbXMuY3NzVGV4dHMubGVuZ3RoID8gcGFyYW1zLmNzc1RleHRzLmpvaW4oJzsnKSArICc7JyA6ICcnLFxuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHR1aS51dGlsLm1hcChwYXJhbXMucG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkQ3NzVGV4dCA9IHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcmFtcy5wb3NUeXBlLCAnOicsIHBvc2l0aW9uLCAncHgnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUoe1xuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzczogJycsXG4gICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IGxhYmVsQ3NzVGV4dCArIGFkZENzc1RleHQsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYXJhbXMubGFiZWxzW2luZGV4XVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBvZiBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIGxhYmVsIHBvc2l0aW9uIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMubGFiZWxzIGxhYmVsIGFycmF5XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBvc1R5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciBib3R0b20pXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMuY3NzVGV4dHMgY3NzIGFycmF5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gbGFiZWxzIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbHNIdG1sO1xuXG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICd4QXhpcycgJiYgdGhpcy5ib3VuZHNNYWtlci54QXhpc0RlZ3JlZSkge1xuICAgICAgICAgICAgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VSb3RhdGlvbkxhYmVsc0h0bWwocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsc0h0bWwgPSB0aGlzLl9tYWtlTm9ybWFsTGFiZWxzSHRtbChwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsc0h0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSBwb3NpdGlvbiBvZiBsYWJlbCBhcmVhLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyXG4gICAgICogICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJhbXMuZWxMYWJlbEFyZWEgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc0xhYmVsQXhpcyB3aGV0aGVyIGxhYmVsIGF4aXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSBwYXJhbXMudGhlbWUgbGFiZWwgdGhlbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxTaXplIGxhYmVsIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VMYWJlbEFyZWFQb3NpdGlvbjogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodDtcblxuICAgICAgICBpZiAocGFyYW1zLmlzTGFiZWxBeGlzICYmICFwYXJhbXMuYWxpZ25lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCgnQUJDJywgcGFyYW1zLnRoZW1lKTtcbiAgICAgICAgICAgIHBhcmFtcy5lbExhYmVsQXJlYS5zdHlsZS50b3AgPSByZW5kZXJVdGlsLmNvbmNhdFN0cihwYXJzZUludChsYWJlbEhlaWdodCAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMuZWxMYWJlbEFyZWEuc3R5bGUubGVmdCA9IHJlbmRlclV0aWwuY29uY2F0U3RyKCctJywgcGFyc2VJbnQocGFyYW1zLmxhYmVsU2l6ZSAvIDIsIDEwKSwgJ3B4Jyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgdGVtcGxhdGVzIG9yIGF4aXMgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIHRhZ3MgPSB7XG4gICAgSFRNTF9BWElTX1RJQ0s6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LXRpY2tcIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj48L2Rpdj4nLFxuICAgIEhUTUxfQVhJU19MQUJFTDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGFiZWx7eyBhZGRDbGFzcyB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjxzcGFuPnt7IGxhYmVsIH19PC9zcGFuPjwvZGl2Pidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbEF4aXNUaWNrOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKHRhZ3MuSFRNTF9BWElTX1RJQ0spLFxuICAgIHRwbEF4aXNMYWJlbDogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZSh0YWdzLkhUTUxfQVhJU19MQUJFTClcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgY2hhcnQuanMgaXMgZW50cnkgcG9pbnQgb2YgVG9hc3QgVUkgQ2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4vY29uc3QnKSxcbiAgICBjaGFydEZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy9jaGFydEZhY3RvcnknKSxcbiAgICBwbHVnaW5GYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpLFxuICAgIHRoZW1lRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yaWVzL3RoZW1lRmFjdG9yeScpLFxuICAgIG1hcEZhY3RvcnkgPSByZXF1aXJlKCcuL2ZhY3Rvcmllcy9tYXBGYWN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQ2hhcnQ7XG5cbnJlcXVpcmUoJy4vcG9seWZpbGwnKTtcbnJlcXVpcmUoJy4vY29kZS1zbmlwcGV0LXV0aWwnKTtcbnJlcXVpcmUoJy4vcmVnaXN0ZXJDaGFydHMnKTtcbnJlcXVpcmUoJy4vcmVnaXN0ZXJUaGVtZXMnKTtcblxuLyoqXG4gKiBOSE4gRW50ZXJ0YWlubWVudCBUb2FzdCBVSSBDaGFydC5cbiAqIEBuYW1lc3BhY2UgdHVpLmNoYXJ0XG4gKi9cbnR1aS51dGlsLmRlZmluZU5hbWVzcGFjZSgndHVpLmNoYXJ0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGNoYXJ0LlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBkYXRhIGNoYXJ0IGRhdGFcbiAqIEBwYXJhbSB7e1xuICogICBjaGFydDoge1xuICogICAgIHdpZHRoOiBudW1iZXIsXG4gKiAgICAgaGVpZ2h0OiBudW1iZXIsXG4gKiAgICAgdGl0bGU6IHN0cmluZyxcbiAqICAgICBmb3JtYXQ6IHN0cmluZ1xuICogICB9LFxuICogICB5QXhpczoge1xuICogICAgIHRpdGxlOiBzdHJpbmcsXG4gKiAgICAgbWluOiBudW1iZXJcbiAqICAgfSxcbiAqICAgeEF4aXM6IHtcbiAqICAgICB0aXRsZTogc3RyaWcsXG4gKiAgICAgbWluOiBudW1iZXJcbiAqICAgfSxcbiAqICAgdG9vbHRpcDoge1xuICogICAgIHN1ZmZpeDogc3RyaW5nLFxuICogICAgIHRlbXBsYXRlOiBmdW5jdGlvblxuICogICB9LFxuICogICB0aGVtZTogc3RyaW5nXG4gKiB9fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IGNoYXJ0IGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqIEBpZ25vcmVcbiAqL1xuX2NyZWF0ZUNoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoZW1lTmFtZSwgdGhlbWUsIGNoYXJ0O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSkgOiB7fTtcbiAgICB0aGVtZU5hbWUgPSBvcHRpb25zLnRoZW1lIHx8IGNoYXJ0Q29uc3QuREVGQVVMVF9USEVNRV9OQU1FO1xuICAgIHRoZW1lID0gdGhlbWVGYWN0b3J5LmdldCh0aGVtZU5hbWUpO1xuXG4gICAgY2hhcnQgPSBjaGFydEZhY3RvcnkuZ2V0KG9wdGlvbnMuY2hhcnRUeXBlLCBkYXRhLCB0aGVtZSwgb3B0aW9ucyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoYXJ0LnJlbmRlcigpKTtcbiAgICBjaGFydC5hbmltYXRlQ2hhcnQoKTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbi8qKlxuICogQmFyIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgc3RhY2tlZCB0eXBlXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuYmFyV2lkdGggYmFyIHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZyB3aGV0aGVyIGRpdmVyZ2luZyBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdCYXIgQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5iYXJDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuYmFyQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9CQVI7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb2x1bW4gY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZGF0YS5jYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSBkYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueUF4aXMgb3B0aW9ucyBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSB0aXRsZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5taW4gbWluaW1hbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5tYXggbWF4aW11bSB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgbGFiZWwgaW50ZXJ2YWwgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueEF4aXMucm90YXRpb24gd2hldGhlciBsYWJlbCByb3RhdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgc3RhY2tlZCB0eXBlXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuYmFyV2lkdGggYmFyIHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmRpdmVyZ2luZyB3aGV0aGVyIGRpdmVyZ2luZyBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGNvbHVtbiBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdDb2x1bW4gQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5jb2x1bW5DaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuY29sdW1uQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU47XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBMaW5lIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGRhdGEuY2F0ZWdvcmllcyBjYXRlZ29yaWVzXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnlBeGlzIG9wdGlvbnMgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueUF4aXMudGl0bGUgdGl0bGUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWluIG1pbmltYWwgdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueUF4aXMubWF4IG1heGltdW0gdmFsdWUgb2YgdmVydGljYWwgYXhpc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy54QXhpcyBvcHRpb25zIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMueEF4aXMudGl0bGUgdGl0bGUgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy54QXhpcy5sYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnhBeGlzLnJvdGF0aW9uIHdoZXRoZXIgbGFiZWwgcm90YXRpb24gb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMgb3B0aW9ucyBvZiBzZXJpZXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzRG90IHdoZXRoZXIgaGFzIGRvdCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuaGFzU2VsZWN0aW9uIHdoZXRoZXIgaGFzIHNlbGVjdGlvbiBvciBub3RcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuc3BsaW5lIHdoZXRoZXIgc3BsaW5lIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnRvb2x0aXAuZ3JvdXBlZCB3aGV0aGVyIGdyb3VwIHRvb2x0aXAgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmxlZ2VuZCBvcHRpb25zIG9mIGxlZ2VuZFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGVnZW5kLmFsaWduIGxlZ2VuZCBhbGlnbiAodG9wfGJvdHRvbXxsZWZ0KVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oYXNDaGVja2JveCB3aGV0aGVyIGhhcyBjaGVja2JveCBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhpZGRlbiB3aGV0aGVyIGhpZGRlbiBvciBub3RcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGhlbWUgdGhlbWUgbmFtZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICBkYXRhID0ge1xuICogICAgICAgY2F0ZWdvcmllczogWydjYXRlMScsICdjYXRlMicsICdjYXRlMyddLFxuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgZGF0YTogWzIwLCAzMCwgNTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgZGF0YTogWzQwLCA0MCwgNjBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMycsXG4gKiAgICAgICAgICAgZGF0YTogWzYwLCA1MCwgMTBdXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kNCcsXG4gKiAgICAgICAgICAgZGF0YTogWzgwLCAxMCwgNzBdXG4gKiAgICAgICAgIH1cbiAqICAgICAgIF1cbiAqICAgICB9LFxuICogICAgIG9wdGlvbnMgPSB7XG4gKiAgICAgICBjaGFydDoge1xuICogICAgICAgICB0aXRsZTogJ0xpbmUgQ2hhcnQnXG4gKiAgICAgICB9LFxuICogICAgICAgeUF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdZIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgc2VyaWVzOiB7XG4gKiAgICAgICAgIGhhc0RvdDogdHJ1ZVxuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQubGluZUNoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5saW5lQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQXJlYSBjaGFydCBjcmVhdG9yLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNoYXJ0IGNvbnRhaW5lclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgY2hhcnQgZGF0YVxuICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBkYXRhLmNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheT59IGRhdGEuc2VyaWVzIHNlcmllcyBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNoYXJ0IGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LndpZHRoIGNoYXJ0IHdpZHRoXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC5oZWlnaHQgY2hhcnQgaGVpZ2h0XG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC50aXRsZSBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQuZm9ybWF0IHZhbHVlIGZvcm1hdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy55QXhpcyBvcHRpb25zIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnlBeGlzLnRpdGxlIHRpdGxlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1pbiBtaW5pbWFsIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnlBeGlzLm1heCBtYXhpbXVtIHZhbHVlIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMueEF4aXMgb3B0aW9ucyBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnhBeGlzLnRpdGxlIHRpdGxlIG9mIGhvcml6b250YWwgYXhpc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMueEF4aXMubGFiZWxJbnRlcnZhbCBsYWJlbCBpbnRlcnZhbCBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy54QXhpcy5yb3RhdGlvbiB3aGV0aGVyIGxhYmVsIHJvdGF0aW9uIG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc0RvdCB3aGV0aGVyIGhhcyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNwbGluZSB3aGV0aGVyIHNwbGluZSBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuc3VmZml4IHN1ZmZpeCBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczogW1xuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDEnLFxuICogICAgICAgICAgIGRhdGE6IFsyMCwgMzAsIDUwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IFs0MCwgNDAsIDYwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDMnLFxuICogICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgIGRhdGE6IFs4MCwgMTAsIDcwXVxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdBcmVhIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIHlBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWSBBeGlzJ1xuICogICAgICAgfSxcbiAqICAgICAgIHhBeGlzOiB7XG4gKiAgICAgICAgIHRpdGxlOiAnWCBBeGlzJ1xuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuYXJlYUNoYXJ0KGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucyk7XG4gKi9cbnR1aS5jaGFydC5hcmVhQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29tYm8gY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gZGF0YS5jYXRlZ29yaWVzIGNhdGVnb3JpZXNcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSBkYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R8QXJyYXl9IG9wdGlvbnMueUF4aXMgb3B0aW9ucyBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy55QXhpcy50aXRsZSB0aXRsZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5taW4gbWluaW1hbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy55QXhpcy5tYXggbWF4aW11bSB2YWx1ZSBvZiB2ZXJ0aWNhbCBheGlzXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnhBeGlzIG9wdGlvbnMgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy54QXhpcy50aXRsZSB0aXRsZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnhBeGlzLmxhYmVsSW50ZXJ2YWwgbGFiZWwgaW50ZXJ2YWwgb2YgaG9yaXpvbnRhbCBheGlzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMueEF4aXMucm90YXRpb24gd2hldGhlciBsYWJlbCByb3RhdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRydWUpXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzLmNvbHVtbiBvcHRpb25zIG9mIGNvbHVtbiBzZXJpZXNcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zZXJpZXMuY29sdW1uLnN0YWNrZWQgc3RhY2tlZCB0eXBlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5jb2x1bW4uc2hvd0xhYmVsIHdoZXRoZXIgc2hvdyBsYWJlbCBvciBub3RcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zZXJpZXMuY29sdW1uLmJhcldpZHRoIGJhciB3aWR0aFxuICogICAgICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zZXJpZXMuY29sdW1uLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5zZXJpZXMubGluZSBvcHRpb25zIG9mIGxpbmUgc2VyaWVzXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLmhhc0RvdCB3aGV0aGVyIGhhcyBkb3Qgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLmhhc1NlbGVjdGlvbiB3aGV0aGVyIGhhcyBzZWxlY3Rpb24gb3Igbm90XG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5saW5lLnNwbGluZSB3aGV0aGVyIHNwbGluZSBvciBub3RcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcCBvcHRpb25zIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAuY29sdW1uIG9wdGlvbnMgb2YgY29sdW1uIHRvb2x0aXBcbiAqICAgICAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmNvbHVtbi5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLmNvbHVtbi50ZW1wbGF0ZV0gdGVtcGxhdGUgb2YgdG9vbHRpcFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5jb2x1bW4ucG9zaXRpb24ubGVmdCBwb3NpdGlvbiBsZWZ0XG4gKiAgICAgICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAuY29sdW1uLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy50b29sdGlwLmdyb3VwZWQgd2hldGhlciBncm91cCB0b29sdGlwIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdClcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGFzQ2hlY2tib3ggd2hldGhlciBoYXMgY2hlY2tib3ggb3Igbm90IChkZWZhdWx0OiB0cnVlKVxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmxlZ2VuZC5oaWRkZW4gd2hldGhlciBoaWRkZW4gb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRoZW1lIHRoZW1lIG5hbWVcbiAqICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubGliVHlwZSBncmFwaCBsaWJyYXJ5IHR5cGVcbiAqIEByZXR1cm5zIHtvYmplY3R9IGJhciBjaGFydFxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyLWlkJyksXG4gKiAgICAgZGF0YSA9IHtcbiAqICAgICAgIGNhdGVnb3JpZXM6IFsnY2F0ZTEnLCAnY2F0ZTInLCAnY2F0ZTMnXSxcbiAqICAgICAgIHNlcmllczoge1xuICogICAgICAgICBjb2x1bW46IFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kMScsXG4gKiAgICAgICAgICAgICBkYXRhOiBbMjAsIDMwLCA1MF1dXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnTGVnZW5kMicsXG4gKiAgICAgICAgICAgICBkYXRhOiBbNDAsIDQwLCA2MF1cbiAqICAgICAgICAgICB9LFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdMZWdlbmQzJyxcbiAqICAgICAgICAgICAgIGRhdGE6IFs2MCwgNTAsIDEwXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDQnLFxuICogICAgICAgICAgICAgZGF0YTogWzgwLCAxMCwgNzBdXG4gKiAgICAgICAgICAgfVxuICogICAgICAgICB9LFxuICogICAgICAgICBsaW5lOiBbXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDUnLFxuICogICAgICAgICAgICAgZGF0YTogWzEsIDIsIDNdXG4gKiAgICAgICAgICAgfVxuICogICAgICAgICBdXG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdDb21ibyBDaGFydCdcbiAqICAgICAgIH0sXG4gKiAgICAgICB5QXhpczpbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICB0aXRsZTogJ1kgQXhpcycsXG4gKiAgICAgICAgICAgY2hhcnRUeXBlOiAnbGluZSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIHRpdGxlOiAnWSBSaWdodCBBeGlzJ1xuICogICAgICAgICB9XG4gKiAgICAgICBdLFxuICogICAgICAgeEF4aXM6IHtcbiAqICAgICAgICAgdGl0bGU6ICdYIEF4aXMnXG4gKiAgICAgICB9LFxuICogICAgICAgc2VyaWVzOiB7XG4gKiAgICAgICAgIGhhc0RvdDogdHJ1ZVxuICogICAgICAgfVxuICogICAgIH07XG4gKiB0dWkuY2hhcnQuY29tYm9DaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQuY29tYm9DaGFydCA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuY2hhcnRUeXBlID0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTUJPO1xuICAgIHJldHVybiBfY3JlYXRlQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUGllIGNoYXJ0IGNyZWF0b3IuXG4gKiBAbWVtYmVyT2YgdHVpLmNoYXJ0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgY2hhcnQgY29udGFpbmVyXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBjaGFydCBkYXRhXG4gKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gZGF0YS5zZXJpZXMgc2VyaWVzIGRhdGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2hhcnQgY2hhcnQgb3B0aW9uc1xuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQud2lkdGggY2hhcnQgd2lkdGhcbiAqICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNoYXJ0LmhlaWdodCBjaGFydCBoZWlnaHRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LnRpdGxlIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jaGFydC5mb3JtYXQgdmFsdWUgZm9ybWF0XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnNlcmllcyBvcHRpb25zIG9mIHNlcmllc1xuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5zaG93TGFiZWwgd2hldGhlciBzaG93IGxhYmVsIG9yIG5vdFxuICogICAgICAgICAgQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnNlcmllcy5oYXNTZWxlY3Rpb24gd2hldGhlciBoYXMgc2VsZWN0aW9uIG9yIG5vdFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwIG9wdGlvbnMgb2YgdG9vbHRpcFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9vbHRpcC5zdWZmaXggc3VmZml4IG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRvb2x0aXAudGVtcGxhdGVdIHRlbXBsYXRlIG9mIHRvb2x0aXBcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvb2x0aXAuYWxpZ24gdG9vbHRpcCBhbGlnbiBvcHRpb25cbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24gcmVsYXRpdmUgcG9zaXRpb25cbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLmxlZnQgcG9zaXRpb24gbGVmdFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnRvb2x0aXAucG9zaXRpb24udG9wIHBvc2l0aW9uIHRvcFxuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5sZWdlbmQgb3B0aW9ucyBvZiBsZWdlbmRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxlZ2VuZC5hbGlnbiBsZWdlbmQgYWxpZ24gKHRvcHxib3R0b218bGVmdHxjZW50ZXJ8b3V0ZXIpXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMubGVnZW5kLmhhc0NoZWNrYm94IHdoZXRoZXIgaGFzIGNoZWNrYm94IG9yIG5vdCAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5sZWdlbmQuaGlkZGVuIHdoZXRoZXIgaGlkZGVuIG9yIG5vdFxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmxpYlR5cGUgZ3JhcGggbGlicmFyeSB0eXBlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBiYXIgY2hhcnRcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lci1pZCcpLFxuICogICAgIGRhdGEgPSB7XG4gKiAgICAgICBzZXJpZXM6IFtcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQxJyxcbiAqICAgICAgICAgICBkYXRhOiAyMFxuICogICAgICAgICB9LFxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgbmFtZTogJ0xlZ2VuZDInLFxuICogICAgICAgICAgIGRhdGE6IDQwXG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBuYW1lOiAnTGVnZW5kMycsXG4gKiAgICAgICAgICAgZGF0YTogNjBcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIG5hbWU6ICdMZWdlbmQ0JyxcbiAqICAgICAgICAgICBkYXRhOiA4MFxuICogICAgICAgICB9XG4gKiAgICAgICBdXG4gKiAgICAgfSxcbiAqICAgICBvcHRpb25zID0ge1xuICogICAgICAgY2hhcnQ6IHtcbiAqICAgICAgICAgdGl0bGU6ICdQaWUgQ2hhcnQnXG4gKiAgICAgICB9XG4gKiAgICAgfTtcbiAqIHR1aS5jaGFydC5waWVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xuICovXG50dWkuY2hhcnQucGllQ2hhcnQgPSBmdW5jdGlvbihjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmNoYXJ0VHlwZSA9IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9QSUU7XG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBNYXAgY2hhcnQgY3JlYXRvci5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjaGFydCBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXk+fSBkYXRhLnNlcmllcyBzZXJpZXMgZGF0YVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jaGFydCBjaGFydCBvcHRpb25zXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFydC53aWR0aCBjaGFydCB3aWR0aFxuICogICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhcnQuaGVpZ2h0IGNoYXJ0IGhlaWdodFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2hhcnQudGl0bGUgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNoYXJ0LmZvcm1hdCB2YWx1ZSBmb3JtYXRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuc2VyaWVzIG9wdGlvbnMgb2Ygc2VyaWVzXG4gKiAgICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc2VyaWVzLnNob3dMYWJlbCB3aGV0aGVyIHNob3cgbGFiZWwgb3Igbm90XG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnRvb2x0aXAgb3B0aW9ucyBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy50b29sdGlwLnRlbXBsYXRlXSB0ZW1wbGF0ZSBvZiB0b29sdGlwXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b29sdGlwLmFsaWduIHRvb2x0aXAgYWxpZ24gb3B0aW9uXG4gKiAgICAgICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudG9vbHRpcC5wb3NpdGlvbi5sZWZ0IHBvc2l0aW9uIGxlZnRcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy50b29sdGlwLnBvc2l0aW9uLnRvcCBwb3NpdGlvbiB0b3BcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMubGVnZW5kIG9wdGlvbnMgb2YgbGVnZW5kXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5sZWdlbmQuYWxpZ24gbGVnZW5kIGFsaWduICh0b3B8Ym90dG9tfGxlZnR8Y2VudGVyfG91dGVyKVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50aGVtZSB0aGVtZSBuYW1lXG4gKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm1hcCBtYXAgdHlwZVxuICogICAgICBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5saWJUeXBlIGdyYXBoIGxpYnJhcnkgdHlwZVxuICogQHJldHVybnMge29iamVjdH0gYmFyIGNoYXJ0XG4gKiBAYXBpXG4gKiBAZXhhbXBsZVxuICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXItaWQnKSxcbiAqICAgICBkYXRhID0ge1xuICogICAgICAgc2VyaWVzOiBbXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBjb2RlOiAnS1InLFxuICogICAgICAgICAgIGRhdGE6IDEwMCxcbiAqICAgICAgICAgICBsYWJlbENvb3JkaW5hdGU6IHtcbiAqICAgICAgICAgICAgIHg6IDAuNixcbiAqICAgICAgICAgICAgIHk6IDAuN1xuICogICAgICAgICAgIH1cbiAqICAgICAgICAgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIGNvZGU6ICdKUCcsXG4gKiAgICAgICAgICAgZGF0YTogNTBcbiAqICAgICAgICAgfVxuICogICAgICAgXVxuICogICAgIH0sXG4gKiAgICAgb3B0aW9ucyA9IHtcbiAqICAgICAgIGNoYXJ0OiB7XG4gKiAgICAgICAgIHRpdGxlOiAnTWFwIENoYXJ0J1xuICogICAgICAgfSxcbiAqICAgICAgIG1hcDogJ3dvcmxkJ1xuICogICAgIH07XG4gKiB0dWkuY2hhcnQubWFwQ2hhcnQoY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKTtcbiAqL1xudHVpLmNoYXJ0Lm1hcENoYXJ0ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5jaGFydFR5cGUgPSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTUFQO1xuICAgIG9wdGlvbnMubWFwID0gbWFwRmFjdG9yeS5nZXQob3B0aW9ucy5tYXApO1xuXG4gICAgcmV0dXJuIF9jcmVhdGVDaGFydChjb250YWluZXIsIGRhdGEsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciB0aGVtZS5cbiAqIEBtZW1iZXJPZiB0dWkuY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aGVtZU5hbWUgdGhlbWUgbmFtZVxuICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGFwcGxpY2F0aW9uIGNoYXJ0IHRoZW1lXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5jaGFydCBjaGFydCB0aGVtZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLmNoYXJ0LmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgY2hhcnRcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5jaGFydC5iYWNrZ3JvdW5kIGJhY2tncm91bmQgb2YgY2hhcnRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnRpdGxlIGNoYXJ0IHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUudGl0bGUuZm9udFNpemUgZm9udCBzaXplIG9mIGNoYXJ0IHRpdGxlXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUudGl0bGUuZm9udEZhbWlseSBmb250IGZhbWlseSBvZiBjaGFydCB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnRpdGxlLmNvbG9yIGZvbnQgY29sb3Igb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS50aXRsZS5iYWNrZ3JvdW5kIGJhY2tncm91bmQgb2YgY2hhcnQgdGl0bGVcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnlBeGlzIHRoZW1lIG9mIHZlcnRpY2FsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS55QXhpcy50aXRsZSB0aGVtZSBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnlBeGlzLnRpdGxlLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiB2ZXJ0aWNhbCBheGlzIHRpdGxlXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLnRpdGxlLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgdmVydGljYWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy50aXRsZS5jb2xvciBmb250IGNvbG9yIG9mIHZlcnRpY2FsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS55QXhpcy5sYWJlbCB0aGVtZSBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLnlBeGlzLmxhYmVsLmZvbnRTaXplIGZvbnQgc2l6ZSBvZiB2ZXJ0aWNhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnlBeGlzLmxhYmVsLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgdmVydGljYWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy5sYWJlbC5jb2xvciBmb250IGNvbG9yIG9mIHZlcnRpY2FsIGF4aXMgbGFiZWxcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS55QXhpcy50aWNrY29sb3IgY29sb3Igb2YgdmVydGljYWwgYXhpcyB0aWNrXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS54QXhpcyB0aGVtZSBvZiBob3Jpem9udGFsIGF4aXNcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS54QXhpcy50aXRsZSB0aGVtZSBvZiBob3Jpem9udGFsIGF4aXMgdGl0bGVcbiAqICAgICAgICAgICAgICBAcGFyYW0ge251bWJlcn0gdGhlbWUueEF4aXMudGl0bGUuZm9udFNpemUgZm9udCBzaXplIG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy50aXRsZS5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS54QXhpcy50aXRsZS5jb2xvciBmb250IGNvbG9yIG9mIGhvcml6b250YWwgYXhpcyB0aXRsZVxuICogICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLnhBeGlzLmxhYmVsIHRoZW1lIG9mIGhvcml6b250YWwgYXhpcyBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7bnVtYmVyfSB0aGVtZS54QXhpcy5sYWJlbC5mb250U2l6ZSBmb250IHNpemUgb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLmxhYmVsLmZvbnRGYW1pbHkgZm9udCBmYW1pbHkgb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnhBeGlzLmxhYmVsLmNvbG9yIGZvbnQgY29sb3Igb2YgaG9yaXpvbnRhbCBheGlzIGxhYmVsXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUueEF4aXMudGlja2NvbG9yIGNvbG9yIG9mIGhvcml6b250YWwgYXhpcyB0aWNrXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5wbG90IHBsb3QgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5wbG90LmxpbmVDb2xvciBwbG90IGxpbmUgY29sb3JcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5wbG90LmJhY2tncm91bmQgcGxvdCBiYWNrZ3JvdW5kXG4gKiAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5zZXJpZXMgc2VyaWVzIHRoZW1lXG4gKiAgICAgICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSB0aGVtZS5zZXJpZXMuY29sb3JzIHNlcmllcyBjb2xvcnNcbiAqICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5zZXJpZXMuYm9yZGVyQ29sb3Igc2VyaWVzIGJvcmRlciBjb2xvclxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5zZWxlY3Rpb25Db2xvciBzZXJpZXMgc2VsZWN0aW9uIGNvbG9yXG4gKiAgICAgICAgICBAcGFyYW0ge3N0cmluZ30gdGhlbWUuc2VyaWVzLnN0YXJ0Q29sb3Igc3RhcnQgY29sb3IgZm9yIG1hcCBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5lbmRDb2xvciBlbmQgY29sb3IgZm9yIG1hcCBjaGFydFxuICogICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLnNlcmllcy5vdmVyQ29sb3IgZW5kIGNvbG9yIGZvciBtYXAgY2hhcnRcbiAqICAgICAgQHBhcmFtIHtvYmplY3R9IHRoZW1lLmxlZ2VuZCBsZWdlbmQgdGhlbWVcbiAqICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSB0aGVtZS5sZWdlbmQubGFiZWwgdGhlbWUgb2YgbGVnZW5kIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtudW1iZXJ9IHRoZW1lLmxlZ2VuZC5sYWJlbC5mb250U2l6ZSBmb250IHNpemUgb2YgbGVnZW5kIGxhYmVsXG4gKiAgICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHRoZW1lLmxlZ2VuZC5sYWJlbC5mb250RmFtaWx5IGZvbnQgZmFtaWx5IG9mIGxlZ2VuZCBsYWJlbFxuICogICAgICAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0aGVtZS5sZWdlbmQubGFiZWwuY29sb3IgZm9udCBjb2xvciBvZiBsZWdlbmQgbGFiZWxcbiAqIEBhcGlcbiAqIEBleGFtcGxlXG4gKiB2YXIgdGhlbWUgPSB7XG4gKiAgIHlBeGlzOiB7XG4gKiAgICAgdGlja0NvbG9yOiAnI2NjYmQ5YScsXG4gKiAgICAgICB0aXRsZToge1xuICogICAgICAgICBjb2xvcjogJyMzMzMzMzMnXG4gKiAgICAgICB9LFxuICogICAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgY29sb3I6ICcjNmY0OTFkJ1xuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeEF4aXM6IHtcbiAqICAgICAgIHRpY2tDb2xvcjogJyNjY2JkOWEnLFxuICogICAgICAgdGl0bGU6IHtcbiAqICAgICAgICAgY29sb3I6ICcjMzMzMzMzJ1xuICogICAgICAgfSxcbiAqICAgICAgIGxhYmVsOiB7XG4gKiAgICAgICAgIGNvbG9yOiAnIzZmNDkxZCdcbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHBsb3Q6IHtcbiAqICAgICAgIGxpbmVDb2xvcjogJyNlNWRiYzQnLFxuICogICAgICAgYmFja2dyb3VuZDogJyNmNmYxZTUnXG4gKiAgICAgfSxcbiAqICAgICBzZXJpZXM6IHtcbiAqICAgICAgIGNvbG9yczogWycjNDBhYmI0JywgJyNlNzhhMzEnLCAnI2MxYzQ1MicsICcjNzk1MjI0JywgJyNmNWY1ZjUnXSxcbiAqICAgICAgIGJvcmRlckNvbG9yOiAnIzhlNjUzNScsXG4gKiAgICAgICBzZWxlY3Rpb25Db2xvcjogJyNjY2NjY2MnLFxuICogICAgICAgc3RhcnRDb2xvcjogJyNlZmVmZWYnLFxuICogICAgICAgZW5kQ29sb3I6ICdibHVlJyxcbiAqICAgICAgIG92ZXJDb2xvcjogJ3llbGxvdydcbiAqICAgICB9LFxuICogICAgIGxlZ2VuZDoge1xuICogICAgICAgbGFiZWw6IHtcbiAqICAgICAgICAgY29sb3I6ICcjNmY0OTFkJ1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfTtcbiAqIHR1aS5jaGFydC5yZWdpc3RlclRoZW1lKCduZXdUaGVtZScsIHRoZW1lKTtcbiAqL1xudHVpLmNoYXJ0LnJlZ2lzdGVyVGhlbWUgPSBmdW5jdGlvbih0aGVtZU5hbWUsIHRoZW1lKSB7XG4gICAgdGhlbWVGYWN0b3J5LnJlZ2lzdGVyKHRoZW1lTmFtZSwgdGhlbWUpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBtYXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZSBtYXAgbmFtZVxuICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gbWFwIGRpbWVuc2lvblxuICogQHBhcmFtIHtBcnJheS48e2NvZGU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmd9Pn0gZGF0YSBtYXAgZGF0YVxuICogQGFwaVxuICogQGV4YW1wbGVcbiAqIHZhciBkYXRhID0gW1xuICogICB7XG4gKiAgICAgY29kZTogJ0tSJyxcbiAqICAgICBuYW1lOiAnU291dGggS29yZWEnLFxuICogICAgIHBhdGg6ICdNODM1LjEzLDM0Ni41M0w4MzcuNTUsMzUwLjcxLi4uJyxcbiAqICAgICBsYWJlbENvb3JkaW5hdGU6IHtcbiAqICAgICAgIHg6IDAuNixcbiAqICAgICAgIHk6IDAuN1xuICogICAgIH1cbiAqICAgfSxcbiAqICAgLy8uLi5cbiAqIF07XG4gKiB0dWkuY2hhcnQucmVnaXN0ZXJNYXAoJ25ld01hcCcsIGRhdGEpO1xuICovXG50dWkuY2hhcnQucmVnaXN0ZXJNYXAgPSBmdW5jdGlvbihtYXBOYW1lLCBkYXRhKSB7XG4gICAgbWFwRmFjdG9yeS5yZWdpc3RlcihtYXBOYW1lLCBkYXRhKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgZ3JhcGggcGx1Z2luLlxuICogQG1lbWJlck9mIHR1aS5jaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGxpYlR5cGUgdHlwZSBvZiBncmFwaCBsaWJyYXJ5XG4gKiBAcGFyYW0ge29iamVjdH0gcGx1Z2luIHBsdWdpbiB0byBjb250cm9sIGxpYnJhcnlcbiAqIEBleGFtcGxlXG4gKiB2YXIgcGx1Z2luUmFwaGFlbCA9IHtcbiAqICAgYmFyOiBmdW5jdGlvbigpIHt9IC8vIFJlbmRlciBjbGFzc1xuICogfTtcbiAqIHR1aS5jaGFydC5yZWdpc3RlclBsdWdpbigncmFwaGFlbCcsIHBsdWdpblJhcGhhZWwpO1xuICovXG50dWkuY2hhcnQucmVnaXN0ZXJQbHVnaW4gPSBmdW5jdGlvbihsaWJUeXBlLCBwbHVnaW4pIHtcbiAgICBwbHVnaW5GYWN0b3J5LnJlZ2lzdGVyKGxpYlR5cGUsIHBsdWdpbik7XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFyZWEgY2hhcnRcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgbGluZVR5cGVNaXhlciA9IHJlcXVpcmUoJy4vbGluZVR5cGVNaXhlcicpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvYXJlYUNoYXJ0U2VyaWVzJyk7XG5cbnZhciBBcmVhQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgTGluZUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogY2xhc3NOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBjbGFzc05hbWU6ICd0dWktYXJlYS1jaGFydCcsXG5cbiAgICAvKipcbiAgICAgKiBTZXJpZXMgY2xhc3NcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgU2VyaWVzOiBTZXJpZXMsXG5cbiAgICAvKipcbiAgICAgKiBBcmVhIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEFyZWFDaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBtaXhlcyBheGlzVHlwZU1peGVyXG4gICAgICogQG1peGVzIHZlcnRpY2FsVHlwZU1peGVyXG4gICAgICogQG1peGVzIGxpbmVUeXBlTWl4ZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGluZVR5cGVJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxufSk7XG5cbmF4aXNUeXBlTWl4ZXIubWl4aW4oQXJlYUNoYXJ0KTtcbmxpbmVUeXBlTWl4ZXIubWl4aW4oQXJlYUNoYXJ0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcmVhQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYXhpc1R5cGVNaXhlciBpcyBtaXhlciBvZiBheGlzIHR5cGUgY2hhcnQoYmFyLCBjb2x1bW4sIGxpbmUsIGFyZWEpLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgQXhpcyA9IHJlcXVpcmUoJy4uL2F4ZXMvYXhpcycpLFxuICAgIFBsb3QgPSByZXF1aXJlKCcuLi9wbG90cy9wbG90JyksXG4gICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9sZWdlbmQnKSxcbiAgICBHcm91cFR5cGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9ncm91cFR5cGVDdXN0b21FdmVudCcpLFxuICAgIFBvaW50VHlwZUN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL3BvaW50VHlwZUN1c3RvbUV2ZW50JyksXG4gICAgVG9vbHRpcCA9IHJlcXVpcmUoJy4uL3Rvb2x0aXBzL3Rvb2x0aXAnKSxcbiAgICBHcm91cFRvb2x0aXAgPSByZXF1aXJlKCcuLi90b29sdGlwcy9ncm91cFRvb2x0aXAnKTtcblxuXG4vKipcbiAqIEF4aXMgbGltaXQgdmFsdWUuXG4gKiBAdHlwZWRlZiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGF4aXNMaW1pdFxuICovXG5cbi8qKlxuICogYXhpc1R5cGVNaXhlciBpcyBiYXNlIGNsYXNzIG9mIGF4aXMgdHlwZSBjaGFydChiYXIsIGNvbHVtbiwgbGluZSwgYXJlYSkuXG4gKiBAbWl4aW5cbiAqL1xudmFyIGF4aXNUeXBlTWl4ZXIgPSB7XG4gICAgLyoqXG4gICAgICogQWRkIGF4aXMgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBheGVzIGF4ZXMgb3B0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGlnbmVkIHdoZXRoZXIgYWxpZ25lZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRBeGlzQ29tcG9uZW50czogZnVuY3Rpb24oYXhlcywgYWxpZ25lZCkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGF4ZXMsIGZ1bmN0aW9uKGF4aXMpIHtcbiAgICAgICAgICAgIHZhciBheGlzUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGFsaWduZWQ6IGFsaWduZWQsXG4gICAgICAgICAgICAgICAgaXNMYWJlbDogISFheGlzLmlzTGFiZWwsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBheGlzLmNoYXJ0VHlwZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGF4aXMubmFtZSA9PT0gJ3JpZ2h0WUF4aXMnKSB7XG4gICAgICAgICAgICAgICAgYXhpc1BhcmFtcy5jb21wb25lbnRUeXBlID0gJ3lBeGlzJztcbiAgICAgICAgICAgICAgICBheGlzUGFyYW1zLmluZGV4ID0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKGF4aXMubmFtZSwgQXhpcywgYXhpc1BhcmFtcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc2VyaWVzIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IHNlcmllc2VzIHNlcmllc2VzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxpZ25lZCB3aGV0aGVyIGFsaWduZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkU2VyaWVzQ29tcG9uZW50czogZnVuY3Rpb24oc2VyaWVzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlcmllc0Jhc2VQYXJhbXMgPSB7XG4gICAgICAgICAgICBsaWJUeXBlOiBvcHRpb25zLmxpYlR5cGUsXG4gICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudCxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdzZXJpZXMnXG4gICAgICAgIH07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWVzUGFyYW1zID0gdHVpLnV0aWwuZXh0ZW5kKHNlcmllc0Jhc2VQYXJhbXMsIHNlcmllcy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcihzZXJpZXMubmFtZSwgc2VyaWVzLlNlcmllc0NsYXNzLCBzZXJpZXNQYXJhbXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9vbHRpcENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBUb29sdGlwQ2xhc3MgPSB0aGlzLmhhc0dyb3VwVG9vbHRpcCA/IEdyb3VwVG9vbHRpcCA6IFRvb2x0aXA7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigndG9vbHRpcCcsIFRvb2x0aXBDbGFzcywgdGhpcy5fbWFrZVRvb2x0aXBEYXRhKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIHNlcmllcyBjaGFydCB0eXBlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnRUeXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxlZ2VuZE9wdGlvbnMgbGVnZW5kIG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRMZWdlbmRDb21wb25lbnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMsIGNoYXJ0VHlwZSwgbGVnZW5kT3B0aW9ucykge1xuICAgICAgICBpZiAoIWxlZ2VuZE9wdGlvbnMgfHwgIWxlZ2VuZE9wdGlvbnMuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2xlZ2VuZCcsIExlZ2VuZCwge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZXM6IGNoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHMgZm9yIGF4aXMgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuYXhlcyBheGVzIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucGxvdERhdGEgcGxvdCBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuc2VyaWVzZXMgc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGFsaWduZWQgPSAhIXBhcmFtcy5hbGlnbmVkO1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcigncGxvdCcsIFBsb3QpO1xuICAgICAgICB0aGlzLl9hZGRBeGlzQ29tcG9uZW50cyhwYXJhbXMuYXhlcywgYWxpZ25lZCk7XG4gICAgICAgIHRoaXMuX2FkZExlZ2VuZENvbXBvbmVudChwYXJhbXMuc2VyaWVzQ2hhcnRUeXBlcywgcGFyYW1zLmNoYXJ0VHlwZSwgdGhpcy5vcHRpb25zLmxlZ2VuZCk7XG4gICAgICAgIHRoaXMuX2FkZFNlcmllc0NvbXBvbmVudHMocGFyYW1zLnNlcmllc2VzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fYWRkVG9vbHRpcENvbXBvbmVudChvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsaW1pdCBtYXAuXG4gICAgICogQHBhcmFtIHt7eUF4aXM6IG9iamVjdCwgeEF4aXM6IG9iamVjdH19IGF4ZXNEYXRhIGF4ZXMgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7e2NvbHVtbjogP2F4aXNMaW1pdCwgbGluZTogP2F4aXNMaW1pdH19IGxpbWl0IG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbWl0TWFwOiBmdW5jdGlvbihheGVzRGF0YSwgY2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgbGltaXRNYXAgPSB7fSxcbiAgICAgICAgICAgIHlBeGlzTGltaXQgPSBheGVzRGF0YS55QXhpcyA/IGF4ZXNEYXRhLnlBeGlzLmxpbWl0IDogYXhlc0RhdGEucmlnaHRZQXhpcy5saW1pdDtcblxuICAgICAgICBsaW1pdE1hcFtjaGFydFR5cGVzWzBdXSA9IHRoaXMuaXNWZXJ0aWNhbCA/IHlBeGlzTGltaXQgOiBheGVzRGF0YS54QXhpcy5saW1pdDtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsaW1pdE1hcFtjaGFydFR5cGVzWzFdXSA9IGF4ZXNEYXRhLnJpZ2h0WUF4aXMgPyBheGVzRGF0YS5yaWdodFlBeGlzLmxpbWl0IDogeUF4aXNMaW1pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW1pdE1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YSBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7e3lBeGlzOiBvYmplY3QsIHhBeGlzOiBvYmplY3R9fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZzogZnVuY3Rpb24oYXhlc0RhdGEsIGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIGxpbWl0TWFwID0gdGhpcy5fZ2V0TGltaXRNYXAoYXhlc0RhdGEsIGNoYXJ0VHlwZXMpLFxuICAgICAgICAgICAgYWxpZ25lZCA9IGF4ZXNEYXRhLnhBeGlzLmFsaWduZWQsXG4gICAgICAgICAgICBzZXJpZXNEYXRhID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgc2VyaWVzRGF0YVtjaGFydFR5cGUgKyAnU2VyaWVzJ10gPSB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0TWFwW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgYWxpZ25lZDogYWxpZ25lZCxcbiAgICAgICAgICAgICAgICBoYXNBeGVzOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VyaWVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBlcmNlbnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBheGVzRGF0YSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF91cGRhdGVQZXJjZW50VmFsdWVzOiBmdW5jdGlvbihheGVzRGF0YSkge1xuICAgICAgICB2YXIgY2hhcnRUeXBlcyA9IHRoaXMuY2hhcnRUeXBlcyB8fCBbdGhpcy5jaGFydFR5cGVdLFxuICAgICAgICAgICAgbGltaXRNYXAgPSB0aGlzLl9nZXRMaW1pdE1hcChheGVzRGF0YSwgY2hhcnRUeXBlcyksXG4gICAgICAgICAgICBzdGFja2VkT3B0aW9uID0gdGhpcy5vcHRpb25zLnNlcmllcyAmJiB0aGlzLm9wdGlvbnMuc2VyaWVzLnN0YWNrZWQ7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5yZWdpc3RlclBlcmNlbnRWYWx1ZXMobGltaXRNYXBbY2hhcnRUeXBlXSwgc3RhY2tlZE9wdGlvbiwgY2hhcnRUeXBlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmVuZGVyaW5nIGRhdGEgZm9yIGF4aXMgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhlc0RhdGEgYXhlc0RhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlUmVuZGVyaW5nRGF0YTogZnVuY3Rpb24oYXhlc0RhdGEpIHtcbiAgICAgICAgdmFyIG9wdGlvbkNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXSxcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSB0aGlzLl9tYWtlU2VyaWVzRGF0YUZvclJlbmRlcmluZyhheGVzRGF0YSwgb3B0aW9uQ2hhcnRUeXBlcywgdGhpcy5pc1ZlcnRpY2FsKSxcbiAgICAgICAgICAgIHlBeGlzID0gYXhlc0RhdGEueUF4aXMgPyBheGVzRGF0YS55QXhpcyA6IGF4ZXNEYXRhLnJpZ2h0WUF4aXM7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwbG90OiB7XG4gICAgICAgICAgICAgICAgdlRpY2tDb3VudDogeUF4aXMudmFsaWRUaWNrQ291bnQsXG4gICAgICAgICAgICAgICAgaFRpY2tDb3VudDogYXhlc0RhdGEueEF4aXMudmFsaWRUaWNrQ291bnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdXN0b21FdmVudDoge1xuICAgICAgICAgICAgICAgIHRpY2tDb3VudDogdGhpcy5pc1ZlcnRpY2FsID8gYXhlc0RhdGEueEF4aXMudGlja0NvdW50IDogeUF4aXMudGlja0NvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHNlcmllc0RhdGEsIGF4ZXNEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGdyb3VwZWQgZXZlbnQgaGFuZGxlciBsYXllci5cbiAgICAgKiBAcGFyYW0ge3t5QXhpczogb2JlamN0LCB4QXhpczogb2JqZWN0fX0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JHcm91cFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgR3JvdXBUeXBlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvck5vcm1hbFRvb2x0aXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgUG9pbnRUeXBlQ3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBUb29sdGlwKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRDdXN0b21FdmVudENvbXBvbmVudEZvckdyb3VwVG9vbHRpcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkQ3VzdG9tRXZlbnRDb21wb25lbnRGb3JOb3JtYWxUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIGNvb3JkaW5hdGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gY3VzdG9tRXZlbnQgY3VzdG9tIGV2ZW50IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7VG9vbHRpcH0gdG9vbHRpcCB0b29sdGlwIGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFNlcmllcz59IHNlcmllc2VzIHNlcmllcyBjb21wb25lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnRGb3JHcm91cFRvb2x0aXA6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50LCB0b29sdGlwLCBzZXJpZXNlcykge1xuICAgICAgICBjdXN0b21FdmVudC5vbignc2hvd0dyb3VwVG9vbHRpcCcsIHRvb2x0aXAub25TaG93LCB0b29sdGlwKTtcbiAgICAgICAgY3VzdG9tRXZlbnQub24oJ2hpZGVHcm91cFRvb2x0aXAnLCB0b29sdGlwLm9uSGlkZSwgdG9vbHRpcCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzLm9uU2hvd0dyb3VwVG9vbHRpcExpbmUpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLm9uKCdzaG93R3JvdXBUb29sdGlwTGluZScsIHNlcmllcy5vblNob3dHcm91cFRvb2x0aXBMaW5lLCBzZXJpZXMpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAub24oJ2hpZGVHcm91cFRvb2x0aXBMaW5lJywgc2VyaWVzLm9uSGlkZUdyb3VwVG9vbHRpcExpbmUsIHNlcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sdGlwLm9uKCdzaG93R3JvdXBBbmltYXRpb24nLCBzZXJpZXMub25TaG93R3JvdXBBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICB0b29sdGlwLm9uKCdoaWRlR3JvdXBBbmltYXRpb24nLCBzZXJpZXMub25IaWRlR3JvdXBBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2ZW50IGZvciBub3JtYWwgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBjdXN0b21FdmVudCBjdXN0b20gZXZlbnQgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtUb29sdGlwfSB0b29sdGlwIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtBcnJheS48U2VyaWVzPn0gc2VyaWVzZXMgc2VyaWVzIGNvbXBvbmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudEZvck5vcm1hbFRvb2x0aXA6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50LCB0b29sdGlwLCBzZXJpZXNlcykge1xuICAgICAgICBjdXN0b21FdmVudC5vbignc2hvd1Rvb2x0aXAnLCB0b29sdGlwLm9uU2hvdywgdG9vbHRpcCk7XG4gICAgICAgIGN1c3RvbUV2ZW50Lm9uKCdoaWRlVG9vbHRpcCcsIHRvb2x0aXAub25IaWRlLCB0b29sdGlwKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc2VzLCBmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgIGlmIChzZXJpZXMub25TaG93QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3Nob3cnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyksIHNlcmllcy5vblNob3dBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ2hpZGUnLCBzZXJpZXMuY2hhcnRUeXBlLCAnYW5pbWF0aW9uJyksIHNlcmllcy5vbkhpZGVBbmltYXRpb24sIHNlcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2ZW50IGZvciBzZXJpZXMgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGN1c3RvbUV2ZW50IGN1c3RvbSBldmVudCBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxTZXJpZXM+fSBzZXJpZXNlcyBzZXJpZXMgY29tcG9uZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50Rm9yU2VyaWVzU2VsZWN0aW9uOiBmdW5jdGlvbihjdXN0b21FdmVudCwgc2VyaWVzZXMpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBjdXN0b21FdmVudC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIHNlcmllcy5jaGFydFR5cGUsICdzZXJpZXMnKSwgc2VyaWVzLm9uU2VsZWN0U2VyaWVzLCBzZXJpZXMpO1xuICAgICAgICAgICAgY3VzdG9tRXZlbnQub24ocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCd1bnNlbGVjdCcsIHNlcmllcy5jaGFydFR5cGUsICdzZXJpZXMnKSwgc2VyaWVzLm9uVW5zZWxlY3RTZXJpZXMsIHNlcmllcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pLFxuICAgICAgICAgICAgY3VzdG9tRXZlbnQgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCdjdXN0b21FdmVudCcpLFxuICAgICAgICAgICAgdG9vbHRpcCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKTtcblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMsIHNlcmllc2VzKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNHcm91cFRvb2x0aXApIHtcbiAgICAgICAgICAgIHRoaXMuX2F0dGFjaEN1c3RvbUV2ZW50Rm9yR3JvdXBUb29sdGlwKGN1c3RvbUV2ZW50LCB0b29sdGlwLCBzZXJpZXNlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hDdXN0b21FdmVudEZvck5vcm1hbFRvb2x0aXAoY3VzdG9tRXZlbnQsIHRvb2x0aXAsIHNlcmllc2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2F0dGFjaEN1c3RvbUV2ZW50Rm9yU2VyaWVzU2VsZWN0aW9uKGN1c3RvbUV2ZW50LCBzZXJpZXNlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpc1R5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXIgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICBiYXJUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2JhclR5cGVNaXhlcicpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvYmFyQ2hhcnRTZXJpZXMnKTtcblxudmFyIEJhckNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIEJhckNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQmFyIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIEJhckNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWJhci1jaGFydCc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaGFzIHJpZ2h0IHkgYXhpcyBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNSaWdodFlBeGlzID0gZmFsc2U7XG5cbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICByYXdEYXRhLnNlcmllcyA9IHRoaXMuX21ha2VSYXdTZXJpZXNEYXRhRm9yRGl2ZXJnaW5nKHJhd0RhdGEuc2VyaWVzLCBvcHRpb25zLnNlcmllcy5zdGFja2VkKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgPSBvcHRpb25zLnNlcmllcy5zdGFja2VkIHx8IGNoYXJ0Q29uc3QuU1RBQ0tFRF9OT1JNQUxfVFlQRTtcbiAgICAgICAgICAgIHRoaXMuaGFzUmlnaHRZQXhpcyA9IG9wdGlvbnMueUF4aXMgJiYgdHVpLnV0aWwuaXNBcnJheShvcHRpb25zLnlBeGlzKSAmJiBvcHRpb25zLnlBeGlzLmxlbmd0aCA+IDE7XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGhhc0F4ZXM6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyhvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJvdW5kcyBjaGFydCBib3VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHhBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogdGhpcy5kYXRhUHJvY2Vzc29yLmdldEdyb3VwVmFsdWVzKCksXG4gICAgICAgICAgICAgICAgc2VyaWVzRGltZW5zaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJvdW5kc01ha2VyLm1ha2VTZXJpZXNXaWR0aCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFja2VkT3B0aW9uOiBvcHRpb25zLnNlcmllcy5zdGFja2VkIHx8ICcnLFxuICAgICAgICAgICAgICAgIGRpdmVyZ2luZ09wdGlvbjogb3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucy54QXhpc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VMYWJlbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKCksXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBheGVzRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB4QXhpczogeEF4aXNEYXRhLFxuICAgICAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGFcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYXhlc0RhdGEucmlnaHRZQXhpcyA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgaXNQb3NpdGlvblJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHlBeGlzRGF0YSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJyxcbiAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd4QXhpcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcblxuICAgICAgICBpZiAodGhpcy5oYXNSaWdodFlBeGlzKSB7XG4gICAgICAgICAgICBheGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdyaWdodFlBeGlzJyxcbiAgICAgICAgICAgICAgICBpc0xhYmU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZENvbXBvbmVudHNGb3JBeGlzVHlwZSh7XG4gICAgICAgICAgICBheGVzOiBheGVzLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2JhclNlcmllcycsXG4gICAgICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBTZXJpZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2Ugc2VsZWN0ZWQgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgYm91bmRQYXJhbXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzUmlnaHRZQXhpcykge1xuICAgICAgICAgICAgYm91bmRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlczogWydiYXInLCAnYmFyJ11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLm9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHMuY2FsbCh0aGlzLCBjaGVja2VkTGVnZW5kcywgbnVsbCwgYm91bmRQYXJhbXMpO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKEJhckNoYXJ0KTtcbmJhclR5cGVNaXhlci5taXhpbihCYXJDaGFydCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgYmFyVHlwZU1peGVyIGlzIG1peGVyIG9mIGJhciB0eXBlIGNoYXJ0KGJhciwgY29sdW1uKS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyk7XG5cbi8qKlxuICogYmFyVHlwZU1peGVyIGlzIG1peGVyIG9mIGJhciB0eXBlIGNoYXJ0KGJhciwgY29sdW1uKS5cbiAqIEBtaXhpblxuICovXG52YXIgYmFyVHlwZU1peGVyID0ge1xuXG4gICAgLyoqXG4gICAgICogUGljayBzdGFja3MuXG4gICAgICogQHBhcmFtIHtBcnJheS48e3N0YWNrOiBzdHJpbmd9Pn0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IHN0YWNrc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tTdGFja3M6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHN0YWNrcztcblxuICAgICAgICBzdGFja3MgPSB0dWkudXRpbC5tYXAocmF3U2VyaWVzRGF0YSwgZnVuY3Rpb24oc2VyaWVzRGF0dW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpZXNEYXR1bS5zdGFjaztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RhY2tzID0gdHVpLnV0aWwuZmlsdGVyKHN0YWNrcywgZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgICAgIHJldHVybiAhIXN0YWNrO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja3MgPSB0dWkudXRpbC51bmlxdWUoc3RhY2tzKS5zbGljZSgwLCAyKTtcblxuICAgICAgICByZXR1cm4gc3RhY2tzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG1pbnVzIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBkYXRhIG51bWJlciBkYXRhXG4gICAgICogQHJldHVybnMge0FycmF5fSBtaW51cyB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTWludXNWYWx1ZXM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChkYXRhLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IDAgOiAtdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBsdXMgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRhdGEgbnVtYmVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBsdXMgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBsdXNWYWx1ZXM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChkYXRhLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugbm9ybWFsIGRpdmVyZ2luZyByYXcgc2VyaWVzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7ZGF0YTogQXJyYXkuPG51bWJlcj59fSByYXdTZXJpZXNEYXRhIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHt7ZGF0YTogQXJyYXkuPG51bWJlcj59fSBjaGFuZ2VkIHJhdyBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxEaXZlcmdpbmdSYXdTZXJpZXNEYXRhOiBmdW5jdGlvbihyYXdTZXJpZXNEYXRhKSB7XG4gICAgICAgIHJhd1Nlcmllc0RhdGEubGVuZ3RoID0gTWF0aC5taW4ocmF3U2VyaWVzRGF0YS5sZW5ndGgsIDIpO1xuXG4gICAgICAgIHJhd1Nlcmllc0RhdGFbMF0uZGF0YSA9IHRoaXMuX21ha2VNaW51c1ZhbHVlcyhyYXdTZXJpZXNEYXRhWzBdLmRhdGEpO1xuXG4gICAgICAgIGlmIChyYXdTZXJpZXNEYXRhWzFdKSB7XG4gICAgICAgICAgICByYXdTZXJpZXNEYXRhWzFdLmRhdGEgPSB0aGlzLl9tYWtlUGx1c1ZhbHVlcyhyYXdTZXJpZXNEYXRhWzFdLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhd1Nlcmllc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tlZCBkaXZlcmdpbmcgcmF3IHNlcmllcyBkYXRhLlxuICAgICAqIEBwYXJhbSB7e2RhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogc3RyaW5nfX0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7e2RhdGE6IEFycmF5LjxudW1iZXI+fX0gY2hhbmdlZCByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZERpdmVyZ2luZ1Jhd1Nlcmllc0RhdGE6IGZ1bmN0aW9uKHJhd1Nlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgc3RhY2tzID0gdGhpcy5fcGlja1N0YWNrcyhyYXdTZXJpZXNEYXRhKSxcbiAgICAgICAgICAgIGxlZnRTdGFjayA9IHN0YWNrc1swXSxcbiAgICAgICAgICAgIHJpZ2h0U3RhY2sgPSBzdGFja3NbMV07XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJhd1Nlcmllc0RhdGEsIGZ1bmN0aW9uKHNlcmllc0RhdHVtKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWVzRGF0dW0uc3RhY2sgPT09IGxlZnRTdGFjaykge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdHVtLmRhdGEgPSB0aGlzLl9tYWtlTWludXNWYWx1ZXMoc2VyaWVzRGF0dW0uZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VyaWVzRGF0dW0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXJpZXNEYXR1bS5zdGFjayA9PT0gcmlnaHRTdGFjaykge1xuICAgICAgICAgICAgICAgIHNlcmllc0RhdHVtLmRhdGEgPSB0aGlzLl9tYWtlUGx1c1ZhbHVlcyhzZXJpZXNEYXR1bS5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZXJpZXNEYXR1bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJhdyBzZXJpZXMgZGF0YSBmb3IgZGl2ZXJnaW5nLlxuICAgICAqIEBwYXJhbSB7e2RhdGE6IEFycmF5LjxudW1iZXI+LCBzdGFjazogc3RyaW5nfX0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHN0YWNrZWRPcHRpb24gc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7e2RhdGE6IEFycmF5LjxudW1iZXI+fX0gY2hhbmdlZCByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmF3U2VyaWVzRGF0YUZvckRpdmVyZ2luZzogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgc3RhY2tlZE9wdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlLmlzVmFsaWRTdGFja2VkT3B0aW9uKHN0YWNrZWRPcHRpb24pKSB7XG4gICAgICAgICAgICByYXdTZXJpZXNEYXRhID0gdGhpcy5fbWFrZVN0YWNrZWREaXZlcmdpbmdSYXdTZXJpZXNEYXRhKHJhd1Nlcmllc0RhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmF3U2VyaWVzRGF0YSA9IHRoaXMuX21ha2VOb3JtYWxEaXZlcmdpbmdSYXdTZXJpZXNEYXRhKHJhd1Nlcmllc0RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhd1Nlcmllc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFyVHlwZU1peGVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoYXJ0QmFzZVxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIERlZmF1bHREYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vaGVscGVycy9kYXRhUHJvY2Vzc29yJyksXG4gICAgQm91bmRzTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2JvdW5kc01ha2VyJyksXG4gICAgQ29tcG9uZW50TWFuYWdlciA9IHJlcXVpcmUoJy4vY29tcG9uZW50TWFuYWdlcicpLFxuICAgIFVzZXJFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnLi4vaGVscGVycy91c2VyRXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgQ2hhcnRCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDaGFydEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDaGFydCBiYXNlLlxuICAgICAqIEBjb25zdHJ1Y3RzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5yYXdEYXRhIHJhdyBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaGFzQXhlcyB3aGV0aGVyIGhhcyBheGVzIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHtEYXRhUHJvY2Vzc29yfSBwYXJhbXMuRGF0YVByb2Nlc3NvciBEYXRhUHJvY2Vzc29yXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByYXcgZGF0YS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmF3RGF0YSA9IHBhcmFtcy5yYXdEYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gdGhpcy5vcHRpb25zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgYXhlcyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0F4ZXMgPSBwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSAhIXBhcmFtcy5pc1ZlcnRpY2FsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIGNoYXJ0IGhhcyBncm91cCB0b29sdGlwIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzR3JvdXBUb29sdGlwID0gISF0dWkudXRpbC5waWNrKHRoaXMub3B0aW9ucywgJ3Rvb2x0aXAnLCAnZ3JvdXBlZCcpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkYXRhIHByb2Nlc3NvclxuICAgICAgICAgKiBAdHlwZSB7RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHRoaXMuX2NyZWF0ZURhdGFQcm9jZXNzb3IocGFyYW1zLkRhdGFQcm9jZXNzb3IgfHwgRGVmYXVsdERhdGFQcm9jZXNzb3IsIHBhcmFtcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gbmV3IEJvdW5kc01ha2VyKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgZGF0YVByb2Nlc3NvcjogdGhpcy5kYXRhUHJvY2Vzc29yLFxuICAgICAgICAgICAgaGFzQXhlczogdGhpcy5oYXNBeGVzLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29tcG9uZW50IG1hbmFnZXJcbiAgICAgICAgICogQHR5cGUge0NvbXBvbmVudE1hbmFnZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIgPSBuZXcgQ29tcG9uZW50TWFuYWdlcih7XG4gICAgICAgICAgICBkYXRhUHJvY2Vzc29yOiB0aGlzLmRhdGFQcm9jZXNzb3IsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgICAgICAgIGJvdW5kc01ha2VyOiB0aGlzLmJvdW5kc01ha2VyLFxuICAgICAgICAgICAgaGFzQXhlczogdGhpcy5oYXNBeGVzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VyIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJFdmVudCA9IG5ldyBVc2VyRXZlbnRMaXN0ZW5lcigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcmlnaW5hbCB3aG9sZSBsZWdlbmQgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG9iamVjdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yZ1dob2xlTGVnZW5kRGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRXaG9sZUxlZ2VuZERhdGEoKTtcblxuICAgICAgICB0aGlzLl9hZGRDdXN0b21FdmVudENvbXBvbmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZGF0YVByb2Nlc3Nvci5cbiAgICAgKiBAcGFyYW0ge0RhdGFQcm9jZXNzb3J9IERhdGFQcm9jZXNzb3IgRGF0YVByb2Nlc3NvciBjbGFzc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtcyB7b2JqZWN0fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogICAgICBAcGFyYW1zIHt7Y2hhcnQ6IG9iamVjdCwgY2hhcnRUeXBlOiBzdHJpbmd9fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbXMge0FycmF5fSBzZXJpZXNDaGFydFR5cGVzIHNlcmllcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGRhdGEgcHJvY2Vzc29yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlRGF0YVByb2Nlc3NvcjogZnVuY3Rpb24oRGF0YVByb2Nlc3NvciwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkYXRhUHJvY2Vzc29yID0gbmV3IERhdGFQcm9jZXNzb3IocGFyYW1zLnJhd0RhdGEpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXG4gICAgICAgIGRhdGFQcm9jZXNzb3IucHJvY2VzcyhwYXJhbXMucmF3RGF0YSwgb3B0aW9ucywgcGFyYW1zLnNlcmllc0NoYXJ0VHlwZXMpO1xuICAgICAgICByZXR1cm4gZGF0YVByb2Nlc3NvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkYXRhIGZvciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0b29sdGlwIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGZvciBheGlzIHR5cGUgY2hhcnQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVuZGVyaW5nIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZuZXQuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gc2VyaWVzZXMgc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hDdXN0b21FdmVudDogZnVuY3Rpb24oc2VyaWVzZXMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ2xlZ2VuZCcpO1xuXG4gICAgICAgIHNlcmllc2VzID0gc2VyaWVzZXMgfHwgdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIGlmIChsZWdlbmQpIHtcbiAgICAgICAgICAgIGxlZ2VuZC5vbignY2hhbmdlQ2hlY2tlZExlZ2VuZHMnLCB0aGlzLm9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHMsIHRoaXMpO1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24gKHNlcmllcykge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC5vbihyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIHNlcmllcy5jaGFydFR5cGUsICdsZWdlbmQnKSwgc2VyaWVzLm9uU2VsZWN0TGVnZW5kLCBzZXJpZXMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGVzIGRhdGEuXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBlcmNlbnQgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX3VwZGF0ZVBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGNvbXBvbmVudCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWUgZnVuY3Rpb24gbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4ZWN1dGVDb21wb25lbnRGdW5jOiBmdW5jdGlvbihmdW5jTmFtZSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZWFjaChmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRbZnVuY05hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50W2Z1bmNOYW1lXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgYXhlc0RhdGEsIHJlbmRlcmluZ0RhdGE7XG5cbiAgICAgICAgdGhpcy5fZXhlY3V0ZUNvbXBvbmVudEZ1bmMoJ3JlZ2lzdGVyRGltZW5zaW9uJyk7XG4gICAgICAgIGF4ZXNEYXRhID0gdGhpcy5fbWFrZUF4ZXNEYXRhKCk7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJBeGVzRGF0YShheGVzRGF0YSk7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVDb21wb25lbnRGdW5jKCdyZWdpc3RlckFkZGl0aW9uYWxEaW1lbnNpb24nKTtcbiAgICAgICAgdGhpcy5ib3VuZHNNYWtlci5yZWdpc3RlckJvdW5kc0RhdGEoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGVyY2VudFZhbHVlcyhheGVzRGF0YSk7XG4gICAgICAgIHJlbmRlcmluZ0RhdGEgPSB0aGlzLl9tYWtlUmVuZGVyaW5nRGF0YShheGVzRGF0YSk7XG5cbiAgICAgICAgY2FsbGJhY2socmVuZGVyaW5nRGF0YSk7XG5cbiAgICAgICAgdGhpcy5fc2VuZFNlcmllc0RhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGNoYXJ0LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY2hhcnQgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKSxcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbCwgJ3R1aS1jaGFydCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUaXRsZShlbCk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGVsLCB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKSk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyQmFja2dyb3VuZChlbCwgdGhpcy50aGVtZS5jaGFydC5iYWNrZ3JvdW5kKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJGb250RmFtaWx5KGVsLCB0aGlzLnRoZW1lLmNoYXJ0LmZvbnRGYW1pbHkpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICB0aGF0Ll9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZW5kZXInLCBlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaEN1c3RvbUV2ZW50KCk7XG4gICAgICAgIHRoaXMuY2hhcnRDb250YWluZXIgPSBlbDtcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciByYXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPD9ib29sZWFuPiB8IHtsaW5lOiA/QXJyYXkuPGJvb2xlYW4+LCBjb2x1bW46ID9BcnJheS48Ym9vbGVhbj59fSBjaGVja2VkTGVnZW5kcyBjaGVja2VkIGxlZ2VuZHNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXdEYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyUmF3RGF0YTogZnVuY3Rpb24ocmF3RGF0YSwgY2hlY2tlZExlZ2VuZHMpIHtcbiAgICAgICAgdmFyIGNsb25lRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmF3RGF0YSkpO1xuXG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KGNsb25lRGF0YS5zZXJpZXMpKSB7XG4gICAgICAgICAgICBjbG9uZURhdGEuc2VyaWVzID0gdHVpLnV0aWwuZmlsdGVyKGNsb25lRGF0YS5zZXJpZXMsIGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tlZExlZ2VuZHNbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGNsb25lRGF0YS5zZXJpZXMsIGZ1bmN0aW9uKHNlcmllc2VzLCBjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRMZWdlbmRzW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVEYXRhLnNlcmllc1tjaGFydFR5cGVdID0gW107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja2VkTGVnZW5kc1tjaGFydFR5cGVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZURhdGEuc2VyaWVzW2NoYXJ0VHlwZV0gPSB0dWkudXRpbC5maWx0ZXIoc2VyaWVzZXMsIGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja2VkTGVnZW5kc1tjaGFydFR5cGVdW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmVEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlcmVuZGVyaW5nIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlbmRlcmluZ0RhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljw/Ym9vbGVhbj4gfCB7bGluZTogP0FycmF5Ljxib29sZWFuPiwgY29sdW1uOiA/QXJyYXkuPGJvb2xlYW4+fX0gY2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVyZW5kZXJpbmdEYXRhOiBmdW5jdGlvbihyZW5kZXJpbmdEYXRhLCBjaGVja2VkTGVnZW5kcykge1xuICAgICAgICB2YXIgdG9vbHRpcERhdGEgPSB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKSxcbiAgICAgICAgICAgIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHJlbmRlcmluZ0RhdGEudG9vbHRpcCA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjaGVja2VkTGVnZW5kczogY2hlY2tlZExlZ2VuZHNcbiAgICAgICAgfSwgdG9vbHRpcERhdGEsIHJlbmRlcmluZ0RhdGEudG9vbHRpcCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICByZW5kZXJpbmdEYXRhW3Nlcmllcy5uYW1lXSA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgY2hlY2tlZExlZ2VuZHM6IGNoZWNrZWRMZWdlbmRzW3Nlcmllcy5jaGFydFR5cGVdIHx8IGNoZWNrZWRMZWdlbmRzXG4gICAgICAgICAgICB9LCByZW5kZXJpbmdEYXRhW3Nlcmllcy5uYW1lXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJpbmdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljw/Ym9vbGVhbj4gfCB7bGluZTogP0FycmF5Ljxib29sZWFuPiwgY29sdW1uOiA/QXJyYXkuPGJvb2xlYW4+fX0gY2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSByYXdEYXRhIHJhd0RhdGFcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGJvdW5kc1BhcmFtcyBhZGRpdGlvbiBwYXJhbXMgZm9yIGNhbGN1bGF0aW5nIGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlcmVuZGVyOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBuZXdXaG9sZUxlZ2VuZERhdGE7XG5cbiAgICAgICAgcmF3RGF0YSA9IHJhd0RhdGEgfHwgdGhpcy5fZmlsdGVyUmF3RGF0YSh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0UmF3RGF0YSgpLCBjaGVja2VkTGVnZW5kcyk7XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLnByb2Nlc3MocmF3RGF0YSwgdGhpcy5vcHRpb25zLCB0aGlzLnNlcmllc0NoYXJ0VHlwZXMpO1xuXG4gICAgICAgIG5ld1dob2xlTGVnZW5kRGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRXaG9sZUxlZ2VuZERhdGEoKTtcbiAgICAgICAgLy8g67KU66GAIOyYgeyXreydgCDrs4Dqsr3rkJjsp4Ag7JWK7Jy866+A66GcLCBib3VuZHMg6rOE7IKw7JeQ64qUIOuzgOqyveuQmOyngCDslYrsnYAg66CI7J2067iUIOuNsOydtO2EsOulvCDtj6ztlajtlbTslbwg7ZWoXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3Nvci5zZXRXaG9sZUxlZ2VuZERhdGEodGhpcy5vcmdXaG9sZUxlZ2VuZERhdGEpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIuaW5pdEJvdW5kc0RhdGEoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyKGZ1bmN0aW9uKHJlbmRlcmluZ0RhdGEpIHtcbiAgICAgICAgICAgIHJlbmRlcmluZ0RhdGEgPSB0aGF0Ll9tYWtlUmVyZW5kZXJpbmdEYXRhKHJlbmRlcmluZ0RhdGEsIGNoZWNrZWRMZWdlbmRzKTtcbiAgICAgICAgICAgIHRoYXQuZGF0YVByb2Nlc3Nvci5zZXRXaG9sZUxlZ2VuZERhdGEobmV3V2hvbGVMZWdlbmREYXRhKTtcbiAgICAgICAgICAgIHRoYXQuX3JlbmRlckNvbXBvbmVudHMocmVuZGVyaW5nRGF0YSwgJ3JlcmVuZGVyJyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjaGFuZ2UgY2hlY2tlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcmF3RGF0YSByYXdEYXRhXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBib3VuZHNQYXJhbXMgYWRkaXRpb24gcGFyYW1zIGZvciBjYWxjdWxhdGluZyBib3VuZHNcbiAgICAgKi9cbiAgICBvbkNoYW5nZUNoZWNrZWRMZWdlbmRzOiBmdW5jdGlvbihjaGVja2VkTGVnZW5kcywgcmF3RGF0YSwgYm91bmRzUGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX3JlcmVuZGVyKGNoZWNrZWRMZWdlbmRzLCByYXdEYXRhLCBib3VuZHNQYXJhbXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGl0bGUuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJUaXRsZTogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgdmFyIGNoYXJ0T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jaGFydCB8fCB7fSxcbiAgICAgICAgICAgIGVsVGl0bGUgPSByZW5kZXJVdGlsLnJlbmRlclRpdGxlKGNoYXJ0T3B0aW9ucy50aXRsZSwgdGhpcy50aGVtZS50aXRsZSwgJ3R1aS1jaGFydC10aXRsZScpO1xuXG4gICAgICAgIGRvbS5hcHBlbmQoZWwsIGVsVGl0bGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgY29tcG9uZW50cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVuZGVyaW5nRGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWUgZnVuY3Rpb24gbmFtZSBmb3IgZXhlY3V0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29tcG9uZW50czogZnVuY3Rpb24ocmVuZGVyaW5nRGF0YSwgZnVuY05hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmNvbXBvbmVudE1hbmFnZXIubWFwKGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZW5kZXJpbmdEYXRhW2NvbXBvbmVudC5uYW1lXSxcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFtmdW5jTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gY29tcG9uZW50W2Z1bmNOYW1lXShkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQoY29udGFpbmVyLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBzZXJpZXMgZGF0YSB0byBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbmRTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIHNlcmllc0luZm9zLCBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghY3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJ0VHlwZXMgPSB0aGlzLmNoYXJ0VHlwZXMgfHwgW3RoaXMuY2hhcnRUeXBlXTtcbiAgICAgICAgc2VyaWVzSW5mb3MgPSB0dWkudXRpbC5tYXAoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldChjaGFydFR5cGUgKyAnU2VyaWVzJykgfHwgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnc2VyaWVzJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY29tcG9uZW50LmdldFNlcmllc0RhdGEoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgY3VzdG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50RGF0YShzZXJpZXNJbmZvcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZXZlbnQgbmFtZSBmb3IgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggcHJlZml4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXZlbnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VBbmltYXRpb25FdmVudE5hbWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSwgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBjaGFydFR5cGUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBjaGFydFR5cGUuc3Vic3RyaW5nKDEpICsgJ0FuaW1hdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY2hhcnQuXG4gICAgICovXG4gICAgYW5pbWF0ZUNoYXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmFuaW1hdGVDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYW5pbWF0ZUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgb2YgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIGV2ZW50IGNhbGxiYWNrXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5yZWdpc3RlcihldmVudE5hbWUsIGZ1bmMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHVwZGF0ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlRGltZW5zaW9uOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZGltZW5zaW9uLndpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2hhcnQud2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1lbnNpb24uaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY2hhcnQuaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBBUEkgZm9yIHJlc2l6YWJsZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRpbWVuc2lvbi53aWR0aCB3aWR0aFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRpbWVuc2lvbi5oZWlnaHQgaGVpZ2h0XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIHVwZGF0ZWQ7XG5cbiAgICAgICAgaWYgKCFkaW1lbnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZWQgPSB0aGlzLl91cGRhdGVEaW1lbnNpb24oZGltZW5zaW9uKTtcblxuICAgICAgICBpZiAoIXVwZGF0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIuaW5pdEJvdW5kc0RhdGEodGhpcy5vcHRpb25zLmNoYXJ0KTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5jaGFydENvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0JykpO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcihmdW5jdGlvbihyZW5kZXJpbmdEYXRhKSB7XG4gICAgICAgICAgICB0aGF0Ll9yZW5kZXJDb21wb25lbnRzKHJlbmRlcmluZ0RhdGEsICdyZXNpemUnKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gYWxpZ24gKGxlZnR8Y2VudGVyfHJpZ2h0LCB0b3B8bWlkZGxlfGJvdHRvbSlcbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgc2V0VG9vbHRpcEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykuc2V0QWxpZ24oYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgcG9zaXRpb24gb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiBtb3ZpbmcgcG9zaXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi5sZWZ0IGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbi50b3AgdG9wXG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHNldFRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBhbGlnbiBvcHRpb24uXG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHJlc2V0VG9vbHRpcEFsaWduOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLnJlc2V0QWxpZ24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgcmVzZXRUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIuZ2V0KCd0b29sdGlwJykucmVzZXRQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHNlcmllcyBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgc2hvd1Nlcmllc0xhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBzZXJpZXMuc2hvd0xhYmVsKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgaGlkZVNlcmllc0xhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc2VzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLndoZXJlKHtjb21wb25lbnRUeXBlOiAnc2VyaWVzJ30pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNlcywgZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICBzZXJpZXMuaGlkZUxhYmVsKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0QmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb2x1bW4gY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICBiYXJUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2JhclR5cGVNaXhlcicpLFxuICAgIGF4aXNEYXRhTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2F4aXNEYXRhTWFrZXInKSxcbiAgICBTZXJpZXMgPSByZXF1aXJlKCcuLi9zZXJpZXMvY29sdW1uQ2hhcnRTZXJpZXMnKTtcblxudmFyIENvbHVtbkNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIENvbHVtbkNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIENvbHVtbkNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAbWl4ZXMgdmVydGljYWxUeXBlTWl4ZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluaXRlZERhdGEgaW5pdGlhbGl6ZWQgZGF0YSBmcm9tIGNvbWJvIGNoYXJ0XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNvbHVtbi1jaGFydCc7XG5cbiAgICAgICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICByYXdEYXRhLnNlcmllcyA9IHRoaXMuX21ha2VSYXdTZXJpZXNEYXRhRm9yRGl2ZXJnaW5nKHJhd0RhdGEuc2VyaWVzLCBvcHRpb25zLnNlcmllcy5zdGFja2VkKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2VyaWVzLnN0YWNrZWQgPSBvcHRpb25zLnNlcmllcy5zdGFja2VkIHx8IGNoYXJ0Q29uc3QuU1RBQ0tFRF9OT1JNQUxfVFlQRTtcbiAgICAgICAgfVxuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyhvcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB4QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VMYWJlbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKCksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucy54QXhpc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VWYWx1ZUF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRHcm91cFZhbHVlcygpLFxuICAgICAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm91bmRzTWFrZXIubWFrZVNlcmllc0hlaWdodCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdGFja2VkT3B0aW9uOiBvcHRpb25zLnNlcmllcy5zdGFja2VkIHx8ICcnLFxuICAgICAgICAgICAgICAgIGRpdmVyZ2luZ09wdGlvbjogb3B0aW9ucy5zZXJpZXMuZGl2ZXJnaW5nLFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucy55QXhpcyxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeEF4aXM6IHhBeGlzRGF0YSxcbiAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGFcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGF4ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICd5QXhpcydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3hBeGlzJyxcbiAgICAgICAgICAgICAgICAgICAgaXNMYWJlbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHNlcmllc2VzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY29sdW1uU2VyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IFNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbmF4aXNUeXBlTWl4ZXIubWl4aW4oQ29sdW1uQ2hhcnQpO1xuYmFyVHlwZU1peGVyLm1peGluKENvbHVtbkNoYXJ0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5DaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBDb21ibyBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKSxcbiAgICBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGF4aXNUeXBlTWl4ZXIgPSByZXF1aXJlKCcuL2F4aXNUeXBlTWl4ZXInKSxcbiAgICBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgZGVmYXVsdFRoZW1lID0gcmVxdWlyZSgnLi4vdGhlbWVzL2RlZmF1bHRUaGVtZScpLFxuICAgIENvbHVtbkNoYXJ0U2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2NvbHVtbkNoYXJ0U2VyaWVzJyksXG4gICAgTGluZUNoYXJ0U2VyaWVzID0gcmVxdWlyZSgnLi4vc2VyaWVzL2xpbmVDaGFydFNlcmllcycpO1xuXG52YXIgQ29tYm9DaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBDb21ib0NoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29tYm8gY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgQ29tYm9DaGFydFxuICAgICAqIEBleHRlbmRzIENoYXJ0QmFzZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBjaGFydCB0aGVtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihyYXdEYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2hhcnRUeXBlc01hcDtcblxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY29tYm8tY2hhcnQnO1xuXG4gICAgICAgIGNoYXJ0VHlwZXNNYXAgPSB0aGlzLl9tYWtlQ2hhcnRUeXBlc01hcChyYXdEYXRhLnNlcmllcywgb3B0aW9ucy55QXhpcyk7XG5cbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIGNoYXJ0VHlwZXNNYXApO1xuXG4gICAgICAgIENoYXJ0QmFzZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIHJhd0RhdGE6IHJhd0RhdGEsXG4gICAgICAgICAgICB0aGVtZTogdGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgaGFzQXhlczogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWUsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzOiBjaGFydFR5cGVzTWFwLnNlcmllc0NoYXJ0VHlwZXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHlBeGlzIG9wdGlvbnMgbWFwXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnlBeGlzT3B0aW9uc01hcCA9IHRoaXMuX21ha2VZQXhpc09wdGlvbnNNYXAoY2hhcnRUeXBlc01hcC5jaGFydFR5cGVzLCBvcHRpb25zLnlBeGlzKTtcbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyhjaGFydFR5cGVzTWFwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5QXhpcyBvcHRpb25zIG1hcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSB5QXhpc09wdGlvbnMgeUF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7Y29sdW1uOiA/b2JqZWN0LCBsaW5lOiA/b2JqZWN0fX0gb3B0aW9ucyBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlWUF4aXNPcHRpb25zTWFwOiBmdW5jdGlvbihjaGFydFR5cGVzLCB5QXhpc09wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdGlvbk1hcCA9IHt9O1xuICAgICAgICB5QXhpc09wdGlvbnMgPSB5QXhpc09wdGlvbnMgfHwge307XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUsIGluZGV4KSB7XG4gICAgICAgICAgICBvcHRpb25NYXBbY2hhcnRUeXBlXSA9IHlBeGlzT3B0aW9uc1tpbmRleF0gfHwgeUF4aXNPcHRpb25zO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3B0aW9uTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNoYXJ0IHR5cGVzIG1hcC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geUF4aXNPcHRpb24gb3B0aW9uIGZvciB5IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCB0eXBlcyBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ2hhcnRUeXBlc01hcDogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgeUF4aXNPcHRpb24pIHtcbiAgICAgICAgdmFyIHNlcmllc0NoYXJ0VHlwZXMgPSB0dWkudXRpbC5rZXlzKHJhd1Nlcmllc0RhdGEpLnNvcnQoKSxcbiAgICAgICAgICAgIG9wdGlvbkNoYXJ0VHlwZXMgPSB0aGlzLl9nZXRZQXhpc09wdGlvbkNoYXJ0VHlwZXMoc2VyaWVzQ2hhcnRUeXBlcywgeUF4aXNPcHRpb24pLFxuICAgICAgICAgICAgY2hhcnRUeXBlcyA9IG9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoID8gb3B0aW9uQ2hhcnRUeXBlcyA6IHNlcmllc0NoYXJ0VHlwZXMsXG4gICAgICAgICAgICB2YWxpZENoYXJ0VHlwZXMgPSB0dWkudXRpbC5maWx0ZXIob3B0aW9uQ2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhd1Nlcmllc0RhdGFbY2hhcnRUeXBlXS5sZW5ndGg7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZXNNYXA7XG5cbiAgICAgICAgaWYgKHZhbGlkQ2hhcnRUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZXNNYXAgPSB7XG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlczogdmFsaWRDaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZXM6IHZhbGlkQ2hhcnRUeXBlcyxcbiAgICAgICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzOiAhb3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGggPyBvcHRpb25DaGFydFR5cGVzIDogdmFsaWRDaGFydFR5cGVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcnRUeXBlc01hcCA9IHtcbiAgICAgICAgICAgICAgICBjaGFydFR5cGVzOiBjaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZXM6IHNlcmllc0NoYXJ0VHlwZXMsXG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhcnRUeXBlczogb3B0aW9uQ2hhcnRUeXBlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFydFR5cGVzTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG9wdGlvbnMgbWFwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBvcHRpb25zIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VPcHRpb25zTWFwOiBmdW5jdGlvbihjaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciBvcHRpb25zTWFwID0ge307XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgb3B0aW9uc01hcFtjaGFydFR5cGVdID0gdGhpcy5vcHRpb25zLnNlcmllc1tjaGFydFR5cGVdIHx8IHRoaXMub3B0aW9ucy5zZXJpZXM7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRoZW1lIG1hcFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlbWUgbWFwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRoZW1lTWFwOiBmdW5jdGlvbihjaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudGhlbWUsXG4gICAgICAgICAgICB0aGVtZU1hcCA9IHt9LFxuICAgICAgICAgICAgY29sb3JDb3VudCA9IDA7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNoYXJ0VGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSksXG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbG9ycztcblxuICAgICAgICAgICAgaWYgKGNoYXJ0VGhlbWUuc2VyaWVzW2NoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdID0gY2hhcnRUaGVtZS5zZXJpZXNbY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycykge1xuICAgICAgICAgICAgICAgIHRoZW1lTWFwW2NoYXJ0VHlwZV0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZmF1bHRUaGVtZS5zZXJpZXMpKTtcbiAgICAgICAgICAgICAgICB0aGVtZU1hcFtjaGFydFR5cGVdLmxhYmVsLmZvbnRGYW1pbHkgPSBjaGFydFRoZW1lLmNoYXJ0LmZvbnRGYW1pbHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRDb2xvcnMgPSBjaGFydFRoZW1lLnNlcmllcy5jb2xvcnMuc3BsaWNlKDAsIGNvbG9yQ291bnQpO1xuICAgICAgICAgICAgICAgIGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycyA9IGNoYXJ0VGhlbWUuc2VyaWVzLmNvbG9ycy5jb25jYXQocmVtb3ZlZENvbG9ycyk7XG4gICAgICAgICAgICAgICAgdGhlbWVNYXBbY2hhcnRUeXBlXSA9IGNoYXJ0VGhlbWUuc2VyaWVzO1xuICAgICAgICAgICAgICAgIGNvbG9yQ291bnQgKz0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscyhjaGFydFR5cGUpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoZW1lTWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllc2VzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gc2VyaWVzZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIHNlcmllc0NsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBDb2x1bW5DaGFydFNlcmllcyxcbiAgICAgICAgICAgICAgICBsaW5lOiBMaW5lQ2hhcnRTZXJpZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25zTWFwID0gdGhpcy5fbWFrZU9wdGlvbnNNYXAoY2hhcnRUeXBlcyksXG4gICAgICAgICAgICB0aGVtZU1hcCA9IHRoaXMuX21ha2VUaGVtZU1hcChjaGFydFR5cGVzKSxcbiAgICAgICAgICAgIHNlcmllc2VzO1xuXG4gICAgICAgIHNlcmllc2VzID0gdHVpLnV0aWwubWFwKGNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZVRvb2x0aXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogJ3NlcmllcycsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc01hcFtjaGFydFR5cGVdLFxuICAgICAgICAgICAgICAgIHRoZW1lOiB0aGVtZU1hcFtjaGFydFR5cGVdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGNoYXJ0VHlwZSArICdTZXJpZXMnLFxuICAgICAgICAgICAgICAgIFNlcmllc0NsYXNzOiBzZXJpZXNDbGFzc2VzW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNlcmllc2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydFR5cGVzTWFwIGNoYXJ0IHR5cGVzIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZXNNYXApIHtcbiAgICAgICAgdmFyIGF4ZXMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneUF4aXMnLFxuICAgICAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZXNNYXAuY2hhcnRUeXBlc1swXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHNlcmllc2VzID0gdGhpcy5fbWFrZVNlcmllc2VzKGNoYXJ0VHlwZXNNYXAuc2VyaWVzQ2hhcnRUeXBlcyk7XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZXNNYXAub3B0aW9uQ2hhcnRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF4ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3JpZ2h0WUF4aXMnLFxuICAgICAgICAgICAgICAgIGlzTGFiZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGVzTWFwLmNoYXJ0VHlwZXNbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50c0ZvckF4aXNUeXBlKHtcbiAgICAgICAgICAgIGF4ZXM6IGF4ZXMsXG4gICAgICAgICAgICBzZXJpZXNDaGFydFR5cGVzOiBjaGFydFR5cGVzTWFwLnNlcmllc0NoYXJ0VHlwZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMub3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICBzZXJpZXNlczogc2VyaWVzZXNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB5IGF4aXMgb3B0aW9uIGNoYXJ0IHR5cGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geUF4aXNPcHRpb25zIHkgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBjaGFydCB0eXBlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFlBeGlzT3B0aW9uQ2hhcnRUeXBlczogZnVuY3Rpb24oY2hhcnRUeXBlcywgeUF4aXNPcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHRDaGFydFR5cGVzID0gY2hhcnRUeXBlcy5zbGljZSgpLFxuICAgICAgICAgICAgaXNSZXZlcnNlID0gZmFsc2UsXG4gICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzO1xuXG4gICAgICAgIHlBeGlzT3B0aW9ucyA9IHlBeGlzT3B0aW9ucyA/IFtdLmNvbmNhdCh5QXhpc09wdGlvbnMpIDogW107XG5cbiAgICAgICAgaWYgKHlBeGlzT3B0aW9ucy5sZW5ndGggPT09IDEgJiYgIXlBeGlzT3B0aW9uc1swXS5jaGFydFR5cGUpIHtcbiAgICAgICAgICAgIHJlc3VsdENoYXJ0VHlwZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmICh5QXhpc09wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvcHRpb25DaGFydFR5cGVzID0gdHVpLnV0aWwubWFwKHlBeGlzT3B0aW9ucywgZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5jaGFydFR5cGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KG9wdGlvbkNoYXJ0VHlwZXMsIGZ1bmN0aW9uKGNoYXJ0VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpc1JldmVyc2UgPSBpc1JldmVyc2UgfHwgKGNoYXJ0VHlwZSAmJiByZXN1bHRDaGFydFR5cGVzW2luZGV4XSAhPT0gY2hhcnRUeXBlIHx8IGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Q2hhcnRUeXBlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0Q2hhcnRUeXBlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGF4aXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuaW5kZXggY2hhcnQgaW5kZXhcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLnNlcmllc0RpbWVuc2lvbiBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjaGFydFR5cGVzIGNoYXJ0IHR5cGVcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gaXNPbmVZQXhpcyB3aGV0aGVyIG9uZSBzZXJpZXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gYWRkUGFyYW1zIGFkZCBwYXJhbXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB5IGF4aXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICBjaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlc1tpbmRleF0sXG4gICAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnMsXG4gICAgICAgICAgICB5QXhpc09wdGlvbnMgPSB0aGlzLnlBeGlzT3B0aW9uc01hcFtjaGFydFR5cGVdLFxuICAgICAgICAgICAgeUF4aXNWYWx1ZXMsIHNlcmllc09wdGlvbiwgeUF4aXNEYXRhO1xuXG4gICAgICAgIGlmICghY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmlzT25lWUF4aXMpIHtcbiAgICAgICAgICAgIHlBeGlzVmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFdob2xlR3JvdXBWYWx1ZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlBeGlzVmFsdWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldEdyb3VwVmFsdWVzKGNoYXJ0VHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpZXNPcHRpb24gPSBvcHRpb25zLnNlcmllcyAmJiBvcHRpb25zLnNlcmllc1tjaGFydFR5cGVdIHx8IG9wdGlvbnMuc2VyaWVzO1xuXG4gICAgICAgIHlBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHZhbHVlczogeUF4aXNWYWx1ZXMsXG4gICAgICAgICAgICBzdGFja2VkT3B0aW9uOiBzZXJpZXNPcHRpb24gJiYgc2VyaWVzT3B0aW9uLnN0YWNrZWQgfHwgJycsXG4gICAgICAgICAgICBvcHRpb25zOiB5QXhpc09wdGlvbnMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbjogcGFyYW1zLnNlcmllc0RpbWVuc2lvbixcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9LCBwYXJhbXMuYWRkUGFyYW1zKSk7XG4gICAgICAgIHlBeGlzRGF0YS5vcHRpb25zID0geUF4aXNPcHRpb25zO1xuXG4gICAgICAgIHJldHVybiB5QXhpc0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksXG4gICAgICAgICAgICB5QXhpc1BhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzZXJpZXNEaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmJvdW5kc01ha2VyLm1ha2VTZXJpZXNIZWlnaHQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlczogdGhpcy5jaGFydFR5cGVzLFxuICAgICAgICAgICAgICAgIGlzT25lWUF4aXM6ICF0aGlzLm9wdGlvbkNoYXJ0VHlwZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4QXhpc0RhdGEgPSBheGlzRGF0YU1ha2VyLm1ha2VMYWJlbEF4aXNEYXRhKHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRDYXRlZ29yaWVzKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeUF4aXNEYXRhID0gdGhpcy5fbWFrZVlBeGlzRGF0YSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgICB9LCB5QXhpc1BhcmFtcykpLFxuICAgICAgICAgICAgYXhlc0RhdGEsIHJpZ2h0WUF4aXNEYXRhO1xuXG4gICAgICAgIGF4ZXNEYXRhID0ge1xuICAgICAgICAgICAgeUF4aXM6IHlBeGlzRGF0YSxcbiAgICAgICAgICAgIHhBeGlzOiB4QXhpc0RhdGFcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXlBeGlzUGFyYW1zLmlzT25lWUF4aXMpIHtcbiAgICAgICAgICAgIHJpZ2h0WUF4aXNEYXRhID0gdGhpcy5fbWFrZVlBeGlzRGF0YSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGluZGV4OiAxLFxuICAgICAgICAgICAgICAgIGFkZFBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB5QXhpc1BhcmFtcykpO1xuICAgICAgICAgICAgaWYgKHlBeGlzRGF0YS50aWNrQ291bnQgPCByaWdodFlBeGlzRGF0YS50aWNrQ291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmNyZWFzZVlBeGlzVGlja0NvdW50KHJpZ2h0WUF4aXNEYXRhLnRpY2tDb3VudCAtIHlBeGlzRGF0YS50aWNrQ291bnQsIHlBeGlzRGF0YSwgZm9ybWF0RnVuY3Rpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeUF4aXNEYXRhLnRpY2tDb3VudCA+IHJpZ2h0WUF4aXNEYXRhLnRpY2tDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlYXNlWUF4aXNUaWNrQ291bnQoeUF4aXNEYXRhLnRpY2tDb3VudCAtIHJpZ2h0WUF4aXNEYXRhLnRpY2tDb3VudCwgcmlnaHRZQXhpc0RhdGEsIGZvcm1hdEZ1bmN0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJpZ2h0WUF4aXNEYXRhLmFsaWduZWQgPSB4QXhpc0RhdGEuYWxpZ25lZDtcbiAgICAgICAgICAgIGF4ZXNEYXRhLnJpZ2h0WUF4aXMgPSByaWdodFlBeGlzRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBheGVzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UgeSBheGlzIHRpY2sgY291bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluY3JlYXNlVGlja0NvdW50IGluY3JlYXNlIHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdG9EYXRhIHRvIHRpY2sgaW5mb1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9uPn0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbmNyZWFzZVlBeGlzVGlja0NvdW50OiBmdW5jdGlvbihpbmNyZWFzZVRpY2tDb3VudCwgdG9EYXRhLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgdG9EYXRhLmxpbWl0Lm1heCArPSB0b0RhdGEuc3RlcCAqIGluY3JlYXNlVGlja0NvdW50O1xuICAgICAgICB0b0RhdGEubGFiZWxzID0gYXhpc0RhdGFNYWtlci5mb3JtYXRMYWJlbHMoY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbUxpbWl0KHRvRGF0YS5saW1pdCwgdG9EYXRhLnN0ZXApLCBmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICB0b0RhdGEudGlja0NvdW50ICs9IGluY3JlYXNlVGlja0NvdW50O1xuICAgICAgICB0b0RhdGEudmFsaWRUaWNrQ291bnQgKz0gaW5jcmVhc2VUaWNrQ291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNoYW5nZSBzZWxlY3RlZCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48P2Jvb2xlYW4+IHwge2xpbmU6ID9BcnJheS48Ym9vbGVhbj4sIGNvbHVtbjogP0FycmF5Ljxib29sZWFuPn19IGNoZWNrZWRMZWdlbmRzIGNoZWNrZWQgbGVnZW5kc1xuICAgICAqL1xuICAgIG9uQ2hhbmdlQ2hlY2tlZExlZ2VuZHM6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciByYXdEYXRhID0gdGhpcy5fZmlsdGVyUmF3RGF0YSh0aGlzLnJhd0RhdGEsIGNoZWNrZWRMZWdlbmRzKSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZXNNYXAgPSB0aGlzLl9tYWtlQ2hhcnRUeXBlc01hcChyYXdEYXRhLnNlcmllcywgdGhpcy5vcHRpb25zLnlBeGlzKTtcblxuICAgICAgICB0dWkudXRpbC5leHRlbmQodGhpcywgY2hhcnRUeXBlc01hcCk7XG5cbiAgICAgICAgQ2hhcnRCYXNlLnByb3RvdHlwZS5vbkNoYW5nZUNoZWNrZWRMZWdlbmRzLmNhbGwodGhpcywgY2hlY2tlZExlZ2VuZHMsIHJhd0RhdGEsIGNoYXJ0VHlwZXNNYXApO1xuICAgIH1cbn0pO1xuXG5heGlzVHlwZU1peGVyLm1peGluKENvbWJvQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJvQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcG9uZW50TWFuYWdlciBtYW5hZ2VzIGNvbXBvbmVudHMgb2YgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21wb25lbnRNYW5hZ2VyID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDb21wb25lbnRNYW5hZ2VyLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50TWFuYWdlciBtYW5hZ2VzIGNvbXBvbmVudHMgb2YgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtEYXRhUHJvY2Vzc29yfSBwYXJhbXMuZGF0YVByb2Nlc3NvciBkYXRhIHByb2Nlc3NvclxuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kcyBtYWtlclxuICAgICAqIEBjb25zdHJ1Y3RzIENvbXBvbmVudE1hbmFnZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudHNcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxvYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBvbmVudCBtYXAuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hcCA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogb3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGV0aGVyIGNoYXJ0IGhhcyBheGVzIG9yIG5vdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQXhlcyA9IHBhcmFtcy5oYXNBeGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBjb21wb25lbnQuXG4gICAgICogVGhlIGNvbXBvbmVudCByZWZlcnMgdG8gYSBjb21wb25lbnQgb2YgdGhlIGNoYXJ0LlxuICAgICAqIFRoZSBjb21wb25lbnQgdHlwZXMgYXJlIGF4aXMsIGxlZ2VuZCwgcGxvdCwgc2VyaWVzIGFuZCBjdXN0b21FdmVudC5cbiAgICAgKiBDaGFydCBDb21wb25lbnQgRGVzY3JpcHRpb24gOiBodHRwczovL2ktbXNkbi5zZWMucy1tc2Z0LmNvbS9keW5pbWcvSUMyNjc5OTcuZ2lmXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBjb21wb25lbnQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lLCBDb21wb25lbnQsIHBhcmFtcykge1xuICAgICAgICB2YXIgb3B0aW9ucywgaW5kZXgsIHRoZW1lLFxuICAgICAgICAgICAgY29tcG9uZW50LCBjb21wb25lbnRUeXBlO1xuXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgICBjb21wb25lbnRUeXBlID0gcGFyYW1zLmNvbXBvbmVudFR5cGUgfHwgbmFtZTtcbiAgICAgICAgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHRoaXMub3B0aW9uc1tjb21wb25lbnRUeXBlXTtcbiAgICAgICAgdGhlbWUgPSBwYXJhbXMudGhlbWUgfHwgdGhpcy50aGVtZVtjb21wb25lbnRUeXBlXTtcbiAgICAgICAgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcblxuICAgICAgICBwYXJhbXMudGhlbWUgPSB0aGVtZTtcbiAgICAgICAgcGFyYW1zLm9wdGlvbnMgPSB0dWkudXRpbC5pc0FycmF5KG9wdGlvbnMpID8gb3B0aW9uc1tpbmRleF0gOiBvcHRpb25zIHx8IHt9O1xuICAgICAgICBwYXJhbXMuZGF0YVByb2Nlc3NvciA9IHRoaXMuZGF0YVByb2Nlc3NvcjtcbiAgICAgICAgcGFyYW1zLmJvdW5kc01ha2VyID0gdGhpcy5ib3VuZHNNYWtlcjtcbiAgICAgICAgcGFyYW1zLmhhc0F4ZXMgPSB0aGlzLmhhc0F4ZXM7XG5cbiAgICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChwYXJhbXMpO1xuICAgICAgICBjb21wb25lbnQubmFtZSA9IG5hbWU7XG4gICAgICAgIGNvbXBvbmVudC5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hcFtuYW1lXSA9IGNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBlYWNoIGNvbXBvbmVudHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWVcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5jb21wb25lbnRzLCBpdGVyYXRlZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBjb21wb25lbnRzLlxuICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gY29tcG9uZW50c1xuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLmNvbXBvbmVudHMsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBjb21wb25lbnRzIHRvIGNvbmRpdGlvbk1hcC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZGl0aW9uTWFwIGNvbmRpdGlvbiBtYXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IGZpbHRlcmVkIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICB3aGVyZTogZnVuY3Rpb24oY29uZGl0aW9uTWFwKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5maWx0ZXIodGhpcy5jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGNvbmRpdGlvbk1hcCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRba2V5XSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjb21wb25lbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50TWFwW25hbWVdO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudE1hbmFnZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGluZSBjaGFydFxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2hhcnRCYXNlID0gcmVxdWlyZSgnLi9jaGFydEJhc2UnKSxcbiAgICBsaW5lVHlwZU1peGVyID0gcmVxdWlyZSgnLi9saW5lVHlwZU1peGVyJyksXG4gICAgYXhpc1R5cGVNaXhlciA9IHJlcXVpcmUoJy4vYXhpc1R5cGVNaXhlcicpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9saW5lQ2hhcnRTZXJpZXMnKTtcblxudmFyIExpbmVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKENoYXJ0QmFzZSwgLyoqIEBsZW5kcyBMaW5lQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBjbGFzc05hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogJ3R1aS1saW5lLWNoYXJ0JyxcblxuICAgIC8qKlxuICAgICAqIFNlcmllcyBjbGFzc1xuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICBTZXJpZXM6IFNlcmllcyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGluZUNoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQG1peGVzIGF4aXNUeXBlTWl4ZXJcbiAgICAgKiBAbWl4ZXMgdmVydGljYWxUeXBlTWl4ZXJcbiAgICAgKiBAbWl4ZXMgbGluZVR5cGVNaXhlclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9saW5lVHlwZUluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG59KTtcblxuYXhpc1R5cGVNaXhlci5taXhpbihMaW5lQ2hhcnQpO1xubGluZVR5cGVNaXhlci5taXhpbihMaW5lQ2hhcnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBsaW5lVHlwZU1peGVyIGlzIG1peGVyIG9mIGxpbmUgdHlwZSBjaGFydChsaW5lLCBhcmVhKS5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENoYXJ0QmFzZSA9IHJlcXVpcmUoJy4vY2hhcnRCYXNlJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBheGlzRGF0YU1ha2VyID0gcmVxdWlyZSgnLi4vaGVscGVycy9heGlzRGF0YU1ha2VyJyksXG4gICAgQXJlYVR5cGVDdXN0b21FdmVudCA9IHJlcXVpcmUoJy4uL2N1c3RvbUV2ZW50cy9hcmVhVHlwZUN1c3RvbUV2ZW50Jyk7XG5cbi8qKlxuICogbGluZVR5cGVNaXhlciBpcyBtaXhlciBvZiBsaW5lIHR5cGUgY2hhcnQobGluZSwgYXJlYSkuXG4gKiBAbWl4aW5cbiAqL1xudmFyIGxpbmVUeXBlTWl4ZXIgPSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbml0ZWREYXRhIGluaXRpYWxpemVkIGRhdGEgZnJvbSBjb21ibyBjaGFydFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2xpbmVUeXBlSW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBoYXNBeGVzOiB0cnVlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKG9wdGlvbnMuY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBheGVzIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBheGVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQXhlc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgIGFsaWduZWQgPSBwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KG9wdGlvbnMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIHhBeGlzRGF0YSA9IGF4aXNEYXRhTWFrZXIubWFrZUxhYmVsQXhpc0RhdGEoe1xuICAgICAgICAgICAgICAgIGxhYmVsczogdGhpcy5kYXRhUHJvY2Vzc29yLmdldENhdGVnb3JpZXMoKSxcbiAgICAgICAgICAgICAgICBhbGlnbmVkOiBhbGlnbmVkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMueEF4aXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgeUF4aXNEYXRhID0gYXhpc0RhdGFNYWtlci5tYWtlVmFsdWVBeGlzRGF0YSh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0R3JvdXBWYWx1ZXMoKSxcbiAgICAgICAgICAgICAgICBzZXJpZXNEaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmJvdW5kc01ha2VyLm1ha2VTZXJpZXNIZWlnaHQoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhY2tlZE9wdGlvbjogb3B0aW9ucy5zZXJpZXMgJiYgb3B0aW9ucy5zZXJpZXMuc3RhY2tlZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IG9wdGlvbnMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMueUF4aXMsXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGlnbmVkOiBhbGlnbmVkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeEF4aXM6IHhBeGlzRGF0YSxcbiAgICAgICAgICAgIHlBeGlzOiB5QXhpc0RhdGFcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQgZm9yIG5vcm1hbCB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50Rm9yTm9ybWFsVG9vbHRpcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignY3VzdG9tRXZlbnQnLCBBcmVhVHlwZUN1c3RvbUV2ZW50LCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdGhpcy5pc1ZlcnRpY2FsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZENvbXBvbmVudHM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzRm9yQXhpc1R5cGUoe1xuICAgICAgICAgICAgYXhlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3lBeGlzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAneEF4aXMnLFxuICAgICAgICAgICAgICAgICAgICBpc0xhYmVsOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgc2VyaWVzZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5jaGFydFR5cGUgKyAnU2VyaWVzJyxcbiAgICAgICAgICAgICAgICAgICAgU2VyaWVzQ2xhc3M6IHRoaXMuU2VyaWVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjaGFydCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIENoYXJ0QmFzZS5wcm90b3R5cGUucmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1peCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIHRhcmdldCBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBtaXhpbjogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB0dWkudXRpbC5leHRlbmQoZnVuYy5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbGluZVR5cGVNaXhlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIE1hcENoYXJ0TWFwTW9kZWwgPSByZXF1aXJlKCcuL21hcENoYXJ0TWFwTW9kZWwnKSxcbiAgICBNYXBDaGFydENvbG9yTW9kZWwgPSByZXF1aXJlKCcuL21hcENoYXJ0Q29sb3JNb2RlbCcpLFxuICAgIE1hcENoYXJ0RGF0YVByb2Nlc3NvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbWFwQ2hhcnREYXRhUHJvY2Vzc29yJyksXG4gICAgYXhpc0RhdGFNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYXhpc0RhdGFNYWtlcicpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9tYXBDaGFydFNlcmllcycpLFxuICAgIFpvb20gPSByZXF1aXJlKCcuLi9zZXJpZXMvem9vbScpLFxuICAgIExlZ2VuZCA9IHJlcXVpcmUoJy4uL2xlZ2VuZHMvbWFwQ2hhcnRMZWdlbmQnKSxcbiAgICBNYXBDaGFydFRvb2x0aXAgPSByZXF1aXJlKCcuLi90b29sdGlwcy9tYXBDaGFydFRvb2x0aXAnKSxcbiAgICBtYXBDaGFydEN1c3RvbUV2ZW50ID0gcmVxdWlyZSgnLi4vY3VzdG9tRXZlbnRzL21hcENoYXJ0Q3VzdG9tRXZlbnQnKTtcblxudmFyIE1hcENoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ2hhcnRCYXNlLCAvKiogQGxlbmRzIE1hcENoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFwIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0XG4gICAgICogQGV4dGVuZHMgQ2hhcnRCYXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSByYXdEYXRhIHJhdyBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEsIHRoZW1lLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzcyBuYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktbWFwLWNoYXJ0JztcblxuICAgICAgICBvcHRpb25zLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwge307XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG5cbiAgICAgICAgQ2hhcnRCYXNlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgcmF3RGF0YTogcmF3RGF0YSxcbiAgICAgICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBEYXRhUHJvY2Vzc29yOiBNYXBDaGFydERhdGFQcm9jZXNzb3JcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkQ29tcG9uZW50cyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ29tcG9uZW50czogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLmxlZ2VuZCA9IG9wdGlvbnMubGVnZW5kIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuY29tcG9uZW50TWFuYWdlci5yZWdpc3RlcignbGVnZW5kJywgTGVnZW5kKTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ3Rvb2x0aXAnLCBNYXBDaGFydFRvb2x0aXAsIHRoaXMuX21ha2VUb29sdGlwRGF0YSgpKTtcblxuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ21hcFNlcmllcycsIFNlcmllcywge1xuICAgICAgICAgICAgbGliVHlwZTogb3B0aW9ucy5saWJUeXBlLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBvcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6ICdzZXJpZXMnLFxuICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCd6b29tJywgWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZXZlbnQgY29tcG9uZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZEN1c3RvbUV2ZW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdjdXN0b21FdmVudCcsIG1hcENoYXJ0Q3VzdG9tRXZlbnQsIHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXhlcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUF4ZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF4aXNEYXRhTWFrZXIubWFrZVZhbHVlQXhpc0RhdGEoe1xuICAgICAgICAgICAgdmFsdWVzOiBbdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcygpXSxcbiAgICAgICAgICAgIHNlcmllc0RpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2xlZ2VuZCcpLmhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5vcHRpb25zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uczogdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpLFxuICAgICAgICAgICAgdGlja0NvdW50OiBjaGFydENvbnN0Lk1BUF9DSEFSVF9MRUdFTkRfVElDS19DT1VOVCxcbiAgICAgICAgICAgIGlzVmVydGljYWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwZXJjZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUGVyY2VudFZhbHVlczogZnVuY3Rpb24oYXhlc0RhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yLnJlZ2lzdGVyUGVyY2VudFZhbHVlcyhheGVzRGF0YS5saW1pdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmVuZGVyaW5nIGRhdGEgZm9yIG1hcCBjaGFydC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVJlbmRlcmluZ0RhdGE6IGZ1bmN0aW9uKGF4ZXNEYXRhKSB7XG4gICAgICAgIHZhciBzZXJpZXNUaGVtZSA9IHRoaXMudGhlbWUuc2VyaWVzLFxuICAgICAgICAgICAgY29sb3JNb2RlbCA9IG5ldyBNYXBDaGFydENvbG9yTW9kZWwoc2VyaWVzVGhlbWUuc3RhcnRDb2xvciwgc2VyaWVzVGhlbWUuZW5kQ29sb3IpLFxuICAgICAgICAgICAgbWFwTW9kZWwgPSBuZXcgTWFwQ2hhcnRNYXBNb2RlbCh0aGlzLmRhdGFQcm9jZXNzb3IsIHRoaXMub3B0aW9ucy5tYXApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvck1vZGVsOiBjb2xvck1vZGVsLFxuICAgICAgICAgICAgICAgIGF4ZXNEYXRhOiBheGVzRGF0YVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcFNlcmllczoge1xuICAgICAgICAgICAgICAgIG1hcE1vZGVsOiBtYXBNb2RlbCxcbiAgICAgICAgICAgICAgICBjb2xvck1vZGVsOiBjb2xvck1vZGVsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgICAgIG1hcE1vZGVsOiBtYXBNb2RlbFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggY3VzdG9tIGV2bmV0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2F0dGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKSxcbiAgICAgICAgICAgIG1hcFNlcmllcyA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ21hcFNlcmllcycpLFxuICAgICAgICAgICAgbGVnZW5kID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnbGVnZW5kJyksXG4gICAgICAgICAgICB0b29sdGlwID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgndG9vbHRpcCcpLFxuICAgICAgICAgICAgem9vbSA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3pvb20nKTtcblxuICAgICAgICBjdXN0b21FdmVudC5vbih7XG4gICAgICAgICAgICBjbGlja01hcFNlcmllczogbWFwU2VyaWVzLm9uQ2xpY2tTZXJpZXMsXG4gICAgICAgICAgICBtb3ZlTWFwU2VyaWVzOiBtYXBTZXJpZXMub25Nb3ZlU2VyaWVzLFxuICAgICAgICAgICAgZHJhZ1N0YXJ0TWFwU2VyaWVzOiBtYXBTZXJpZXMub25EcmFnU3RhcnRTZXJpZXMsXG4gICAgICAgICAgICBkcmFnTWFwU2VyaWVzOiBtYXBTZXJpZXMub25EcmFnU2VyaWVzLFxuICAgICAgICAgICAgZHJhZ0VuZE1hcFNlcmllczogbWFwU2VyaWVzLm9uRHJhZ0VuZFNlcmllc1xuICAgICAgICB9LCBtYXBTZXJpZXMpO1xuXG4gICAgICAgIG1hcFNlcmllcy5vbih7XG4gICAgICAgICAgICBzaG93V2VkZ2U6IGxlZ2VuZC5vblNob3dXZWRnZSxcbiAgICAgICAgICAgIGhpZGVXZWRnZTogbGVnZW5kLm9uSGlkZVdlZGdlXG4gICAgICAgIH0sIGxlZ2VuZCk7XG5cbiAgICAgICAgbWFwU2VyaWVzLm9uKHtcbiAgICAgICAgICAgIHNob3dUb29sdGlwOiB0b29sdGlwLm9uU2hvdyxcbiAgICAgICAgICAgIGhpZGVUb29sdGlwOiB0b29sdGlwLm9uSGlkZSxcbiAgICAgICAgICAgIHNob3dUb29sdGlwQ29udGFpbmVyOiB0b29sdGlwLm9uU2hvd1Rvb2x0aXBDb250YWluZXIsXG4gICAgICAgICAgICBoaWRlVG9vbHRpcENvbnRhaW5lcjogdG9vbHRpcC5vbkhpZGVUb29sdGlwQ29udGFpbmVyXG4gICAgICAgIH0sIHRvb2x0aXApO1xuXG4gICAgICAgIHpvb20ub24oJ3pvb20nLCBtYXBTZXJpZXMub25ab29tLCBtYXBTZXJpZXMsIG1hcFNlcmllcyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFwQ2hhcnRDb2xvck1vZGVsIGlzIGNvbG9yIG1vZGVsIGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb2xvcnV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbG9ydXRpbCcpO1xuXG52YXIgTWFwQ2hhcnRDb2xvck1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBNYXBDaGFydENvbG9yTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXBDaGFydENvbG9yTW9kZWwgaXMgbGVnZW5kIG1vZGVsLlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0Q29sb3JNb2RlbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydENvbG9yIGhleCBjb2xvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRDb2xvciBoZXggY29sb3JcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihzdGFydENvbG9yLCBlbmRDb2xvcikge1xuICAgICAgICB2YXIgZW5kUkdCO1xuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBjb2xvcnV0aWwuY29sb3JOYW1lVG9IZXgoc3RhcnRDb2xvcik7XG4gICAgICAgIHRoaXMuc3RhcnRSR0IgPSBjb2xvcnV0aWwuaGV4VG9SR0IodGhpcy5zdGFydCk7XG4gICAgICAgIHRoaXMuZW5kID0gY29sb3J1dGlsLmNvbG9yTmFtZVRvSGV4KGVuZENvbG9yKTtcblxuICAgICAgICBlbmRSR0IgPSBjb2xvcnV0aWwuaGV4VG9SR0IodGhpcy5lbmQpO1xuICAgICAgICB0aGlzLmRpc3RhbmNlcyA9IHRoaXMuX21ha2VEaXN0YW5jZXModGhpcy5zdGFydFJHQiwgZW5kUkdCKTtcbiAgICAgICAgdGhpcy5jb2xvck1hcCA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpc3RhbmNlcyBzdGFydCBSR0IgdG8gZW5kIFJHQi5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBzdGFydFJHQiBzdGFydCBSR0JcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBlbmRSR0IgZW5kIFJHQlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gZGlzdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURpc3RhbmNlczogZnVuY3Rpb24oc3RhcnRSR0IsIGVuZFJHQikge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHN0YXJ0UkdCLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmRSR0JbaW5kZXhdIC0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgaGV4IGNvbG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyByYXRpb1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGhleCBjb2xvclxuICAgICAqL1xuICAgIGdldENvbG9yOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgICB2YXIgaGV4Q29sb3IgPSB0aGlzLmNvbG9yTWFwW3JhdGlvXSxcbiAgICAgICAgICAgIGRpc3RhbmNlcywgcmdiQ29sb3I7XG5cbiAgICAgICAgaWYgKCFoZXhDb2xvcikge1xuICAgICAgICAgICAgZGlzdGFuY2VzID0gdGhpcy5kaXN0YW5jZXM7XG4gICAgICAgICAgICByZ2JDb2xvciA9IHR1aS51dGlsLm1hcCh0aGlzLnN0YXJ0UkdCLCBmdW5jdGlvbiAoc3RhcnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgcGFyc2VJbnQoZGlzdGFuY2VzW2luZGV4XSAqIHJhdGlvLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhleENvbG9yID0gY29sb3J1dGlsLnJnYlRvSEVYLmFwcGx5KG51bGwsIHJnYkNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZXhDb2xvcjtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydENvbG9yTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFwQ2hhcnRNYXBNb2RlbCBpcyBtYXAgbW9kZWwgb2YgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBNYXBDaGFydE1hcE1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBNYXBDaGFydE1hcE1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFwQ2hhcnRNYXBNb2RlbCBpcyBtYXAgbW9kZWwgb2YgbWFwIGNoYXJ0LlxuICAgICAqIEBjb25zdHJ1Y3RzIE1hcENoYXJ0TWFwTW9kZWxcbiAgICAgKiBAcGFyYW0ge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn0gZGF0YVByb2Nlc3NvciBNYXAgY2hhcnQgZGF0YSBwcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGxhYmVsQ29vcmRpbmF0ZTogP3t4OiBudW1iZXIsIHk6bnVtYmVyfX0+fSByYXdNYXBEYXRhIHJhdyBtYXAgZGF0YVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKGRhdGFQcm9jZXNzb3IsIHJhd01hcERhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbW1hbmQgZnVuY3Rpb24gbWFwLlxuICAgICAgICAgKiBAdHlwZSB7e1xuICAgICAgICAgKiAgICAgIE06IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VDb29yZGluYXRlLCBtOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGUsXG4gICAgICAgICAqICAgICAgTDogTWFwQ2hhcnRNYXBNb2RlbC5fbWFrZUNvb3JkaW5hdGUsIGw6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VDb29yZGluYXRlRnJvbVJlbGF0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICogICAgICBIOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWENvb3JkaW5hdGUsIGg6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VYQ29vcmRpbmF0ZUZyb1JlbGF0aXZlQ29vcmRpbmF0ZSxcbiAgICAgICAgICogICAgICBWOiBNYXBDaGFydE1hcE1vZGVsLl9tYWtlWUNvb3JkaW5hdGUsIHY6IE1hcENoYXJ0TWFwTW9kZWwuX21ha2VZQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGVcbiAgICAgICAgICogfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tbWFuZEZ1bmNNYXAgPSB7XG4gICAgICAgICAgICBNOiB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIG06IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKSxcbiAgICAgICAgICAgIEw6IHR1aS51dGlsLmJpbmQodGhpcy5fbWFrZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgbDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgSDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWENvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgaDogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWENvb3JkaW5hdGVGcm9SZWxhdGl2ZUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgVjogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWUNvb3JkaW5hdGUsIHRoaXMpLFxuICAgICAgICAgICAgdjogdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlWUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlLCB0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZ25vcmUgY29tbWFuZCBtYXAuXG4gICAgICAgICAqIEB0eXBlIHt7WjogYm9vbGVhbiwgejogYm9vbGVhbn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlnbm9yZUNvbW1hbmRNYXAgPSB7XG4gICAgICAgICAgICBaOiB0cnVlLFxuICAgICAgICAgICAgejogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgZGF0YS5cbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBEYXRhID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBkaW1lbnNpb25cbiAgICAgICAgICogQHR5cGUge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcERpbWVuc2lvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBjaGFydCBkYXRhIHByb2Nlc3Nvci5cbiAgICAgICAgICogQHR5cGUge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IGRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlTWFwRGF0YShyYXdNYXBEYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgY29vcmRpbmF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gY29vcmRpbmF0ZSBtYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zcGxpdENvb3JkaW5hdGU6IGZ1bmN0aW9uKGNvb3JkaW5hdGVTdHIpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZVN0ci5zcGxpdCgnLCcpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQoY29vcmRpbmF0ZXNbMF0pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjb29yZGluYXRlc1sxXSkge1xuICAgICAgICAgICAgcmVzdWx0LnkgPSBwYXJzZUZsb2F0KGNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcGxpdENvb3JkaW5hdGUoY29vcmRpbmF0ZVN0cik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBmcm9tIHJlbGF0aXZlIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcHJldkNvb3JkaW5hdGUgcHJldmlvdXMgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvb3JkaW5hdGVGcm9tUmVsYXRpdmVDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyLCBwcmV2Q29vcmRpbmF0ZSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX3NwbGl0Q29vcmRpbmF0ZShjb29yZGluYXRlU3RyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY29vcmRpbmF0ZS54ICsgcHJldkNvb3JkaW5hdGUueCxcbiAgICAgICAgICAgIHk6IGNvb3JkaW5hdGUueSArIHByZXZDb29yZGluYXRlLnlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyfX0geCBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVhDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB4IGNvb3JkaW5hdGUgZnJvbSByZWxhdGl2ZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHByZXZDb29yZGluYXRlIHByZXZpb3VzIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlcn19IHggY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VYQ29vcmRpbmF0ZUZyb1JlbGF0aXZlQ29vcmRpbmF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZVN0ciwgcHJldkNvb3JkaW5hdGUpIHtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSB0aGlzLl9zcGxpdENvb3JkaW5hdGUoY29vcmRpbmF0ZVN0cik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNvb3JkaW5hdGUueCArIHByZXZDb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvb3JkaW5hdGVTdHIgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHt7eTogbnVtYmVyfX0geSBjb29yZGluYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVlDb29yZGluYXRlOiBmdW5jdGlvbihjb29yZGluYXRlU3RyKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBjb29yZGluYXRlLnhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB5IGNvb3JkaW5hdGUgZnJvbSByZWxhdGl2ZSBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb29yZGluYXRlU3RyIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHByZXZDb29yZGluYXRlIHByZXZpb3VzIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7e3k6IG51bWJlcn19IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VZQ29vcmRpbmF0ZUZyb21SZWxhdGl2ZUNvb3JkaW5hdGU6IGZ1bmN0aW9uKGNvb3JkaW5hdGVTdHIsIHByZXZDb29yZGluYXRlKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlID0gdGhpcy5fc3BsaXRDb29yZGluYXRlKGNvb3JkaW5hdGVTdHIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiBjb29yZGluYXRlLnggKyBwcmV2Q29vcmRpbmF0ZS55XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0IHBhdGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggcGF0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3R5cGU6IHN0cmluZywgY29vcmRpbmF0ZTogc3RyaW5nfT59IHNwbGl0dGVkIHBhdGggZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NwbGl0UGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIHBhdGhEYXRhID0gW10sXG4gICAgICAgICAgICBjb29yZGluYXRlID0gJycsXG4gICAgICAgICAgICBjaHIsIGNvbW1hbmRUeXBlO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNociA9IHBhdGguY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWFuZEZ1bmNNYXBbY2hyXSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kVHlwZSAmJiBjb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29tbWFuZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21tYW5kVHlwZSA9IGNocjtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlnbm9yZUNvbW1hbmRNYXBbY2hyXSkge1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUgKz0gY2hyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmRUeXBlICYmIGNvb3JkaW5hdGUpIHtcbiAgICAgICAgICAgIHBhdGhEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1hbmRUeXBlLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGU6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGVzIGZyb20gcGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7eDogbnVtYmVyLCB5OiBudW1iZXJ9Pn0gY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQ29vcmRpbmF0ZXNGcm9tUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLl9zcGxpdFBhdGgocGF0aCksXG4gICAgICAgICAgICBwcmV2Q29vcmRpbmF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwYXRoRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHZhciBjb21tYW5kRnVuYyA9IHRoaXMuY29tbWFuZEZ1bmNNYXBbZGF0dW0udHlwZV0sXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZSA9IGNvbW1hbmRGdW5jKGRhdHVtLmNvb3JkaW5hdGUsIHByZXZDb29yZGluYXRlKTtcblxuICAgICAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHByZXZDb29yZGluYXRlLCBjb29yZGluYXRlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGU7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGJvdW5kIGZyb20gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9Pn0gY29vcmRpbmF0ZXMgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX19IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZEJvdW5kRnJvbUNvb3JkaW5hdGVzOiBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgeHMgPSB0dWkudXRpbC5maWx0ZXIodHVpLnV0aWwucGx1Y2soY29vcmRpbmF0ZXMsICd4JyksIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXR1aS51dGlsLmlzVW5kZWZpbmVkKHgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB5cyA9IHR1aS51dGlsLmZpbHRlcih0dWkudXRpbC5wbHVjayhjb29yZGluYXRlcywgJ3knKSwgZnVuY3Rpb24oeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHVpLnV0aWwuaXNVbmRlZmluZWQoeSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1heExlZnQgPSBNYXRoLm1heC5hcHBseShudWxsLCB4cyksXG4gICAgICAgICAgICBtaW5MZWZ0ID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeHMpLFxuICAgICAgICAgICAgbWF4VG9wID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeXMpLFxuICAgICAgICAgICAgbWluVG9wID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeXMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogbWF4TGVmdCAtIG1pbkxlZnQsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtYXhUb3AgLSBtaW5Ub3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IG1pbkxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBtaW5Ub3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25SYXRpbyBwb3NpdGlvbiByYXRpb1xuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGxhYmVsIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJvdW5kLCBwb3NpdGlvblJhdGlvKSB7XG4gICAgICAgIHBvc2l0aW9uUmF0aW8gPSBwb3NpdGlvblJhdGlvIHx8IGNoYXJ0Q29uc3QuTUFQX0NIQVJUX0xBQkVMX0RFRkFVTFRfUE9TSVRJT05fUkFUSU87XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kLnBvc2l0aW9uLmxlZnQgKyAoYm91bmQuZGltZW5zaW9uLndpZHRoICogcG9zaXRpb25SYXRpby54KSxcbiAgICAgICAgICAgIHRvcDogYm91bmQucG9zaXRpb24udG9wICsgKGJvdW5kLmRpbWVuc2lvbi5oZWlnaHQgKiBwb3NpdGlvblJhdGlvLnkpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBtYXAgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcsIGxhYmVsQ29vcmRpbmF0ZTogP3t4OiBudW1iZXIsIHk6bnVtYmVyfX0+fSByYXdNYXBEYXRhIHJhdyBtYXAgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZU1hcERhdGE6IGZ1bmN0aW9uKHJhd01hcERhdGEpIHtcbiAgICAgICAgdGhpcy5tYXBEYXRhID0gdHVpLnV0aWwubWFwKHJhd01hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IHRoaXMuX21ha2VDb29yZGluYXRlc0Zyb21QYXRoKGRhdHVtLnBhdGgpLFxuICAgICAgICAgICAgICAgIGJvdW5kID0gdGhpcy5fZmluZEJvdW5kRnJvbUNvb3JkaW5hdGVzKGNvb3JkaW5hdGUpLFxuICAgICAgICAgICAgICAgIHVzZXJEYXRhID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlTWFwRGF0dW0oZGF0dW0uY29kZSksXG4gICAgICAgICAgICAgICAgbmFtZSwgbGFiZWxDb29yZGluYXRlLCBmb3JtYXR0ZWRWYWx1ZSwgcGVyY2VudFZhbHVlLCByZXN1bHREYXRhO1xuXG4gICAgICAgICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHVzZXJEYXRhLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHBlcmNlbnRWYWx1ZSA9IHVzZXJEYXRhLnBlcmNlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBuYW1lID0gdXNlckRhdGEubmFtZSB8fCBkYXR1bS5uYW1lO1xuICAgICAgICAgICAgICAgIGxhYmVsQ29vcmRpbmF0ZSA9IHVzZXJEYXRhLmxhYmVsQ29vcmRpbmF0ZSB8fCBkYXR1bS5sYWJlbENvb3JkaW5hdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdERhdGEgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogZGF0dW0uY29kZSxcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIHBhdGg6IGRhdHVtLnBhdGgsXG4gICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IHRoaXMuX21ha2VMYWJlbFBvc2l0aW9uKGJvdW5kLCBsYWJlbENvb3JkaW5hdGUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwZXJjZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHREYXRhLnBlcmNlbnRWYWx1ZSA9IHBlcmNlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdERhdGE7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRNYXBEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRGF0YTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0dW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcERhdGFbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGFiZWwgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gcmF0aW9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtuYW1lOiBzdHJpbmcsIGJvdW5kOiB7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSwgbGFiZWxQb3NpdGlvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0+fSBtYXAgZGF0YVxuICAgICAqL1xuICAgIGdldExhYmVsRGF0YTogZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgdmFyIGxhYmVsRGF0YSA9IHR1aS51dGlsLmZpbHRlcih0aGlzLm1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZU1hcERhdHVtKGRhdHVtLmNvZGUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsYWJlbERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRhdHVtLm5hbWUsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkYXR1bS5sYWJlbFBvc2l0aW9uLmxlZnQgKiByYXRpbyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBkYXR1bS5sYWJlbFBvc2l0aW9uLnRvcCAqIHJhdGlvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWFwIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBtYXAgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU1hcERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXBEYXRhID0gdGhpcy5tYXBEYXRhLFxuICAgICAgICAgICAgbGVmdHMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24ubGVmdDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmlnaHRzID0gdHVpLnV0aWwubWFwKG1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtLmJvdW5kLnBvc2l0aW9uLmxlZnQgKyBkYXR1bS5ib3VuZC5kaW1lbnNpb24ud2lkdGg7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRvcHMgPSB0dWkudXRpbC5tYXAobWFwRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0dW0uYm91bmQucG9zaXRpb24udG9wO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBib3R0b21zID0gdHVpLnV0aWwubWFwKG1hcERhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdHVtLmJvdW5kLnBvc2l0aW9uLnRvcCArIGRhdHVtLmJvdW5kLmRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1heC5hcHBseShudWxsLCByaWdodHMpIC0gTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdHMpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1heC5hcHBseShudWxsLCBib3R0b21zKSAtIE1hdGgubWluLmFwcGx5KG51bGwsIHRvcHMpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBtYXAgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBtYXAgZGltZW5zaW9uXG4gICAgICovXG4gICAgZ2V0TWFwRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcERpbWVuc2lvbikge1xuICAgICAgICAgICAgdGhpcy5tYXBEaW1lbnNpb24gPSB0aGlzLl9tYWtlTWFwRGltZW5zaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tYXBEaW1lbnNpb247XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRNYXBNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDaGFydEJhc2UgPSByZXF1aXJlKCcuL2NoYXJ0QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgTGVnZW5kID0gcmVxdWlyZSgnLi4vbGVnZW5kcy9sZWdlbmQnKSxcbiAgICBUb29sdGlwID0gcmVxdWlyZSgnLi4vdG9vbHRpcHMvdG9vbHRpcCcpLFxuICAgIFNlcmllcyA9IHJlcXVpcmUoJy4uL3Nlcmllcy9waWVDaGFydFNlcmllcycpLFxuICAgIFBpZUNoYXJ0Q3VzdG9tRXZlbnQgPSByZXF1aXJlKCcuLi9jdXN0b21FdmVudHMvcGllQ2hhcnRDdXN0b21FdmVudCcpO1xuXG52YXIgUGllQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDaGFydEJhc2UsIC8qKiBAbGVuZHMgUGllQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDb2x1bW4gY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGllQ2hhcnRcbiAgICAgKiBAZXh0ZW5kcyBDaGFydEJhc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgY2hhcnQgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBjaGFydCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocmF3RGF0YSwgdGhlbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLXBpZS1jaGFydCc7XG5cbiAgICAgICAgb3B0aW9ucy50b29sdGlwID0gb3B0aW9ucy50b29sdGlwIHx8IHt9O1xuXG4gICAgICAgIGlmICghb3B0aW9ucy50b29sdGlwLmFsaWduKSB7XG4gICAgICAgICAgICBvcHRpb25zLnRvb2x0aXAuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH1cblxuICAgICAgICBDaGFydEJhc2UuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICByYXdEYXRhOiByYXdEYXRhLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRDb21wb25lbnRzKHRoZW1lLmNoYXJ0LmJhY2tncm91bmQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjaGFydEJhY2tncm91bmQgY2hhcnQgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDb21wb25lbnRzOiBmdW5jdGlvbihjaGFydEJhY2tncm91bmQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEFsaWduLCBpc1BpZUxlZ2VuZFR5cGU7XG4gICAgICAgIG9wdGlvbnMubGVnZW5kID0gb3B0aW9ucy5sZWdlbmQgfHwge307XG4gICAgICAgIGxlZ2VuZEFsaWduID0gb3B0aW9ucy5sZWdlbmQgJiYgb3B0aW9ucy5sZWdlbmQuYWxpZ247XG4gICAgICAgIGlzUGllTGVnZW5kVHlwZSA9IHByZWRpY2F0ZS5pc1BpZUxlZ2VuZEFsaWduKGxlZ2VuZEFsaWduKTtcblxuICAgICAgICBpZiAoIWlzUGllTGVnZW5kVHlwZSAmJiAhb3B0aW9ucy5sZWdlbmQuaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2xlZ2VuZCcsIExlZ2VuZCwge1xuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ3Rvb2x0aXAnLCBUb29sdGlwLCB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKSk7XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyKCdwaWVTZXJpZXMnLCBTZXJpZXMsIHtcbiAgICAgICAgICAgIGxpYlR5cGU6IG9wdGlvbnMubGliVHlwZSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiAnc2VyaWVzJyxcbiAgICAgICAgICAgIGNoYXJ0QmFja2dyb3VuZDogY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgdXNlckV2ZW50OiB0aGlzLnVzZXJFdmVudCxcbiAgICAgICAgICAgIGxlZ2VuZEFsaWduOiBpc1BpZUxlZ2VuZFR5cGUgJiYgIW9wdGlvbnMubGVnZW5kLmhpZGRlbiA/IGxlZ2VuZEFsaWduIDogbnVsbFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGN1c3RvbSBldmVudCBjb21wb25lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkQ3VzdG9tRXZlbnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hbmFnZXIucmVnaXN0ZXIoJ2N1c3RvbUV2ZW50JywgUGllQ2hhcnRDdXN0b21FdmVudCwge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBlcmNlbnQgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3VwZGF0ZVBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IucmVnaXN0ZXJQaWVDaGFydFBlcmNlbnRWYWx1ZXModGhpcy5vcHRpb25zLmNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBjdXN0b20gZXZuZXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfYXR0YWNoQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VzdG9tRXZlbnQsIHRvb2x0aXAsIHBpZVNlcmllcztcblxuICAgICAgICBDaGFydEJhc2UucHJvdG90eXBlLl9hdHRhY2hDdXN0b21FdmVudC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGN1c3RvbUV2ZW50ID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgnY3VzdG9tRXZlbnQnKTtcbiAgICAgICAgdG9vbHRpcCA9IHRoaXMuY29tcG9uZW50TWFuYWdlci5nZXQoJ3Rvb2x0aXAnKTtcbiAgICAgICAgcGllU2VyaWVzID0gdGhpcy5jb21wb25lbnRNYW5hZ2VyLmdldCgncGllU2VyaWVzJyk7XG5cbiAgICAgICAgY3VzdG9tRXZlbnQub24oe1xuICAgICAgICAgICAgY2xpY2tQaWVTZXJpZXM6IHBpZVNlcmllcy5vbkNsaWNrU2VyaWVzLFxuICAgICAgICAgICAgbW92ZVBpZVNlcmllczogcGllU2VyaWVzLm9uTW92ZVNlcmllc1xuICAgICAgICB9LCBwaWVTZXJpZXMpO1xuXG4gICAgICAgIHBpZVNlcmllcy5vbih7XG4gICAgICAgICAgICBzaG93VG9vbHRpcDogdG9vbHRpcC5vblNob3csXG4gICAgICAgICAgICBoaWRlVG9vbHRpcDogdG9vbHRpcC5vbkhpZGUsXG4gICAgICAgICAgICBzaG93VG9vbHRpcENvbnRhaW5lcjogdG9vbHRpcC5vblNob3dUb29sdGlwQ29udGFpbmVyLFxuICAgICAgICAgICAgaGlkZVRvb2x0aXBDb250YWluZXI6IHRvb2x0aXAub25IaWRlVG9vbHRpcENvbnRhaW5lclxuICAgICAgICB9LCB0b29sdGlwKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWVDaGFydDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQaWNrIG1pbmltdW0gdmFsdWUgZnJvbSB2YWx1ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyciB2YWx1ZSBhcnJheVxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNvbmRpdGlvbiBjb25kaXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCB0YXJnZXQgY29udGV4dFxuICogQHJldHVybnMgeyp9IG1pbmltdW0gdmFsdWVcbiAqL1xudmFyIG1pbiA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCwgbWluVmFsdWUsIHJlc3Q7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc3VsdCA9IGFyclswXTtcbiAgICBtaW5WYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgcmVzdCA9IGFyci5zbGljZSgxKTtcbiAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocmVzdCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgY29tcGFyZVZhbHVlID0gY29uZGl0aW9uLmNhbGwoY29udGV4dCwgaXRlbSk7XG4gICAgICAgIGlmIChjb21wYXJlVmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgbWluVmFsdWUgPSBjb21wYXJlVmFsdWU7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUGljayBtYXhpbXVtIHZhbHVlIGZyb20gdmFsdWUgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdmFsdWUgYXJyYXlcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHsqfSBtYXhpbXVtIHZhbHVlXG4gKi9cbnZhciBtYXggPSBmdW5jdGlvbihhcnIsIGNvbmRpdGlvbiwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQsIG1heFZhbHVlLCByZXN0O1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJbMF07XG4gICAgbWF4VmFsdWUgPSBjb25kaXRpb24uY2FsbChjb250ZXh0LCByZXN1bHQpO1xuICAgIHJlc3QgPSBhcnIuc2xpY2UoMSk7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJlc3QsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGNvbXBhcmVWYWx1ZSA9IGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0pO1xuICAgICAgICBpZiAoY29tcGFyZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gY29tcGFyZVZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgb25lIG9mIHRoZW0gaXMgdHJ1ZSBvciBub3QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICovXG52YXIgYW55ID0gZnVuY3Rpb24oYXJyLCBjb25kaXRpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5jYWxsKGNvbnRleHQsIGl0ZW0sIGluZGV4LCBhcnIpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQWxsIG9mIHRoZW0gaXMgdHJ1ZSBvciBub3QuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25kaXRpb24gY29uZGl0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1tvYmplY3RdfSBjb250ZXh0IHRhcmdldCBjb250ZXh0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAqL1xudmFyIGFsbCA9IGZ1bmN0aW9uKGFyciwgY29uZGl0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24uY2FsbChjb250ZXh0LCBpdGVtLCBpbmRleCwgYXJyKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBNYWtlIHVuaXF1ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0gez9ib29sZWFufSBzb3J0ZWQgd2hldGhlciBzb3J0ZWQgb3Igbm90LlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGl0ZXJhdGVlIGl0ZXJhdGVlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgdGFyZ2V0IGNvbnRleHRcbiAqIEByZXR1cm5zIHtBcnJheX0gdW5pcXVlIHZhbHVlc1xuICovXG52YXIgdW5pcXVlID0gZnVuY3Rpb24oYXJyLCBzb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBwcmV2VmFsdWU7XG5cbiAgICBpZiAoIXR1aS51dGlsLmlzQm9vbGVhbihzb3J0ZWQpKSB7XG4gICAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgICAgaXRlcmF0ZWUgPSBzb3J0ZWQ7XG4gICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGl0ZXJhdGVlID0gaXRlcmF0ZWUgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGFycik7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8IHByZXZWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGFyciwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGl0ZXJhdGVlLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBhcnIpO1xuICAgICAgICAgICAgaWYgKHR1aS51dGlsLmluQXJyYXkodmFsdWUsIHJlc3VsdCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBcnJheSBwaXZvdC5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBhcnIyZCB0YXJnZXQgMmQgYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheS48QXJyYXk+fSBwaXZvdGVkIDJkIGFycmF5XG4gKi9cbnZhciBwaXZvdCA9IGZ1bmN0aW9uKGFycjJkKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIyZCwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShhcnIsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2luZGV4XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IGFmdGVyIHBvaW50IGxlbmd0aC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB2YWx1ZSB0YXJnZXQgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCBsZW5ndGhcbiAqL1xudmFyIGxlbmd0aEFmdGVyUG9pbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB2YWx1ZUFyciA9ICh2YWx1ZSArICcnKS5zcGxpdCgnLicpO1xuICAgIHJldHVybiB2YWx1ZUFyci5sZW5ndGggPT09IDIgPyB2YWx1ZUFyclsxXS5sZW5ndGggOiAwO1xufTtcblxuLyoqXG4gKiBGaW5kIG11bHRpcGxlIG51bS5cbiAqIEBwYXJhbSB7Li4uQXJyYXl9IHRhcmdldCB2YWx1ZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG11bHRpcGxlIG51bVxuICovXG52YXIgZmluZE11bHRpcGxlTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHVuZGVyUG9pbnRMZW5zID0gdHVpLnV0aWwubWFwKGFyZ3MsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubGVuZ3RoQWZ0ZXJQb2ludCh2YWx1ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICB1bmRlclBvaW50TGVuID0gdHVpLnV0aWwubWF4KHVuZGVyUG9pbnRMZW5zKSxcbiAgICAgICAgbXVsdGlwbGVOdW0gPSBNYXRoLnBvdygxMCwgdW5kZXJQb2ludExlbik7XG4gICAgcmV0dXJuIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBNb2R1bG8gb3BlcmF0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IHRhcmdldCB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2ROdW0gbW9kIG51bVxuICogQHJldHVybnMge251bWJlcn0gcmVzdWx0IG1vZFxuICovXG52YXIgbW9kID0gZnVuY3Rpb24odGFyZ2V0LCBtb2ROdW0pIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSB0dWkudXRpbC5maW5kTXVsdGlwbGVOdW0obW9kTnVtKTtcbiAgICByZXR1cm4gKCh0YXJnZXQgKiBtdWx0aXBsZU51bSkgJSAobW9kTnVtICogbXVsdGlwbGVOdW0pKSAvIG11bHRpcGxlTnVtO1xufTtcblxuLyoqXG4gKiBBZGRpdGlvbiBmb3IgZmxvYXRpbmcgcG9pbnQgb3BlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgdGFyZ2V0IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiIHRhcmdldCBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhZGRpdGlvbiByZXN1bHRcbiAqL1xudmFyIGFkZGl0aW9uID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBtdWx0aXBsZU51bSA9IGZpbmRNdWx0aXBsZU51bShhLCBiKTtcbiAgICByZXR1cm4gKChhICogbXVsdGlwbGVOdW0pICsgKGIgKiBtdWx0aXBsZU51bSkpIC8gbXVsdGlwbGVOdW07XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0aW9uIGZvciBmbG9hdGluZyBwb2ludCBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gYSB0YXJnZXQgYVxuICogQHBhcmFtIHtudW1iZXJ9IGIgdGFyZ2V0IGJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHN1YnRyYWN0aW9uIHJlc3VsdFxuICovXG52YXIgc3VidHJhY3Rpb24gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIG11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtKGEsIGIpO1xuICAgIHJldHVybiAoKGEgKiBtdWx0aXBsZU51bSkgLSAoYiAqIG11bHRpcGxlTnVtKSkgLyBtdWx0aXBsZU51bTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGljYXRpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gbXVsdGlwbGljYXRpb24gcmVzdWx0XG4gKi9cbnZhciBtdWx0aXBsaWNhdGlvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuICgoYSAqIG11bHRpcGxlTnVtKSAqIChiICogbXVsdGlwbGVOdW0pKSAvIChtdWx0aXBsZU51bSAqIG11bHRpcGxlTnVtKTtcbn07XG5cbi8qKlxuICogRGl2aXNpb24gZm9yIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhIHRhcmdldCBhXG4gKiBAcGFyYW0ge251bWJlcn0gYiB0YXJnZXQgYlxuICogQHJldHVybnMge251bWJlcn0gZGl2aXNpb24gcmVzdWx0XG4gKi9cbnZhciBkaXZpc2lvbiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgbXVsdGlwbGVOdW0gPSBmaW5kTXVsdGlwbGVOdW0oYSwgYik7XG4gICAgcmV0dXJuIChhICogbXVsdGlwbGVOdW0pIC8gKGIgKiBtdWx0aXBsZU51bSk7XG59O1xuXG4vKipcbiAqIFN1bS5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB0YXJnZXQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgdmFsdWVcbiAqL1xudmFyIHN1bSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBjb3B5QXJyID0gdmFsdWVzLnNsaWNlKCk7XG4gICAgY29weUFyci51bnNoaWZ0KDApO1xuICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoY29weUFyciwgZnVuY3Rpb24oYmFzZSwgYWRkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGJhc2UpICsgcGFyc2VGbG9hdChhZGQpO1xuICAgIH0pO1xufTtcblxuXG52YXIgcHJvcGVyQ2FzZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudHVpLnV0aWwubWluID0gbWluO1xudHVpLnV0aWwubWF4ID0gbWF4O1xudHVpLnV0aWwuYW55ID0gYW55O1xudHVpLnV0aWwuYWxsID0gYWxsO1xudHVpLnV0aWwudW5pcXVlID0gdW5pcXVlO1xudHVpLnV0aWwucGl2b3QgPSBwaXZvdDtcbnR1aS51dGlsLmxlbmd0aEFmdGVyUG9pbnQgPSBsZW5ndGhBZnRlclBvaW50O1xudHVpLnV0aWwubW9kID0gbW9kO1xudHVpLnV0aWwuZmluZE11bHRpcGxlTnVtID0gZmluZE11bHRpcGxlTnVtO1xudHVpLnV0aWwuYWRkaXRpb24gPSBhZGRpdGlvbjtcbnR1aS51dGlsLnN1YnRyYWN0aW9uID0gc3VidHJhY3Rpb247XG50dWkudXRpbC5tdWx0aXBsaWNhdGlvbiA9IG11bHRpcGxpY2F0aW9uO1xudHVpLnV0aWwuZGl2aXNpb24gPSBkaXZpc2lvbjtcbnR1aS51dGlsLnN1bSA9IHN1bTtcbnR1aS51dGlsLnByb3BlckNhc2UgPSBwcm9wZXJDYXNlO1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgZm4gdW50aWwgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gKiBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdWNlZCBmdW5jdGlvbiB3YXMgaW52b2tlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXk9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXlcbiAqIEBtZW1iZXJvZiB0dWkudXRpbFxuICogQHJldHVybnMge2Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIHt9XG4gKlxuICogdmFyIGRlYm91bmNlZCA9IHR1aS51dGlsLmRlYm91bmNlKHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCwgMzAwKTtcbiAqXG4gKiAvLyBpbnZva2UgcmVwZWF0ZWRseVxuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpOyAgICAvLyBsYXN0IGludm9rZSBvZiBkZWJvdW5jZWQoKVxuICpcbiAqIC8vIGludm9rZSBzb21lTWV0aG9kVG9JbnZva2VEZWJvdW5jZWQoKSBhZnRlciAzMDAgbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIsXG4gICAgICAgIGFyZ3M7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcblxuICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBmbiBhdCBtb3N0IG9uY2UgcGVyIGV2ZXJ5IGludGVydmFsIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIHRocm90dGxlIHNob3J0IHRpbWUgcmVwZWF0ZWRseSBpbnZva2luZyBmdW5jdGlvbnMuIChlLmcgTW91c2VNb3ZlLCBSZXNpemUgLi4uKVxuICpcbiAqIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHlvdSBtdXN0IHJlbW92ZSBzbHVncyAoZS5nLiBmbGFnIHZhcmlhYmxlKSByZWxhdGVkIHdpdGggdGhyb3R0bGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsPTBdIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQG1lbWJlcm9mIHR1aS51dGlsXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRocm90dGxlZCBmdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQoKSB7fVxuICpcbiAqIHZhciB0aHJvdHRsZWQgPSB0dWkudXRpbC50aHJvdHRsZShzb21lTWV0aG9kVG9JbnZva2VUaHJvdHRsZWQsIDMwMCk7XG4gKlxuICogLy8gaW52b2tlIHJlcGVhdGVkbHlcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKGxlYWRpbmcpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpOyAgICAvLyBpbnZva2UgKG5lYXIgMzAwIG1pbGxpc2Vjb25kcylcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDYwMCBtaWxsaXNlY29uZHMpXG4gKiAvLyAuLi5cbiAqIC8vIGludm9rZSAodHJhaWxpbmcpXG4gKlxuICogLy8gaWYgeW91IG5lZWQgcmV1c2UgdGhyb3R0bGVkIG1ldGhvZC4gdGhlbiBpbnZva2UgcmVzZXQoKVxuICogdGhyb3R0bGVkLnJlc2V0KCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZuLCBpbnRlcnZhbCkge1xuICAgIHZhciBiYXNlLFxuICAgICAgICBfdGltZXN0YW1wID0gdHVpLnV0aWwudGltZXN0YW1wLFxuICAgICAgICBkZWJvdW5jZWQsXG4gICAgICAgIGlzTGVhZGluZyA9IHRydWUsXG4gICAgICAgIHN0YW1wLFxuICAgICAgICBhcmdzLFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIF9hcmdzKTtcbiAgICAgICAgICAgIGJhc2UgPSBudWxsO1xuICAgICAgICB9O1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XG5cbiAgICBkZWJvdW5jZWQgPSB0dWkudXRpbC5kZWJvdW5jZSh0aWNrLCBpbnRlcnZhbCk7XG5cbiAgICBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgICAgIGFyZ3MgPSBhcHMuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChpc0xlYWRpbmcpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgICAgICBpc0xlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YW1wID0gX3RpbWVzdGFtcCgpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlIHx8IHN0YW1wO1xuXG4gICAgICAgIGRlYm91bmNlZChhcmdzKTtcblxuICAgICAgICBpZiAoKHN0YW1wIC0gYmFzZSkgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRpY2soYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgaXNMZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgYmFzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhyb3R0bGVkLnJlc2V0ID0gcmVzZXQ7XG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxudHVpLnV0aWwuZGVib3VuY2UgPSBkZWJvdW5jZTtcbnR1aS51dGlsLnRocm90dGxlID0gdGhyb3R0bGU7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hhcnQgY29uc3RcbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbi8qKlxuICogQ2hhcnQgY29uc3RcbiAqIEByZWFkb25seVxuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIGNoYXJ0Q29uc3QgPSB7XG4gICAgLyoqIHR1aSBjbGFzcyBuYW1lc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQ0xBU1NfTkFNRV9MRUdFTkRfTEFCRUw6ICd0dWktY2hhcnQtbGVnZW5kLWxhYmVsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDTEFTU19OQU1FX0xFR0VORF9DSEVDS0JPWDogJ3R1aS1jaGFydC1sZWdlbmQtY2hlY2tib3gnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENMQVNTX05BTUVfU0VSSUVTX0xBQkVMOiAndHVpLWNoYXJ0LXNlcmllcy1sYWJlbCcsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgQ0xBU1NfTkFNRV9TRVJJRVNfTEVHRU5EOiAndHVpLWNoYXJ0LXNlcmllcy1sZWdlbmQnLFxuICAgIC8qKiBjaGFydCB0eXBlc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQ0hBUlRfVFlQRV9CQVI6ICdiYXInLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfQ09MVU1OOiAnY29sdW1uJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0xJTkU6ICdsaW5lJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0FSRUE6ICdhcmVhJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX0NPTUJPOiAnY29tYm8nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIENIQVJUX1RZUEVfUElFOiAncGllJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBDSEFSVF9UWVBFX01BUDogJ21hcCcsXG4gICAgLyoqIGNoYXJ0IHBhZGRpbmcgKi9cbiAgICBDSEFSVF9QQURESU5HOiAxMCxcbiAgICAvKiogY2hhcnQgZGVmYXVsdCB3aWR0aCAqL1xuICAgIENIQVJUX0RFRkFVTFRfV0lEVEg6IDUwMCxcbiAgICAvKiogY2hhcnQgZGVmYXVsdCBoZWlnaHQgKi9cbiAgICBDSEFSVF9ERUZBVUxUX0hFSUdIVDogNDAwLFxuICAgIC8qKiBoaWRkZW4gd2lkdGggKi9cbiAgICBISURERU5fV0lEVEg6IDEsXG4gICAgLyoqIHJlbmRlcmVkIHRleHQgcGFkZGluZyAqL1xuICAgIFRFWFRfUEFERElORzogMixcbiAgICAvKiogc2VyaWVzIGV4cGFuZCBzaXplICovXG4gICAgU0VSSUVTX0VYUEFORF9TSVpFOiAxMCxcbiAgICAvKiogc2VyaWVzIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBTRVJJRVNfTEFCRUxfUEFERElORzogNSxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgdGl0bGUgKi9cbiAgICBERUZBVUxUX1RJVExFX0ZPTlRfU0laRTogMTQsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIGF4aXMgdGl0bGUgKi9cbiAgICBERUZBVUxUX0FYSVNfVElUTEVfRk9OVF9TSVpFOiAxMCxcbiAgICAvKiogZGVmYXVsdCBmb250IHNpemUgb2YgbGFiZWwgKi9cbiAgICBERUZBVUxUX0xBQkVMX0ZPTlRfU0laRTogMTIsXG4gICAgLyoqIGRlZmF1bHQgZm9udCBzaXplIG9mIHNlcmllcyBsYWJlbCAqL1xuICAgIERFRkFVTFRfU0VSSUVTX0xBQkVMX0ZPTlRfU0laRTogMTEsXG4gICAgLyoqIGRlZmF1bHQgZ3JhcGggcGx1Z2luXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1BMVUdJTjogJ3JhcGhhZWwnLFxuICAgIC8qKiBkZWZhdWx0IHRpY2sgY29sb3JcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIERFRkFVTFRfVElDS19DT0xPUjogJ2JsYWNrJyxcbiAgICAvKiogZGVmYXVsdCB0aGVtZSBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBERUZBVUxUX1RIRU1FX05BTUU6ICdkZWZhdWx0JyxcbiAgICBNQVhfSEVJR0hUX1dPUkxEOiAnQScsXG4gICAgLyoqIHN0YWNrZWQgb3B0aW9uIHR5cGVzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBTVEFDS0VEX05PUk1BTF9UWVBFOiAnbm9ybWFsJyxcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBTVEFDS0VEX1BFUkNFTlRfVFlQRTogJ3BlcmNlbnQnLFxuICAgIC8qKiBlbXB0eSBheGlzIGxhYmVsICovXG4gICAgRU1QVFlfQVhJU19MQUJFTDogJycsXG4gICAgLyoqIGFuZ2VsICovXG4gICAgQU5HTEVfODU6IDg1LFxuICAgIEFOR0xFXzkwOiA5MCxcbiAgICBBTkdMRV8zNjA6IDM2MCxcbiAgICAvKiogcmFkaWFuICovXG4gICAgUkFEOiBNYXRoLlBJIC8gMTgwLFxuICAgIC8qKiBzZXJpZXMgbGVnZW5kIGFsaWduc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgTEVHRU5EX0FMSUdOX09VVEVSOiAnb3V0ZXInLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIExFR0VORF9BTElHTl9DRU5URVI6ICdjZW50ZXInLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIExFR0VORF9BTElHTl9UT1A6ICd0b3AnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIExFR0VORF9BTElHTl9CT1RUT006ICdib3R0b20nLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIExFR0VORF9BTElHTl9MRUZUOiAnbGVmdCcsXG4gICAgLyoqIHNlcmllcyBvdXRlciBsYWJlbCBwYWRkaW5nICovXG4gICAgU0VSSUVTX09VVEVSX0xBQkVMX1BBRERJTkc6IDIwLFxuICAgIC8qKiBkZWZhdWx0IHJhdGUgb2YgcGllIGdyYXBoICovXG4gICAgUElFX0dSQVBIX0RFRkFVTFRfUkFURTogMC44LFxuICAgIC8qKiBzbWFsbCByYXRlIG9mIHBpZSBncmFwaCAqL1xuICAgIFBJRV9HUkFQSF9TTUFMTF9SQVRFOiAwLjY1LFxuICAgIC8qKiB0aWNrIGNvdW50IGZvciBtYXAgY2hhcnQgbGVnZW5kICovXG4gICAgTUFQX0NIQVJUX0xFR0VORF9USUNLX0NPVU5UOiA0LFxuICAgIC8qKiBkZWZhdWx0IHBvc2l0aW9uIHJhdGlvIG9mIG1hcCBjaGFydCBsYWJlbFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgTUFQX0NIQVJUX0xBQkVMX0RFRkFVTFRfUE9TSVRJT05fUkFUSU86IHtcbiAgICAgICAgeDogMC41LFxuICAgICAgICB5OiAwLjVcbiAgICB9LFxuICAgIC8qKiBkb3QgcmFkaXVzICovXG4gICAgRE9UX1JBRElVUzogNCxcbiAgICAvKiogeUF4aXMgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBZQVhJU19QUk9QUzogWyd0aWNrQ29sb3InLCAndGl0bGUnLCAnbGFiZWwnXSwgLy8geWF4aXMgdGhlbWXsnZgg7IaN7ISxIC0gY2hhcnQgdHlwZSBmaWx0ZXJpbmftlaAg65WMIOyCrOyaqeuQqFxuICAgIC8qKiBzZXJpZXMgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICBTRVJJRVNfUFJPUFM6IFsnbGFiZWwnLCAnY29sb3JzJywgJ2JvcmRlckNvbG9yJywgJ3NpbmdsZUNvbG9ycycsXG4gICAgICAgICdzZWxlY3Rpb25Db2xvcicsICdzdGFydENvbG9yJywgJ2VuZENvbG9yJywgJ292ZXJDb2xvciddLCAvLyBzZXJpZXMgdGhlbWXsnZgg7IaN7ISxIC0gY2hhcnQgdHlwZSBmaWx0ZXJpbmftlaAg65WMIOyCrOyaqeuQqFxuICAgIC8qKiB0aXRsZSBhcmVhIHdpZHRoIHBhZGRpbmcgKi9cbiAgICBUSVRMRV9BUkVBX1dJRFRIX1BBRERJTkc6IDIwLFxuICAgIC8qKiB0b3AgbWFyZ2luIG9mIHggYXhpcyBsYWJlbCAqL1xuICAgIFhBWElTX0xBQkVMX1RPUF9NQVJHSU46IDEwLFxuICAgIC8qKiByaWdodCBwYWRkaW5nIG9mIHZlcnRpY2FsIGxhYmVsICovXG4gICAgVl9MQUJFTF9SSUdIVF9QQURESU5HOiAxMCxcbiAgICAvKiogdG9vbHRpcCBwcmVmaXhcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIFRPT0xUSVBfUFJFRklYOiAndHVpLWNoYXJ0LXRvb2x0aXAnLFxuICAgIC8qKiB0b29sdGlwIHotaW5kZXggKiovXG4gICAgVE9PTFRJUF9aSU5ERVg6IDUwMCxcbiAgICAvKiogdG9vbHRpcCBhbmltYXRpb24gdGltZSAqL1xuICAgIFRPT0xUSVBfQU5JTUFUSU9OX1RJTUU6IDEwMCxcbiAgICAvKiogdG9vbHRpcCBhbmltYXRpb24gdGltZSBmb3IgcGllIGNoYXJ0ICovXG4gICAgVE9PTFRJUF9QSUVfQU5JTUFUSU9OX1RJTUU6IDUwLFxuICAgIC8qKiBtaW5pbXVtIHBpeGVsIHR5cGUgc3RlcCBzaXplICovXG4gICAgTUlOX1BJWEVMX1RZUEVfU1RFUF9TSVpFOiA0MCxcbiAgICAvKiogbWF4aW11bSBwaXhlbCB0eXBlIHN0ZXAgc2l6ZSAqL1xuICAgIE1BWF9QSVhFTF9UWVBFX1NURVBfU0laRTogNjAsXG4gICAgLyoqIHRpY2sgaW5mbyBvZiBwZXJjZW50IHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBQRVJDRU5UX1NUQUNLRURfVElDS19JTkZPOiB7XG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDEwMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiAyNSxcbiAgICAgICAgdGlja0NvdW50OiA1LFxuICAgICAgICBsYWJlbHM6IFswLCAyNSwgNTAsIDc1LCAxMDBdXG4gICAgfSxcbiAgICAvKiogdGljayBpbmZvIG9mIG5lZ2F0aXZlIHBlcmNlbnQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIE5FR0FUSVZFX1BFUkNFTlRfU1RBQ0tFRF9USUNLX0lORk86IHtcbiAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgIG1pbjogLTEwMCxcbiAgICAgICAgICAgIG1heDogMTAwXG4gICAgICAgIH0sXG4gICAgICAgIHN0ZXA6IDI1LFxuICAgICAgICB0aWNrQ291bnQ6IDksXG4gICAgICAgIGxhYmVsczogWy0xMDAsIC03NSwgLTUwLCAtMjUsIDAsIDI1LCA1MCwgNzUsIDEwMF1cbiAgICB9LFxuICAgIC8qKiB0aWNrIGluZm8gb2YgZGl2ZXJnaW5nIHBlcmNlbnQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIERJVkVSR0VOVF9QRVJDRU5UX1NUQUNLRURfVElDS19JTkZPOiB7XG4gICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICBtaW46IC0xMDAsXG4gICAgICAgICAgICBtYXg6IDEwMFxuICAgICAgICB9LFxuICAgICAgICBzdGVwOiAyNSxcbiAgICAgICAgdGlja0NvdW50OiA5LFxuICAgICAgICBsYWJlbHM6IFsxMDAsIDc1LCA1MCwgMjUsIDAsIDI1LCA1MCwgNzUsIDEwMF1cbiAgICB9LFxuICAgIC8qKiB0aXRsZSBhZGQgcGFkZGluZyAqL1xuICAgIFRJVExFX1BBRERJTkc6IDIwLFxuICAgIC8qKiBsZWdlbmQgYXJlYSBwYWRkaW5nICovXG4gICAgTEVHRU5EX0FSRUFfUEFERElORzogMTAsXG4gICAgLyoqIGxlZ2VuZCBjaGVja2JveCB3aWR0aCAqL1xuICAgIExFR0VORF9DSEVDS0JPWF9XSURUSDogMjAsXG4gICAgLyoqIGxlZ2VuZCByZWN0IHdpZHRoICovXG4gICAgTEVHRU5EX1JFQ1RfV0lEVEg6IDEyLFxuICAgIC8qKiBsZ2VuZCBsYWJlbCBsZWZ0IHBhZGRpbmcgKi9cbiAgICBMRUdFTkRfTEFCRUxfTEVGVF9QQURESU5HOiA1LFxuICAgIC8qKiBtYXAgbGVnZW5kIGhlaWdodCAqL1xuICAgIE1BUF9MRUdFTkRfU0laRTogMjAwLFxuICAgIC8qKiBtYXAgbGVnZW5kIGdyYXBoIHNpemUgKi9cbiAgICBNQVBfTEVHRU5EX0dSQVBIX1NJWkU6IDI1LFxuICAgIC8qKiBtYXAgbGVnZW5kIGxhYmVsIHBhZGRpbmcgKi9cbiAgICBNQVBfTEVHRU5EX0xBQkVMX1BBRERJTkc6IDUsXG4gICAgLyoqIEFYSVMgTEFCRUwgUEFERElORyAqL1xuICAgIEFYSVNfTEFCRUxfUEFERElORzogNyxcbiAgICAvKiogcm90YXRpb25zIGRlZ3JlZSBjYW5kaWRhdGVzICovXG4gICAgREVHUkVFX0NBTkRJREFURVM6IFsyNSwgNDUsIDY1LCA4NV0sXG4gICAgLyoqIHhBeGlzIGxhYmVsIGNvbXBhcmUgbWFyZ2luICovXG4gICAgWEFYSVNfTEFCRUxfQ09NUEFSRV9NQVJHSU46IDIwLFxuICAgIC8qKiB4QXhpcyBsYWJlbCBndXR0ZXIgKi9cbiAgICBYQVhJU19MQUJFTF9HVVRURVI6IDIsXG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgbXVsdGlwbGUgbnVtcyBvZiBheGlzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIEFYSVNfU1RBTkRBUkRfTVVMVElQTEVfTlVNUzogWzEsIDIsIDUsIDEwLCAyMCwgNTAsIDEwMF0sXG4gICAgLyoqXG4gICAgICogTGFzdCBzdGFuZGFyZCBtdWx0aXBsZSBudW0gb2YgYXhpc1xuICAgICAqL1xuICAgIEFYSVNfTEFTVF9TVEFOREFSRF9NVUxUSVBMRV9OVU06IDEwMCxcbiAgICAvKiogbGFiZWwgcGFkZGluZyB0b3AgKi9cbiAgICBMQUJFTF9QQURESU5HX1RPUDogMixcbiAgICAvKiogbGluZSBtYXJnaW4gdG9wICovXG4gICAgTElORV9NQVJHSU5fVE9QOiA1LFxuICAgIC8qKiB0b29sdGlwIGdhcCAqL1xuICAgIFRPT0xUSVBfR0FQOiA1LFxuICAgIC8qKiB0b29sdGlwIGRpcmVjdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRDogJ2ZvcndvcmQnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfRElSRUNUSU9OX0NFTlRFUjogJ2NlbnRlcicsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQ6ICdiYWNrd29yZCcsXG4gICAgLyoqIHRvb2x0aXAgYWxpZ24gb3B0aW9uc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0FMSUdOX09QVElPTjogJ2NlbnRlciB0b3AnLFxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIFRPT0xUSVBfREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjogJ3JpZ2h0IG1pZGRsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0dST1VQX0FMSUdOX09QVElPTjogJ3JpZ2h0IG1pZGRsZScsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgVE9PTFRJUF9ERUZBVUxUX0dST1VQX0hPUklaT05UQUxfQUxJR05fT1BUSU9OOiAnY2VudGVyIGJvdHRvbScsXG4gICAgLyoqIGhpZGUgZGVsYXkgKi9cbiAgICBISURFX0RFTEFZOiAyMDBcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNoYXJ0Q29uc3Q7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYVR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGxpbmUgdHlwZSBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1c3RvbUV2ZW50QmFzZSA9IHJlcXVpcmUoJy4vY3VzdG9tRXZlbnRCYXNlJyksXG4gICAgQXJlYVR5cGVEYXRhTW9kZWwgPSByZXF1aXJlKCcuL2FyZWFUeXBlRGF0YU1vZGVsJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBBcmVhVHlwZUN1c3RvbUV2ZW50ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ3VzdG9tRXZlbnRCYXNlLCAvKiogQGxlbmRzIEFyZWFUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBBcmVhVHlwZUN1c3RvbUV2ZW50IGlzIGN1c3RvbSBldmVudCBmb3IgbGluZSB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqIEBjb25zdHJ1Y3RzIEFyZWFUeXBlQ3VzdG9tRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBDdXN0b21FdmVudEJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLmNhbGwodGhpcywgcGFyYW1zKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmlvdXMgZm91bmQgZGF0YVxuICAgICAgICAgKiBAdHlwZSB7bnVsbCB8IG9iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbihzZXJpZXNJbmZvcykge1xuICAgICAgICB2YXIgc2VyaWVzSW5mbyA9IHNlcmllc0luZm9zWzBdO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IG5ldyBBcmVhVHlwZURhdGFNb2RlbChzZXJpZXNJbmZvKTtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLnByb3RvdHlwZS5pbml0Q3VzdG9tRXZlbnREYXRhLmNhbGwodGhpcywgc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW1vdmUuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGJvdW5kID0gZWxUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBsYXllclggPSBlLmNsaWVudFggLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBsYXllclkgPSBlLmNsaWVudFkgLSBib3VuZC50b3AsXG4gICAgICAgICAgICBncm91cEluZGV4ID0gdGhpcy50aWNrQmFzZURhdGFNb2RlbC5maW5kSW5kZXgobGF5ZXJYKSxcbiAgICAgICAgICAgIGZvdW5kRGF0YSA9IHRoaXMuZGF0YU1vZGVsLmZpbmREYXRhKGdyb3VwSW5kZXgsIGxheWVyWSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc0NoYW5nZWQodGhpcy5wcmV2Rm91bmREYXRhLCBmb3VuZERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm91bmREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3Nob3dUb29sdGlwJywgZm91bmREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldkZvdW5kRGF0YSA9IGZvdW5kRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2VvdXQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFUeXBlQ3VzdG9tRXZlbnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQXJlYVR5cGVEYXRhTW9kZWwgaXMgZGF0YSBtb2RlbCBmb3IgYXJlYSB0eXBlIGN1c3RvbSBldmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFyZWFUeXBlRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBBcmVhVHlwZURhdGFNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIEFyZWFUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZSBmb3IgYXJlYSB0eXBlIGN1c3RvbSBldmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBBcmVhVHlwZURhdGFNb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNJbmZvIHNlcmllcyBpbmZvXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mbykge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlRGF0YShzZXJpZXNJbmZvLmRhdGEuZ3JvdXBQb3NpdGlvbnMsIHNlcmllc0luZm8uY2hhcnRUeXBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBhcmVhIHR5cGUgZGF0YSBmb3IgY3VzdG9tIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjYWhydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fSBhcmVhIHR5cGUgZGF0YSBmb3IgY3VzdG9tIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSB0dWkudXRpbC5waXZvdChncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgRGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBJbmRleCBncm91cCBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBpbmRleFxuICAgICAqL1xuICAgIGZpbmREYXRhOiBmdW5jdGlvbihncm91cEluZGV4LCBsYXllclkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICBtaW4gPSAxMDAwMDtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmRhdGFbZ3JvdXBJbmRleF0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMobGF5ZXJZIC0gZGF0YS5ib3VuZC50b3ApO1xuICAgICAgICAgICAgaWYgKG1pbiA+IGRpZmYpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFUeXBlRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEN1c3RvbUV2ZW50QmFzZSBpcyBiYXNlIGNsYXNzIGZvciBldmVudCBoYW5kbGUgbGF5ZXJzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpLFxuICAgIFRpY2tCYXNlRGF0YU1vZGVsID0gcmVxdWlyZSgnLi90aWNrQmFzZURhdGFNb2RlbCcpLFxuICAgIFBvaW50VHlwZURhdGFNb2RlbCA9IHJlcXVpcmUoJy4vcG9pbnRUeXBlRGF0YU1vZGVsJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQ3VzdG9tRXZlbnRCYXNlID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBDdXN0b21FdmVudEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBDdXN0b21FdmVudEJhc2UgaXMgYmFzZSBjbGFzcyBmb3IgY3VzdG9tIGV2ZW50IGNvbXBvbmVudHMuXG4gICAgICogQGNvbnN0cnVjdHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tcbiAgICAgKiAgICAgICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqICAgICAgfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gcGFyYW1zLmlzVmVydGljYWw7XG4gICAgICAgIHRoaXMuZGF0YVByb2Nlc3NvciA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yO1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXZlbnQgaGFuZGxlIGxheWVyIGFyZWFcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjdXN0b21FdmVudENvbnRhaW5lciBjdXN0b20gZXZlbnQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckN1c3RvbUV2ZW50QXJlYTogZnVuY3Rpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkQm91bmQ7XG5cbiAgICAgICAgdGhpcy5kaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY3VzdG9tRXZlbnQnKTtcbiAgICAgICAgdGhpcy50aWNrQmFzZURhdGFNb2RlbCA9IG5ldyBUaWNrQmFzZURhdGFNb2RlbCh0aGlzLmRpbWVuc2lvbiwgZGF0YS50aWNrQ291bnQsIHRoaXMuY2hhcnRUeXBlLCB0aGlzLmlzVmVydGljYWwpO1xuICAgICAgICBleHBhbmRlZEJvdW5kID0gcmVuZGVyVXRpbC5leHBhbmRCb3VuZCh0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCdjdXN0b21FdmVudCcpKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oY3VzdG9tRXZlbnRDb250YWluZXIsIGV4cGFuZGVkQm91bmQuZGltZW5zaW9uKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbihjdXN0b21FdmVudENvbnRhaW5lciwgZXhwYW5kZWRCb3VuZC5wb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBldmVudCBoYW5kbGUgbGF5ZXIgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIHJlbmRlcmluZyBkYXRhXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBjb29yZGluYXRlIGFyZWFcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgJ3R1aS1jaGFydC1zZXJpZXMtY3VzdG9tLWV2ZW50LWFyZWEnKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJDdXN0b21FdmVudEFyZWEoZWwsIGRhdGEpO1xuICAgICAgICB0aGlzLmF0dGFjaEV2ZW50KGVsKTtcbiAgICAgICAgdGhpcy5jdXN0b21FdmVudENvbnRhaW5lciA9IGVsO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbihzZXJpZXNJbmZvcykge1xuICAgICAgICB0aGlzLnBvaW50VHlwZURhdGFNb2RlbCA9IG5ldyBQb2ludFR5cGVEYXRhTW9kZWwoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHBhcmFtIHt7dGlja0NvdW50OiBudW1iZXJ9fSBkYXRhIGRhdGFcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJDdXN0b21FdmVudEFyZWEodGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBldmVudCBoYW5kbGUgbGF5ZXIgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7e3RpY2tDb3VudDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVyZW5kZXIoZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXYgcHJldmlvdXMgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjdXIgY3VycmVudCBkYXRhXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgY2hhbmdlZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWQ6IGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICByZXR1cm4gIXByZXYgfHwgIWN1ciB8fCBwcmV2LmNoYXJ0VHlwZSAhPT0gY3VyLmNoYXJ0VHlwZSB8fFxuICAgICAgICAgICAgcHJldi5pbmRleGVzLmdyb3VwSW5kZXggIT09IGN1ci5pbmRleGVzLmdyb3VwSW5kZXggfHwgcHJldi5pbmRleGVzLmluZGV4ICE9PSBjdXIuaW5kZXhlcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBwb2ludCB0eXBlIGRhdGEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUYXJnZXQgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50WCBtb3VzZSBwb3NpdGlvbiB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFkgbW91c2UgcG9zaXRpb24geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGZvdW5kIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kUG9pbnRUeXBlRGF0YTogZnVuY3Rpb24oZWxUYXJnZXQsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gZWxUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBsYXllclggPSBjbGllbnRYIC0gYm91bmQubGVmdCxcbiAgICAgICAgICAgIGxheWVyWSA9IGNsaWVudFkgLSBib3VuZC50b3AsXG4gICAgICAgICAgICBncm91cEluZGV4ID0gdGhpcy50aWNrQmFzZURhdGFNb2RlbC5maW5kSW5kZXgodGhpcy5pc1ZlcnRpY2FsID8gbGF5ZXJYIDogbGF5ZXJZKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRUeXBlRGF0YU1vZGVsLmZpbmREYXRhKGdyb3VwSW5kZXgsIGxheWVyWCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLCBsYXllclkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZWxlY3RlZCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Vuc2VsZWN0U2VsZWN0ZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHJlbmRlclV0aWwubWFrZUN1c3RvbUV2ZW50TmFtZSgndW5zZWxlY3QnLCB0aGlzLnNlbGVjdGVkRGF0YS5jaGFydFR5cGUsICdzZXJpZXMnKTtcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwgdGhpcy5zZWxlY3RlZERhdGEpO1xuICAgICAgICBkZWxldGUgdGhpcy5zZWxlY3RlZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgY3VzdG9tIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZSkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gcmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKGV2ZW50VHlwZSwgdGhpcy5jaGFydFR5cGUsICdzZXJpZXMnKTtcblxuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2hpZGUnKTtcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmN1c3RvbUV2ZW50Q29udGFpbmVyLCAnaGlkZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGlja1xuICAgICAqIEBwYXJhbSB7bW91c2VldmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgY2xpZW50WCA9IGUuY2xpZW50WCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgZm91bmREYXRhID0gdGhpcy5fZmluZFBvaW50VHlwZURhdGEoZWxUYXJnZXQsIGNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICAgIGlmICghdGhpcy5faXNDaGFuZ2VkKHRoaXMuc2VsZWN0ZWREYXRhLCBmb3VuZERhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNlbGVjdFNlbGVjdGVkRGF0YSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kRGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWREYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zZWxlY3RTZWxlY3RlZERhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyZShyZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3NlbGVjdCcsIGZvdW5kRGF0YS5jaGFydFR5cGUsICdzZXJpZXMnKSwgZm91bmREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gZm91bmREYXRhO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGRvd25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9vbk1vdXNlZG93bjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIHVwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfb25Nb3VzZXVwOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2UgbW92ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Ugb3V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBldmVudFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICovXG4gICAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdjbGljaycsIGVsLCB0dWkudXRpbC5iaW5kKHRoaXMuX29uQ2xpY2ssIHRoaXMpKTtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5iaW5kRXZlbnQoJ21vdXNlZG93bicsIGVsLCB0dWkudXRpbC5iaW5kKHRoaXMuX29uTW91c2Vkb3duLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZXVwJywgZWwsIHR1aS51dGlsLmJpbmQodGhpcy5fb25Nb3VzZXVwLCB0aGlzKSk7XG4gICAgICAgIGV2ZW50TGlzdGVuZXIuYmluZEV2ZW50KCdtb3VzZW1vdmUnLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLl9vbk1vdXNlbW92ZSwgdGhpcykpO1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnbW91c2VvdXQnLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLl9vbk1vdXNlb3V0LCB0aGlzKSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihDdXN0b21FdmVudEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbUV2ZW50QmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBHcm91cFR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGdyb3VwZWQgdG9vbHRpcCBvcHRpb24uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpO1xuXG52YXIgR3JvdXBUeXBlQ3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgR3JvdXBUeXBlQ3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cFR5cGVDdXN0b21FdmVudCBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGdyb3VwZWQgdG9vbHRpcCBvcHRpb24uXG4gICAgICogQGNvbnN0cnVjdHMgR3JvdXBUeXBlQ3VzdG9tRXZlbnRcbiAgICAgKiBAZXh0ZW5kcyBDdXN0b21FdmVudEJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgQ3VzdG9tRXZlbnRCYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3V0IHBvc2l0aW9uIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGF5ZXJYIGxheWVyWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXllclkgbGF5ZXJZXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNPdXRQb3NpdGlvbjogZnVuY3Rpb24obGF5ZXJYLCBsYXllclkpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZGltZW5zaW9uO1xuICAgICAgICByZXR1cm4gbGF5ZXJYIDwgMCB8fCBsYXllclggPiBkaW1lbnNpb24ud2lkdGggfHwgbGF5ZXJZIDwgMCB8fCBsYXllclkgPiBkaW1lbnNpb24uaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZW1vdmUuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIG1vdXNlIGV2ZW50IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2Vtb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlbFRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCxcbiAgICAgICAgICAgIGJvdW5kID0gZWxUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBsYXllclggPSBlLmNsaWVudFggLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGJvdW5kLmxlZnQsXG4gICAgICAgICAgICBsYXllclkgPSBlLmNsaWVudFkgLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc091dFBvc2l0aW9uKGxheWVyWCwgbGF5ZXJZKSkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnRpY2tCYXNlRGF0YU1vZGVsLmZpbmRJbmRleCh0aGlzLmlzVmVydGljYWwgPyBsYXllclggOiBsYXllclkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZW91dCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldkluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2hvd0dyb3VwVG9vbHRpcCcsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHRoaXMudGlja0Jhc2VEYXRhTW9kZWwubWFrZVJhbmdlKGluZGV4LCB0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICAgICAgc2l6ZTogdGhpcy5kaW1lbnNpb25bdGhpcy5pc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnXSxcbiAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsOiB0aGlzLmlzVmVydGljYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlb3V0LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5wcmV2SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cFRvb2x0aXAnLCB0aGlzLnByZXZJbmRleCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFR5cGVDdXN0b21FdmVudDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYXBDaGFydEN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ3VzdG9tRXZlbnRCYXNlID0gcmVxdWlyZSgnLi9jdXN0b21FdmVudEJhc2UnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBNYXBDaGFydEN1c3RvbUV2ZW50ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoQ3VzdG9tRXZlbnRCYXNlLCAvKiogQGxlbmRzIE1hcENoYXJ0Q3VzdG9tRXZlbnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXBDaGFydEN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgbWFwIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtCb3VuZHNNYWtlcn0gcGFyYW1zLmJvdW5kc01ha2VyIGJvdW5kc01ha2VyIGluc3RhbmNlXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRDdXN0b21FdmVudFxuICAgICAqIEBleHRlbmRzIEN1c3RvbUV2ZW50QmFzZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXZlbnQgaGFuZGxlIGxheWVyIGFyZWFcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjdXN0b21FdmVudENvbnRhaW5lciBjdXN0b20gZXZlbnQgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDdXN0b21FdmVudEFyZWE6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5kaW1lbnNpb24pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5wb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2suXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIGRvd25cbiAgICAgKiBAcGFyYW0ge21vdXNlZXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmlzRG93biA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlyZSgnZHJhZ1N0YXJ0TWFwU2VyaWVzJywge1xuICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgdG9wOiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYWcgZW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5jdXN0b21FdmVudENvbnRhaW5lciwgJ2RyYWcnKTtcbiAgICAgICAgdGhpcy5maXJlKCdkcmFnRW5kTWFwU2VyaWVzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIHVwXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuaXNEb3duID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZykge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0VuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTW92ZSkge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdjbGljaycsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNNb3ZlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG1vdmUuXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnKSB7XG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuY3VzdG9tRXZlbnRDb250YWluZXIsICdkcmFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRHJhZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2RyYWdNYXBTZXJpZXMnLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogZS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvcDogZS5jbGllbnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VFdmVudCgnbW92ZScsIGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG91dFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX29uTW91c2VvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnRW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ21vdmUnLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRG93biA9IGZhbHNlO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTWFwQ2hhcnRDdXN0b21FdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRDdXN0b21FdmVudDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBQaWVDaGFydEN1c3RvbUV2ZW50IGlzIGV2ZW50IGhhbmRsZSBsYXllciBmb3IgcGllIGNoYXJ0IHRvb2x0aXAuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKTtcblxudmFyIFBpZUNoYXJ0Q3VzdG9tRXZlbnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhDdXN0b21FdmVudEJhc2UsIC8qKiBAbGVuZHMgUGllQ2hhcnRDdXN0b21FdmVudC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFBpZUNoYXJ0Q3VzdG9tRXZlbnQgaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBwaWUgY2hhcnQgdG9vbHRpcC5cbiAgICAgKiBAY29uc3RydWN0cyBQaWVDaGFydEN1c3RvbUV2ZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyIGluc3RhbmNlXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFybWFzLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBldmVudCBoYW5kbGUgbGF5ZXIgYXJlYVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGN1c3RvbUV2ZW50Q29udGFpbmVyIGN1c3RvbSBldmVudCBjb250YWluZXIgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2RpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSwgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IGJvdW5kIGJvdW5kIG9mIGV2ZW50IGhhbmRsZXIgbGF5ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDdXN0b21FdmVudEFyZWE6IGZ1bmN0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ2N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyRGltZW5zaW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5kaW1lbnNpb24pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGN1c3RvbUV2ZW50Q29udGFpbmVyLCBib3VuZC5wb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGF0YSBvZiBjdXN0b20gZXZlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0Q3VzdG9tRXZlbnREYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2suXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25DbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlIG1vdmUuXG4gICAgICogQHBhcmFtIHttb3VzZWV2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZUV2ZW50KCdtb3ZlJywgZSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihQaWVDaGFydEN1c3RvbUV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWVDaGFydEN1c3RvbUV2ZW50O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBvaW50VHlwZUN1c3RvbUV2ZW4gaXMgZXZlbnQgaGFuZGxlIGxheWVyIGZvciBsaW5lIHR5cGUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBDdXN0b21FdmVudEJhc2UgPSByZXF1aXJlKCcuL2N1c3RvbUV2ZW50QmFzZScpO1xuXG52YXIgUG9pbnRUeXBlQ3VzdG9tRXZlbiA9IHR1aS51dGlsLmRlZmluZUNsYXNzKEN1c3RvbUV2ZW50QmFzZSwgLyoqIEBsZW5kcyBQb2ludFR5cGVDdXN0b21FdmVuLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUG9pbnRUeXBlQ3VzdG9tRXZlbiBpcyBldmVudCBoYW5kbGUgbGF5ZXIgZm9yIGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAY29uc3RydWN0cyBQb2ludFR5cGVDdXN0b21FdmVuXG4gICAgICogQGV4dGVuZHMgQ3VzdG9tRXZlbnRCYXNlXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEN1c3RvbUV2ZW50QmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmV2aW91cyBmb3VuZCBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtudWxsIHwgb2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2Vtb3ZlLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9vbk1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWxUYXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBjbGllbnRYID0gZS5jbGllbnRYIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBmb3VuZERhdGEgPSB0aGlzLl9maW5kUG9pbnRUeXBlRGF0YShlbFRhcmdldCwgY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlZCh0aGlzLnByZXZGb3VuZERhdGEsIGZvdW5kRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvdW5kRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93VG9vbHRpcCcsIGZvdW5kRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZGb3VuZERhdGEgPSBmb3VuZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdXNlb3V0LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudCBvYmplY3RcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfb25Nb3VzZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXZGb3VuZERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnaGlkZVRvb2x0aXAnLCB0aGlzLnByZXZGb3VuZERhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcmV2Rm91bmREYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50VHlwZUN1c3RvbUV2ZW47XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUG9pbnRUeXBlRGF0YU1vZGVsIGlzIGRhdGEgbW9kZSBmb3IgcG9pbnQgdHlwZSBjdXN0b20gZXZlbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogcG9zaXRpb25cbiAqIEB0eXBlZGVmIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBib3VuZFxuICogQHR5cGVkZWYge3tcbiAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICogICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAqfX0gYm91bmRcbiAqL1xuXG4vKipcbiAqIGdyb3VwIGJvdW5kXG4gKiAgQHR5cGVkZWYge0FycmF5LjxBcnJheS48Ym91bmQ+Pn0gZ3JvdXBCb3VuZFxuICovXG5cbi8qKlxuICogZ3JvdXAgcG9zaXRpb25cbiAqICBAdHlwZWRlZiB7QXJyYXkuPEFycmF5Ljxwb3NpdGlvbj4+fSBncm91cFBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBzZXJpZXMgaW5mb1xuICogQHR5cGVkZWYge3tcbiAqICAgICAgY2hhcnRUeXBlOiB7c3RyaW5nfSxcbiAqICAgICAgZGF0YToge1xuICogICAgICAgICAgZ3JvdXBCb3VuZHM6ID9ncm91cEJvdW5kLFxuICogICAgICAgICAgZ3JvdXBWYWx1ZXM6ID9BcnJheS48QXJyYXkuPG51bWJlcj4+LFxuICogICAgICAgICAgZ3JvdXBQb3NpdGlvbnM6ID9ncm91cFBvc2l0aW9uXG4gKiAgICAgIH1cbiAqfX0gc2VyaWVzSW5mb1xuICovXG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICBwcmVkaWNhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3ByZWRpY2F0ZScpO1xuXG52YXIgUG9pbnRUeXBlRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBQb2ludFR5cGVEYXRhTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBQb2ludFR5cGVEYXRhTW9kZWwgaXMgZGF0YSBtb2RlIGZvciBwb2ludCB0eXBlIGN1c3RvbSBldmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBQb2ludFR5cGVEYXRhTW9kZWxcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzZXJpZXNJbmZvPn0gc2VyaWVzSW5mb3Mgc2VyaWVzIGluZm9zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oc2VyaWVzSW5mb3MpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fbWFrZURhdGEoc2VyaWVzSW5mb3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNvb3JkaW5hdGUgZGF0YSBhYm91dCBiYXIgdHlwZSBncmFwaFxuICAgICAqIEBwYXJhbSB7Z3JvdXBCb3VuZH0gZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fSBjb29yZGluYXRlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUmVjdFR5cGVDb29yZGluYXRlRGF0YTogZnVuY3Rpb24oZ3JvdXBCb3VuZHMsIGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihfYm91bmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kO1xuICAgICAgICAgICAgICAgIGlmICghX2JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvdW5kID0gX2JvdW5kLmVuZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYm91bmQubGVmdCArIGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhIGFib3V0IGRvdCB0eXBlIGdyYXBoXG4gICAgICogQHBhcmFtIHtncm91cFBvc2l0aW9uc30gZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGNvb3JkaW5hdGUgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEb3RUeXBlQ29vcmRpbmF0ZURhdGE6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zLCBjaGFydFR5cGUpIHtcbiAgICAgICAgaWYgKCFncm91cFBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0dWkudXRpbC5waXZvdChncm91cFBvc2l0aW9ucyksIGZ1bmN0aW9uKHBvc2l0aW9ucywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3VuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuRE9UX1JBRElVUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5ET1RfUkFESVVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHBvc2l0aW9uLmxlZnQgKyBjaGFydENvbnN0LkRPVF9SQURJVVMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHBvc2l0aW9uLnRvcCArIGNoYXJ0Q29uc3QuRE9UX1JBRElVU1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSm9pbiBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxBcnJheS48b2JqZWN0Pj4+fSBncm91cERhdGEgZ3JvdXAgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBqb2luZWQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2pvaW5EYXRhOiBmdW5jdGlvbihncm91cERhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGdyb3VwRGF0YSwgZnVuY3Rpb24oY29vcmREYXRhKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY29vcmREYXRhLCBmdW5jdGlvbihkYXRhLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHRzW2luZGV4XS5jb25jYXQoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY29vcmRpbmF0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHNlcmllc0luZm8+fSBzZXJpZXNJbmZvcyBzZXJpZXMgaW5mb3NcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gY29vcmRpbmF0ZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZURhdGE6IGZ1bmN0aW9uKHNlcmllc0luZm9zKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlRGF0YTtcbiAgICAgICAgc2VyaWVzSW5mb3MucmV2ZXJzZSgpO1xuICAgICAgICBjb29yZGluYXRlRGF0YSA9IHR1aS51dGlsLm1hcChzZXJpZXNJbmZvcywgZnVuY3Rpb24oaW5mbykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KGluZm8uY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21ha2VEb3RUeXBlQ29vcmRpbmF0ZURhdGEoaW5mby5kYXRhLmdyb3VwUG9zaXRpb25zLCBpbmZvLmNoYXJ0VHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21ha2VSZWN0VHlwZUNvb3JkaW5hdGVEYXRhKGluZm8uZGF0YS5ncm91cEJvdW5kcywgaW5mby5jaGFydFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luRGF0YShjb29yZGluYXRlRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdG9vbHRpcCBkYXRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWCBtb3VzZSBwb3NpdGlvbiB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxheWVyWSBtb3VzZSBwb3NpdGlvbiB5XG4gICAgICogQHJldHVybnMge29iamVjdH0gdG9vbHRpcCBkYXRhXG4gICAgICovXG4gICAgZmluZERhdGE6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGxheWVyWCwgbGF5ZXJZKSB7XG4gICAgICAgIHZhciBtaW4gPSAxMDAwMCxcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICBjYW5kaWRhdGVzO1xuXG4gICAgICAgIGlmIChncm91cEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxheWVyWCwgbGF5ZXJZ66W8IO2PrO2VqO2VmOuKlCBkYXRhIOy2lOy2nFxuICAgICAgICBjYW5kaWRhdGVzID0gdHVpLnV0aWwuZmlsdGVyKHRoaXMuZGF0YVtncm91cEluZGV4XSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGJvdW5kID0gZGF0YSAmJiBkYXRhLmJvdW5kO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kICYmIGJvdW5kLmxlZnQgPD0gbGF5ZXJYICYmIGJvdW5kLnJpZ2h0ID49IGxheWVyWCAmJiBib3VuZC50b3AgPD0gbGF5ZXJZICYmIGJvdW5kLmJvdHRvbSA+PSBsYXllclk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIOy2lOy2nOuQnCBkYXRhIOykkSB0b3DsnbQgbGF5ZXJZ7JmAIOqwgOyepSDqsIDquYzsmrQgZGF0YSDssL7slYTrgrTquLBcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMobGF5ZXJZIC0gZGF0YS5zZW5kRGF0YS5ib3VuZC50b3ApO1xuICAgICAgICAgICAgaWYgKG1pbiA+IGRpZmYpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBkaWZmO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGEuc2VuZERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUeXBlRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRpY2tCYXNlRGF0YU1vZGVsIGlzIHRpY2sgYmFzZSBkYXRhIG1vZGVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKTtcblxudmFyIFRpY2tCYXNlRGF0YU1vZGVsID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBUaWNrQmFzZURhdGFNb2RlbC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFRpY2tCYXNlRGF0YU1vZGVsIGlzIHRpY2sgYmFzZSBkYXRhIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQGNvbnN0cnVjdHMgVGlja0Jhc2VEYXRhTW9kZWxcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihkaW1lbnNpb24sIHRpY2tDb3VudCwgY2hhcnRUeXBlLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX21ha2VEYXRhKGRpbWVuc2lvbiwgdGlja0NvdW50LCBjaGFydFR5cGUsIGlzVmVydGljYWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgYmFzZSBkYXRhIGFib3V0IGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHRpY2sgYmFzZSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxpbmVUeXBlRGF0YTogZnVuY3Rpb24od2lkdGgsIHRpY2tDb3VudCkge1xuICAgICAgICB2YXIgdGlja0ludGVydmFsID0gKHdpZHRoICsgMSkgLyAodGlja0NvdW50IC0gMSksXG4gICAgICAgICAgICBoYWxmSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwgLyAyLFxuICAgICAgICAgICAgcmFuZ2VzID0gdHVpLnV0aWwubWFwKHR1aS51dGlsLnJhbmdlKDAsIHRpY2tDb3VudCksIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBpbmRleCAqIHRpY2tJbnRlcnZhbCAtIGhhbGZJbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBpbmRleCAqIHRpY2tJbnRlcnZhbCArIGhhbGZJbnRlcnZhbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmFuZ2VzW3RpY2tDb3VudCAtIDFdLm1heCAtPSAxO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgYmFzZSBkYXRhIGFib3V0IG5vbiBsaW5lIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgd2lkdGggb3IgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5fSB0aWNrIGJhc2UgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxEYXRhOiBmdW5jdGlvbihzaXplLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRpY2tDb3VudCAtIDEsXG4gICAgICAgICAgICB0aWNrSW50ZXJ2YWwgPSBzaXplIC8gbGVuLFxuICAgICAgICAgICAgcHJldiA9IDA7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodHVpLnV0aWwucmFuZ2UoMCwgbGVuKSwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBtYXggPSB0dWkudXRpbC5taW4oW3NpemUsIChpbmRleCArIDEpICogdGlja0ludGVydmFsXSksXG4gICAgICAgICAgICAgICAgbGltaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbjogcHJldixcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJldiA9IG1heDtcbiAgICAgICAgICAgIHJldHVybiBsaW1pdDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGljayBiYXNlIGRhdGEgZm9yIGN1c3RvbSBldmVudC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdGljayBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlRGF0YTogZnVuY3Rpb24oZGltZW5zaW9uLCB0aWNrQ291bnQsIGNoYXJ0VHlwZSwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgc2l6ZVR5cGUgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnLFxuICAgICAgICAgICAgZGF0YTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQoY2hhcnRUeXBlKSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX21ha2VMaW5lVHlwZURhdGEoZGltZW5zaW9uW3NpemVUeXBlXSwgdGlja0NvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9tYWtlTm9ybWFsRGF0YShkaW1lbnNpb25bc2l6ZVR5cGVdLCB0aWNrQ291bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50VmFsdWUgbW91c2UgcG9zaXRpb24gcG9pbnQgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBncm91cCBpbmRleFxuICAgICAqL1xuICAgIGZpbmRJbmRleDogZnVuY3Rpb24ocG9pbnRWYWx1ZSkge1xuICAgICAgICB2YXIgZm91bmRJbmRleCA9IC0xO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5kYXRhLCBmdW5jdGlvbihsaW1pdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChsaW1pdC5taW4gPCBwb2ludFZhbHVlICYmIGxpbWl0Lm1heCA+PSBwb2ludFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm91bmRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kSW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aWNrIGJhc2UgZGF0YSBsZW5ndGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVuZ3RoXG4gICAgICovXG4gICAgZ2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcmFuZ2Ugb2YgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgdHlwZSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbWFrZVJhbmdlOiBmdW5jdGlvbihpbmRleCwgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IHRoaXMuZGF0YVtpbmRleF0sXG4gICAgICAgICAgICByYW5nZSwgY2VudGVyO1xuICAgICAgICBpZiAocHJlZGljYXRlLmlzTGluZVR5cGVDaGFydChjaGFydFR5cGUpKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBwYXJzZUludChsaW1pdC5tYXggLSAobGltaXQubWF4IC0gbGltaXQubWluKSAvIDIsIDEwKTtcbiAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBjZW50ZXIsXG4gICAgICAgICAgICAgICAgZW5kOiBjZW50ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbGltaXQubWluLFxuICAgICAgICAgICAgICAgIGVuZDogbGltaXQubWF4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpY2tCYXNlRGF0YU1vZGVsO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBDaGFydCBmYWN0b3J5IHBsYXkgcm9sZSByZWdpc3RlciBjaGFydC5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IGNoYXJ0IGZyb20gdGhpcyBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRzID0ge30sXG4gICAgZmFjdG9yeSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjaGFydCBpbnN0YW5jZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGNoYXJ0IGRhdGFcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgY2hhcnQgb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBjaGFydCBpbnN0YW5jZTtcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24oY2hhcnRUeXBlLCBkYXRhLCB0aGVtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIENoYXJ0ID0gY2hhcnRzW2NoYXJ0VHlwZV0sXG4gICAgICAgICAgICAgICAgY2hhcnQ7XG5cbiAgICAgICAgICAgIGlmICghQ2hhcnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgY2hhcnRUeXBlICsgJyBjaGFydC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hhcnQgPSBuZXcgQ2hhcnQoZGF0YSwgdGhlbWUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGNoYXJ0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXIgdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge2NsYXNzfSBDaGFydENsYXNzIGNoYXJ0IGNsYXNzXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oY2hhcnRUeXBlLCBDaGFydENsYXNzKSB7XG4gICAgICAgICAgICBjaGFydHNbY2hhcnRUeXBlXSA9IENoYXJ0Q2xhc3M7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgIE1hcCBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwcyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBHZXQgbWFwIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWUgbWFwIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG1hcCBkYXRhXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihtYXBOYW1lKSB7XG4gICAgICAgIHZhciBkYXRhID0gbWFwc1ttYXBOYW1lXTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGV4aXN0ICcgKyBtYXBOYW1lICsgJyBtYXAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgTWFwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXBOYW1lIG1hcCBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBtYXAgZGF0YVxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihtYXBOYW1lLCBkYXRhKSB7XG4gICAgICAgIG1hcHNbbWFwTmFtZV0gPSBkYXRhO1xuICAgIH1cbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgIFBsdWdpbiBmYWN0b3J5IHBsYXkgcm9sZSByZWdpc3RlciByZW5kZXJpbmcgcGx1Z2luLlxuICogICAgICAgICAgICAgICAgQWxzbywgeW91IGNhbiBnZXQgcGx1Z2luIGZyb20gdGhpcyBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGx1Z2lucyA9IHt9LFxuICAgIGZhY3RvcnkgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZ3JhcGggcmVuZGVyZXIuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsaWJUeXBlIHR5cGUgb2YgZ3JhcGggbGlicmFyeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gcmVuZGVyZXIgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24obGliVHlwZSwgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tsaWJUeXBlXSxcbiAgICAgICAgICAgICAgICBSZW5kZXJlciwgcmVuZGVyZXI7XG5cbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgZXhpc3QgJyArIGxpYlR5cGUgKyAnIHBsdWdpbi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgUmVuZGVyZXIgPSBwbHVnaW5bY2hhcnRUeXBlXTtcbiAgICAgICAgICAgIGlmICghUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgY2hhcnRUeXBlICsgJyBjaGFydCByZW5kZXJlci4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGx1Z2luIHJlZ2lzdGVyLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGliVHlwZSB0eXBlIG9mIGdyYXBoIGxpYnJhcnlcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHBsdWdpbiBwbHVnaW4gdG8gY29udHJvbCBsaWJyYXJ5XG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24obGliVHlwZSwgcGx1Z2luKSB7XG4gICAgICAgICAgICBwbHVnaW5zW2xpYlR5cGVdID0gcGx1Z2luO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3ICBUaGVtZSBmYWN0b3J5IHBsYXkgcm9sZSByZWdpc3RlciB0aGVtZS5cbiAqICAgICAgICAgICAgICAgIEFsc28sIHlvdSBjYW4gZ2V0IHRoZW1lIGZyb20gdGhpcyBmYWN0b3J5LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZGVmYXVsdFRoZW1lID0gcmVxdWlyZSgnLi4vdGhlbWVzL2RlZmF1bHRUaGVtZScpO1xuXG52YXIgdGhlbWVzID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGhlbWVOYW1lIHRoZW1lIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGVtZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHRoZW1lTmFtZSkge1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGVtZXNbdGhlbWVOYW1lXTtcblxuICAgICAgICBpZiAoIXRoZW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBleGlzdCAnICsgdGhlbWVOYW1lICsgJyB0aGVtZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlbWUgcmVnaXN0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRoZW1lTmFtZSB0aGVtZSBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRoZW1lTmFtZSwgdGhlbWUpIHtcbiAgICAgICAgdmFyIHRhcmdldEl0ZW1zO1xuICAgICAgICB0aGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhlbWUpKTtcblxuICAgICAgICBpZiAodGhlbWVOYW1lICE9PSBjaGFydENvbnN0LkRFRkFVTFRfVEhFTUVfTkFNRSkge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLl9pbml0VGhlbWUodGhlbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SXRlbXMgPSB0aGlzLl9nZXRJbmhlcml0VGFyZ2V0VGhlbWVJdGVtcyh0aGVtZSk7XG5cbiAgICAgICAgdGhpcy5faW5oZXJpdFRoZW1lRm9udCh0aGVtZSwgdGFyZ2V0SXRlbXMpO1xuICAgICAgICB0aGlzLl9jb3B5Q29sb3JJbmZvKHRoZW1lKTtcbiAgICAgICAgdGhlbWVzW3RoZW1lTmFtZV0gPSB0aGVtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdCB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIF9pbml0VGhlbWU6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBjbG9uZVRoZW1lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWZhdWx0VGhlbWUpKSxcbiAgICAgICAgICAgIG5ld1RoZW1lO1xuXG4gICAgICAgIHRoaXMuX2NvbmNhdERlZmF1bHRDb2xvcnModGhlbWUsIGNsb25lVGhlbWUuc2VyaWVzLmNvbG9ycylcbiAgICAgICAgbmV3VGhlbWUgPSB0aGlzLl9vdmVyd3JpdGVUaGVtZSh0aGVtZSwgY2xvbmVUaGVtZSk7XG5cbiAgICAgICAgbmV3VGhlbWUgPSB0aGlzLl9jb3B5UHJvcGVydHkoe1xuICAgICAgICAgICAgcHJvcE5hbWU6ICd5QXhpcycsXG4gICAgICAgICAgICBmcm9tVGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9UaGVtZTogbmV3VGhlbWUsXG4gICAgICAgICAgICByZWplY3Rpb25Qcm9wczogY2hhcnRDb25zdC5ZQVhJU19QUk9QU1xuICAgICAgICB9KTtcblxuICAgICAgICBuZXdUaGVtZSA9IHRoaXMuX2NvcHlQcm9wZXJ0eSh7XG4gICAgICAgICAgICBwcm9wTmFtZTogJ3NlcmllcycsXG4gICAgICAgICAgICBmcm9tVGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9UaGVtZTogbmV3VGhlbWUsXG4gICAgICAgICAgICByZWplY3Rpb25Qcm9wczogY2hhcnRDb25zdC5TRVJJRVNfUFJPUFNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ld1RoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgY2hhcnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCB0YXJnZXQgY2hhcnRzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcmVqZWN0aW9uUHJvcHMgcmVqZWN0IHByb3BlcnR5XG4gICAgICogQHJldHVybnMge09iamVjdH0gZmlsdGVyZWQgY2hhcnRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbHRlckNoYXJ0VHlwZXM6IGZ1bmN0aW9uKHRhcmdldCwgcmVqZWN0aW9uUHJvcHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHR1aS51dGlsLmZpbHRlcih0YXJnZXQsIGZ1bmN0aW9uKGl0ZW0sIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5pbkFycmF5KG5hbWUsIHJlamVjdGlvblByb3BzKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25jYXQgY29sb3JzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSB0aGVtZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHNlcmllc0NvbG9ycyBzZXJpZXMgY29sb3JzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29uY2F0Q29sb3JzOiBmdW5jdGlvbih0aGVtZSwgc2VyaWVzQ29sb3JzKSB7XG4gICAgICAgIGlmICh0aGVtZS5jb2xvcnMpIHtcbiAgICAgICAgICAgIHRoZW1lLmNvbG9ycyA9IHRoZW1lLmNvbG9ycy5jb25jYXQoc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5zaW5nbGVDb2xvcnMpIHtcbiAgICAgICAgICAgIHRoZW1lLnNpbmdsZUNvbG9ycyA9IHRoZW1lLnNpbmdsZUNvbG9ycy5jb25jYXQoc2VyaWVzQ29sb3JzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25jYXQgZGVmYXVsdCBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ29sb3JzIHNlcmllcyBjb2xvcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb25jYXREZWZhdWx0Q29sb3JzOiBmdW5jdGlvbih0aGVtZSwgc2VyaWVzQ29sb3JzKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGVzO1xuXG4gICAgICAgIGlmICghdGhlbWUuc2VyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydFR5cGVzID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS5zZXJpZXMsIGNoYXJ0Q29uc3QuU0VSSUVTX1BST1BTKTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmtleXMoY2hhcnRUeXBlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25jYXRDb2xvcnModGhlbWUuc2VyaWVzLCBzZXJpZXNDb2xvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChjaGFydFR5cGVzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uY2F0Q29sb3JzKGl0ZW0sIHNlcmllc0NvbG9ycyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZnJvbSBmcm9tIHRoZW1lIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRvIHRvIHRoZW1lIHByb3BlcnR5XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmVzdWx0IHByb3BlcnR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb3ZlcndyaXRlVGhlbWU6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2godG8sIGZ1bmN0aW9uKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgdmFyIGZyb21JdGVtID0gZnJvbVtrZXldO1xuICAgICAgICAgICAgaWYgKCFmcm9tSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkoZnJvbUl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21JdGVtLnNsaWNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR1aS51dGlsLmlzT2JqZWN0KGZyb21JdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX292ZXJ3cml0ZVRoZW1lKGZyb21JdGVtLCBpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21JdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcHkgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnByb3BOYW1lIHByb3BlcnR5IG5hbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuZnJvbVRoZW1lIGZyb20gcHJvcGVydHlcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudG9UaGVtZSB0cCBwcm9wZXJ0eVxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGFyYW1zLnJlamVjdGlvblByb3BzIHJlamVjdCBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybnMge29iamVjdH0gY29waWVkIHByb3BlcnR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY29weVByb3BlcnR5OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGNoYXJ0VHlwZXM7XG5cbiAgICAgICAgaWYgKCFwYXJhbXMudG9UaGVtZVtwYXJhbXMucHJvcE5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLnRvVGhlbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydFR5cGVzID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyhwYXJhbXMuZnJvbVRoZW1lW3BhcmFtcy5wcm9wTmFtZV0sIHBhcmFtcy5yZWplY3Rpb25Qcm9wcyk7XG4gICAgICAgIGlmICh0dWkudXRpbC5rZXlzKGNoYXJ0VHlwZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChjaGFydFR5cGVzLCBmdW5jdGlvbihpdGVtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xvbmVUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFRoZW1lW3BhcmFtcy5wcm9wTmFtZV0pKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZnJvbVRoZW1lW3BhcmFtcy5wcm9wTmFtZV1ba2V5XSA9IHRoaXMuX292ZXJ3cml0ZVRoZW1lKGl0ZW0sIGNsb25lVGhlbWUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHBhcmFtcy50b1RoZW1lW3BhcmFtcy5wcm9wTmFtZV0gPSBwYXJhbXMuZnJvbVRoZW1lW3BhcmFtcy5wcm9wTmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW1zLnRvVGhlbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcHkgY29sb3IgaW5mbyB0byBsZWdlbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzVGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxlZ2VuZFRoZW1lIGxlZ2VuZCB0aGVtZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBjb2xvcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb3B5Q29sb3JJbmZvVG9PdGhlcjogZnVuY3Rpb24oc2VyaWVzVGhlbWUsIGxlZ2VuZFRoZW1lLCBjb2xvcnMpIHtcbiAgICAgICAgbGVnZW5kVGhlbWUuY29sb3JzID0gY29sb3JzIHx8IHNlcmllc1RoZW1lLmNvbG9ycztcbiAgICAgICAgaWYgKHNlcmllc1RoZW1lLnNpbmdsZUNvbG9ycykge1xuICAgICAgICAgICAgbGVnZW5kVGhlbWUuc2luZ2xlQ29sb3JzID0gc2VyaWVzVGhlbWUuc2luZ2xlQ29sb3JzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXJpZXNUaGVtZS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgbGVnZW5kVGhlbWUuYm9yZGVyQ29sb3IgPSBzZXJpZXNUaGVtZS5ib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VyaWVzVGhlbWUuc2VsZWN0aW9uQ29sb3IpIHtcbiAgICAgICAgICAgIGxlZ2VuZFRoZW1lLnNlbGVjdGlvbkNvbG9yID0gc2VyaWVzVGhlbWUuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRhcmdldCBpdGVtcyBhYm91dCBmb250IGluaGVyaXQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHJldHVybnMge0FycmF5LjxvYmplY3Q+fSB0YXJnZXQgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRJbmhlcml0VGFyZ2V0VGhlbWVJdGVtczogZnVuY3Rpb24odGhlbWUpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gW1xuICAgICAgICAgICAgICAgIHRoZW1lLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRoZW1lLnhBeGlzLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRoZW1lLnhBeGlzLmxhYmVsLFxuICAgICAgICAgICAgICAgIHRoZW1lLmxlZ2VuZC5sYWJlbFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHlBeGlzQ2hhcnRUeXBlVGhlbXMgPSB0aGlzLl9maWx0ZXJDaGFydFR5cGVzKHRoZW1lLnlBeGlzLCBjaGFydENvbnN0LllBWElTX1BST1BTKSxcbiAgICAgICAgICAgIHNlcmllc0NoYXJ0VHlwZVRoZW1lcyA9IHRoaXMuX2ZpbHRlckNoYXJ0VHlwZXModGhlbWUuc2VyaWVzLCBjaGFydENvbnN0LlNFUklFU19QUk9QUyk7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKHlBeGlzQ2hhcnRUeXBlVGhlbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh0aGVtZS55QXhpcy50aXRsZSk7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHRoZW1lLnlBeGlzLmxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goeUF4aXNDaGFydFR5cGVUaGVtcywgZnVuY3Rpb24oY2hhdFR5cGVUaGVtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hhdFR5cGVUaGVtZS50aXRsZSk7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChjaGF0VHlwZVRoZW1lLmxhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKHNlcmllc0NoYXJ0VHlwZVRoZW1lcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHRoZW1lLnNlcmllcy5sYWJlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKHNlcmllc0NoYXJ0VHlwZVRoZW1lcywgZnVuY3Rpb24oY2hhdFR5cGVUaGVtZSkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY2hhdFR5cGVUaGVtZS5sYWJlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaGVyaXQgdGhlbWUgZm9udC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSB0YXJnZXRJdGVtcyB0YXJnZXQgdGhlbWUgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbmhlcml0VGhlbWVGb250OiBmdW5jdGlvbih0aGVtZSwgdGFyZ2V0SXRlbXMpIHtcbiAgICAgICAgdmFyIGJhc2VGb250ID0gdGhlbWUuY2hhcnQuZm9udEZhbWlseTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGFyZ2V0SXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5mb250RmFtaWx5ID0gYmFzZUZvbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IGNvbG9yIGluZm8uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRoZW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgX2NvcHlDb2xvckluZm86IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBzZXJpZXNDaGFydFR5cGVzID0gdGhpcy5fZmlsdGVyQ2hhcnRUeXBlcyh0aGVtZS5zZXJpZXMsIGNoYXJ0Q29uc3QuU0VSSUVTX1BST1BTKTtcbiAgICAgICAgaWYgKCF0dWkudXRpbC5rZXlzKHNlcmllc0NoYXJ0VHlwZXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIodGhlbWUuc2VyaWVzLCB0aGVtZS5sZWdlbmQpO1xuICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIodGhlbWUuc2VyaWVzLCB0aGVtZS50b29sdGlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzQ2hhcnRUeXBlcywgZnVuY3Rpb24oaXRlbSwgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhlbWUubGVnZW5kW2NoYXJ0VHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGVtZS50b29sdGlwW2NoYXJ0VHlwZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3B5Q29sb3JJbmZvVG9PdGhlcihpdGVtLCB0aGVtZS5sZWdlbmRbY2hhcnRUeXBlXSwgaXRlbS5jb2xvcnMgfHwgdGhlbWUubGVnZW5kLmNvbG9ycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29weUNvbG9ySW5mb1RvT3RoZXIoaXRlbSwgdGhlbWUudG9vbHRpcFtjaGFydFR5cGVdLCBpdGVtLmNvbG9ycyB8fCB0aGVtZS50b29sdGlwLmNvbG9ycyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoZW1lLmxlZ2VuZC5jb2xvcnM7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoZW1lLnRvb2x0aXAuY29sb3JzO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEF4aXMgRGF0YSBNYWtlclxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi9wcmVkaWNhdGUnKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi9jYWxjdWxhdG9yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG52YXIgYWJzID0gTWF0aC5hYnMsXG4gICAgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxuLyoqXG4gKiBBeGlzIGRhdGEgbWFrZXIuXG4gKiBAbW9kdWxlIGF4aXNEYXRhTWFrZXJcbiAqL1xudmFyIGF4aXNEYXRhTWFrZXIgPSB7XG4gICAgLyoqXG4gICAgICogTWFrZSBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbEludGVydmFsIGxhYmVsIGludGVydmFsXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBsYWJlbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsSW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGxhc3RJbmRleDtcbiAgICAgICAgaWYgKCFsYWJlbEludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgaW5kZXggPCBsYXN0SW5kZXggJiYgKGluZGV4ICUgbGFiZWxJbnRlcnZhbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBjaGFydENvbnN0LkVNUFRZX0FYSVNfTEFCRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGEgYWJvdXQgbGFiZWwgYXhpcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBjaGFydCBsYWJlbHNcbiAgICAgKiAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsYWJlbHM6IEFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICB2YWxpZFRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgaXNMYWJlbEF4aXM6IGJvb2xlYW4sXG4gICAgICogICAgICBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogfX0gYXhpcyBkYXRhXG4gICAgICovXG4gICAgbWFrZUxhYmVsQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGlja0NvdW50ID0gcGFyYW1zLmxhYmVscy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFwYXJhbXMuYWxpZ25lZCkge1xuICAgICAgICAgICAgdGlja0NvdW50ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWxzOiB0aGlzLl9tYWtlTGFiZWxzKHBhcmFtcy5sYWJlbHMsIG9wdGlvbnMubGFiZWxJbnRlcnZhbCksXG4gICAgICAgICAgICB0aWNrQ291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICAgIHZhbGlkVGlja0NvdW50OiAwLFxuICAgICAgICAgICAgaXNMYWJlbEF4aXM6IHRydWUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiAhIXBhcmFtcy5pc1ZlcnRpY2FsLFxuICAgICAgICAgICAgYWxpZ25lZDogISFwYXJhbXMuYWxpZ25lZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRhdGEgYWJvdXQgdmFsdWUgYXhpcy5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcGFyYW1zLnZhbHVlcyBjaGFydCB2YWx1ZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5zZXJpZXNEaW1lbnNpb24gc2VyaWVzIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48ZnVuY3Rpb24+fSBwYXJhbXMuZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc3RhY2tlZCBzdGFja2VkIG9wdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5vcHRpb25zIGF4aXMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsYWJlbHM6IEFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICB2YWxpZFRpY2tDb3VudDogbnVtYmVyLFxuICAgICAqICAgICAgaXNMYWJlbEF4aXM6IGJvb2xlYW4sXG4gICAgICogICAgICBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sXG4gICAgICogICAgICBpc1ZlcnRpY2FsOiBib29sZWFuXG4gICAgICogfX0gYXhpcyBkYXRhXG4gICAgICovXG4gICAgbWFrZVZhbHVlQXhpc0RhdGE6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgaXNWZXJ0aWNhbCA9ICEhcGFyYW1zLmlzVmVydGljYWwsXG4gICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQgPSAhIXBhcmFtcy5pc1Bvc2l0aW9uUmlnaHQsXG4gICAgICAgICAgICBpc0FsbG93ZWRTdGFja2VkT3B0aW9uID0gcHJlZGljYXRlLmlzQWxsb3dlZFN0YWNrZWRPcHRpb24ocGFyYW1zLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSBwYXJhbXMuZm9ybWF0RnVuY3Rpb25zLFxuICAgICAgICAgICAgbWludXNTdW0sIHRpY2tJbmZvO1xuXG4gICAgICAgIGlmIChpc0FsbG93ZWRTdGFja2VkT3B0aW9uICYmIHByZWRpY2F0ZS5pc1BlcmNlbnRTdGFja2VkKHBhcmFtcy5zdGFja2VkT3B0aW9uKSkge1xuICAgICAgICAgICAgbWludXNTdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKGNvbmNhdC5hcHBseShbXSwgcGFyYW1zLnZhbHVlcykpO1xuICAgICAgICAgICAgaWYgKG1pbnVzU3VtIDwgMCkge1xuICAgICAgICAgICAgICAgIHRpY2tJbmZvID0gcGFyYW1zLmRpdmVyZ2luZ09wdGlvbiA/IGNoYXJ0Q29uc3QuRElWRVJHRU5UX1BFUkNFTlRfU1RBQ0tFRF9USUNLX0lORk9cbiAgICAgICAgICAgICAgICAgICAgOiBjaGFydENvbnN0Lk5FR0FUSVZFX1BFUkNFTlRfU1RBQ0tFRF9USUNLX0lORk87XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpY2tJbmZvID0gY2hhcnRDb25zdC5QRVJDRU5UX1NUQUNLRURfVElDS19JTkZPO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gW2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyUnO1xuICAgICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrSW5mbyA9IHRoaXMuX2dldFRpY2tJbmZvKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRoaXMuX21ha2VCYXNlVmFsdWVzKHBhcmFtcy52YWx1ZXMsIGlzQWxsb3dlZFN0YWNrZWRPcHRpb24sIHBhcmFtcy5zdGFja2VkT3B0aW9uKSxcbiAgICAgICAgICAgICAgICBzZXJpZXNEaW1lbnNpb246IHBhcmFtcy5zZXJpZXNEaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgICAgICBpc1Bvc2l0aW9uUmlnaHQ6IGlzUG9zaXRpb25SaWdodCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IHBhcmFtcy5jaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgZGl2ZXJnaW5nT3B0aW9uOiBwYXJhbXMuZGl2ZXJnaW5nT3B0aW9uLFxuICAgICAgICAgICAgICAgIHRpY2tDb3VudDogcGFyYW1zLnRpY2tDb3VudFxuICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWxzOiB0aGlzLmZvcm1hdExhYmVscyh0aWNrSW5mby5sYWJlbHMsIGZvcm1hdEZ1bmN0aW9ucyksXG4gICAgICAgICAgICB0aWNrQ291bnQ6IHRpY2tJbmZvLnRpY2tDb3VudCxcbiAgICAgICAgICAgIHZhbGlkVGlja0NvdW50OiB0aWNrSW5mby50aWNrQ291bnQsXG4gICAgICAgICAgICBsaW1pdDogdGlja0luZm8ubGltaXQsXG4gICAgICAgICAgICBzdGVwOiB0aWNrSW5mby5zdGVwLFxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogaXNWZXJ0aWNhbCxcbiAgICAgICAgICAgIGlzUG9zaXRpb25SaWdodDogaXNQb3NpdGlvblJpZ2h0LFxuICAgICAgICAgICAgYWxpZ25lZDogISFwYXJhbXMuYWxpZ25lZFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGdyb3VwVmFsdWVzIGdyb3VwIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBbGxvd2VkU3RhY2tlZE9wdGlvbiB3aGV0aGVyIGFsbG93ZWQgc3RhY2tlZCBvcHRpb24gb3Igbm90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gYmFzZSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZVZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIGlzQWxsb3dlZFN0YWNrZWRPcHRpb24sIHN0YWNrZWQpIHtcbiAgICAgICAgaWYgKGlzQWxsb3dlZFN0YWNrZWRPcHRpb24gJiYgcHJlZGljYXRlLmlzTm9ybWFsU3RhY2tlZChzdGFja2VkKSkge1xuICAgICAgICAgICAgZ3JvdXBWYWx1ZXMgPSB0dWkudXRpbC5tYXAoZ3JvdXBWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVzU3VtID0gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIG1pbnVzU3VtID0gY2FsY3VsYXRvci5zdW1NaW51c1ZhbHVlcyh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGx1c1N1bSwgbWludXNTdW1dO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgZ3JvdXBWYWx1ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYmFzZSBzaXplIGZvciBnZXQgY2FuZGlkYXRlIHRpY2sgY291bnRzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGNoYXQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHJldHVybnMge251bWJlcn0gYmFzZSBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QmFzZVNpemU6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgaXNWZXJ0aWNhbCkge1xuICAgICAgICB2YXIgYmFzZVNpemU7XG5cbiAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgICAgIGJhc2VTaXplID0gZGltZW5zaW9uLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VTaXplID0gZGltZW5zaW9uLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2VTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FuZGlkYXRlIHRpY2sgY291bnRzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhdCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IHRpY2sgY291bnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FuZGlkYXRlVGlja0NvdW50czogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGlzVmVydGljYWwpIHtcbiAgICAgICAgdmFyIGJhc2VTaXplID0gdGhpcy5fZ2V0QmFzZVNpemUoY2hhcnREaW1lbnNpb24sIGlzVmVydGljYWwpLFxuICAgICAgICAgICAgc3RhcnQgPSB0dWkudXRpbC5tYXgoWzMsIHBhcnNlSW50KGJhc2VTaXplIC8gY2hhcnRDb25zdC5NQVhfUElYRUxfVFlQRV9TVEVQX1NJWkUsIDEwKV0pLFxuICAgICAgICAgICAgZW5kID0gdHVpLnV0aWwubWF4KFtzdGFydCwgcGFyc2VJbnQoYmFzZVNpemUgLyBjaGFydENvbnN0Lk1JTl9QSVhFTF9UWVBFX1NURVBfU0laRSwgMTApXSkgKyAxLFxuICAgICAgICAgICAgdGlja0NvdW50cyA9IHR1aS51dGlsLnJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGlja0NvdW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXBhcmluZyB2YWx1ZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgc3RlcDogbnVtYmVyfX0gdGlja0luZm8gdGljayBpbmZvXG4gICAgICogQHJldHVybnMge251bWJlcn0gY29tcGFyaW5nIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29tcGFyaW5nVmFsdWU6IGZ1bmN0aW9uKG1pbiwgbWF4LCB0aWNrSW5mbykge1xuICAgICAgICB2YXIgZGlmZk1heCA9IGFicyh0aWNrSW5mby5saW1pdC5tYXggLSBtYXgpLFxuICAgICAgICAgICAgZGlmZk1pbiA9IGFicyhtaW4gLSB0aWNrSW5mby5saW1pdC5taW4pLFxuICAgICAgICAgICAgd2VpZ2h0ID0gTWF0aC5wb3coMTAsIHR1aS51dGlsLmxlbmd0aEFmdGVyUG9pbnQodGlja0luZm8uc3RlcCkpO1xuICAgICAgICByZXR1cm4gKGRpZmZNYXggKyBkaWZmTWluKSAqIHdlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRpY2sgaW5mby5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGNhbmRpZGF0ZXMgdGljayBpbmZvIGNhbmRpZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgdGlja0NvdW50OiBudW1iZXIsIHN0ZXA6IG51bWJlciwgbGFiZWxzOiBBcnJheS48bnVtYmVyPn19IHNlbGVjdGVkIHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdFRpY2tJbmZvOiBmdW5jdGlvbihtaW4sIG1heCwgY2FuZGlkYXRlcykge1xuICAgICAgICB2YXIgZ2V0Q29tcGFyaW5nVmFsdWUgPSB0dWkudXRpbC5iaW5kKHRoaXMuX2dldENvbXBhcmluZ1ZhbHVlLCB0aGlzLCBtaW4sIG1heCksXG4gICAgICAgICAgICB0aWNrSW5mbyA9IHR1aS51dGlsLm1pbihjYW5kaWRhdGVzLCBnZXRDb21wYXJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsaW1pdCBmb3IgZGl2ZXJnaW5nIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bWF4fSBtYXggbWF4IHZhbHVlXG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMaW1pdEZvckRpdmVyZ2luZ09wdGlvbjogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgdmFyIG5ld01heCA9IE1hdGgubWF4KE1hdGguYWJzKG1pbiksIE1hdGguYWJzKG1heCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IC1uZXdNYXgsXG4gICAgICAgICAgICBtYXg6IG5ld01heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGljayBjb3VudCBhbmQgbGltaXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbHVlcyBiYXNlIHZhbHVlc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuc2VyaWVzRGltZW5zaW9uIGNoYXQgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGF0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4Om51bWJlcn19IG9wdGlvbnMgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3t0aWNrQ291bnQ6IG51bWJlciwgbGltaXQ6IG9iamVjdH19IHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRpY2tJbmZvOiBmdW5jdGlvbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1pbiA9IHR1aS51dGlsLm1pbihwYXJhbXMudmFsdWVzKSxcbiAgICAgICAgICAgIG1heCA9IHR1aS51dGlsLm1heChwYXJhbXMudmFsdWVzKSxcbiAgICAgICAgICAgIGNoYW5nZWRMaW1pdCwgaW50VHlwZUluZm8sIHRpY2tDb3VudHMsIGNhbmRpZGF0ZXMsIHRpY2tJbmZvO1xuXG4gICAgICAgIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAwKSB7XG4gICAgICAgICAgICBtYXggPSA1O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5kaXZlcmdpbmdPcHRpb24pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLm1pbjtcbiAgICAgICAgICAgIGNoYW5nZWRMaW1pdCA9IHRoaXMuX21ha2VMaW1pdEZvckRpdmVyZ2luZ09wdGlvbihtaW4sIG1heCk7XG4gICAgICAgICAgICBtaW4gPSBjaGFuZ2VkTGltaXQubWluO1xuICAgICAgICAgICAgbWF4ID0gY2hhbmdlZExpbWl0Lm1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDAxLiBtaW4sIG1heCwgb3B0aW9ucyDsoJXrs7Trpbwg7KCV7IiY7ZiV7Jy866GcIOuzgOqyvVxuICAgICAgICBpbnRUeXBlSW5mbyA9IHRoaXMuX21ha2VJbnRlZ2VyVHlwZUluZm8obWluLCBtYXgsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIDAyLiB0aWNrIGNvdW50IO2bhOuztOq1sCDslrvquLBcbiAgICAgICAgdGlja0NvdW50cyA9IHBhcmFtcy50aWNrQ291bnQgPyBbcGFyYW1zLnRpY2tDb3VudF0gOiB0aGlzLl9nZXRDYW5kaWRhdGVUaWNrQ291bnRzKHBhcmFtcy5zZXJpZXNEaW1lbnNpb24sIHBhcmFtcy5pc1ZlcnRpY2FsKTtcblxuICAgICAgICAvLyAwMy4gdGljayBpbmZvIO2bhOuztOq1sCDqs4TsgrBcbiAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX2dldENhbmRpZGF0ZVRpY2tJbmZvcyh7XG4gICAgICAgICAgICBtaW46IGludFR5cGVJbmZvLm1pbixcbiAgICAgICAgICAgIG1heDogaW50VHlwZUluZm8ubWF4LFxuICAgICAgICAgICAgdGlja0NvdW50czogdGlja0NvdW50cyxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9LCBpbnRUeXBlSW5mby5vcHRpb25zKTtcblxuICAgICAgICAvLyAwNC4gdGljayBpbmZvIO2bhOuztOq1sCDspJEg7ZWY64KYIOyEoO2DnVxuICAgICAgICB0aWNrSW5mbyA9IHRoaXMuX3NlbGVjdFRpY2tJbmZvKGludFR5cGVJbmZvLm1pbiwgaW50VHlwZUluZm8ubWF4LCBjYW5kaWRhdGVzKTtcblxuICAgICAgICAvLyAwNS4g7KCV7IiY7ZiV7Jy866GcIOuzgOqyve2WiOuNmCB0aWNrIGluZm/rpbwg7JuQ656YIO2Yle2DnOuhnCDrs4Dqsr1cbiAgICAgICAgdGlja0luZm8gPSB0aGlzLl9yZXZlcnRPcmlnaW5hbFR5cGVUaWNrSW5mbyh0aWNrSW5mbywgaW50VHlwZUluZm8uZGl2aWRlTnVtKTtcblxuICAgICAgICBpZiAocGFyYW1zLmRpdmVyZ2luZ09wdGlvbikge1xuICAgICAgICAgICAgdGlja0luZm8ubGFiZWxzID0gdHVpLnV0aWwubWFwKHRpY2tJbmZvLmxhYmVscywgTWF0aC5hYnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBpbnRlZ2VyIHR5cGUgaW5mb1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gb3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgb3B0aW9uczoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIGRpdmlkZU51bTogbnVtYmVyfX0gaW50ZWdlciB0eXBlIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSW50ZWdlclR5cGVJbmZvOiBmdW5jdGlvbihtaW4sIG1heCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXVsdGlwbGVOdW0sIGNoYW5nZWRPcHRpb25zO1xuXG4gICAgICAgIGlmIChhYnMobWluKSA+PSAxIHx8IGFicyhtYXgpID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkaXZpZGVOdW06IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtdWx0aXBsZU51bSA9IHR1aS51dGlsLmZpbmRNdWx0aXBsZU51bShtaW4sIG1heCk7XG4gICAgICAgIGNoYW5nZWRPcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1pbikpIHtcbiAgICAgICAgICAgIGNoYW5nZWRPcHRpb25zLm1pbiA9IG9wdGlvbnMubWluICogbXVsdGlwbGVOdW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSkge1xuICAgICAgICAgICAgY2hhbmdlZE9wdGlvbnMubWF4ID0gb3B0aW9ucy5tYXggKiBtdWx0aXBsZU51bTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IG1pbiAqIG11bHRpcGxlTnVtLFxuICAgICAgICAgICAgbWF4OiBtYXggKiBtdWx0aXBsZU51bSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGNoYW5nZWRPcHRpb25zLFxuICAgICAgICAgICAgZGl2aWRlTnVtOiBtdWx0aXBsZU51bVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGljayBpbmZvIHRvIG9yaWdpbmFsIHR5cGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7c3RlcDogbnVtYmVyLCBsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIGxhYmVsczogQXJyYXkuPG51bWJlcj59fSB0aWNrSW5mbyB0aWNrIGluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlTnVtIGRpdmlkZSBudW1cbiAgICAgKiBAcmV0dXJucyB7e3N0ZXA6IG51bWJlciwgbGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LCBsYWJlbHM6IEFycmF5LjxudW1iZXI+fX0gZGl2aWRlZCB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXZlcnRPcmlnaW5hbFR5cGVUaWNrSW5mbzogZnVuY3Rpb24odGlja0luZm8sIGRpdmlkZU51bSkge1xuICAgICAgICBpZiAoZGl2aWRlTnVtID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGlja0luZm87XG4gICAgICAgIH1cblxuICAgICAgICB0aWNrSW5mby5zdGVwID0gdHVpLnV0aWwuZGl2aXNpb24odGlja0luZm8uc3RlcCwgZGl2aWRlTnVtKTtcbiAgICAgICAgdGlja0luZm8ubGltaXQubWluID0gdHVpLnV0aWwuZGl2aXNpb24odGlja0luZm8ubGltaXQubWluLCBkaXZpZGVOdW0pO1xuICAgICAgICB0aWNrSW5mby5saW1pdC5tYXggPSB0dWkudXRpbC5kaXZpc2lvbih0aWNrSW5mby5saW1pdC5tYXgsIGRpdmlkZU51bSk7XG4gICAgICAgIHRpY2tJbmZvLmxhYmVscyA9IHR1aS51dGlsLm1hcCh0aWNrSW5mby5sYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwuZGl2aXNpb24obGFiZWwsIGRpdmlkZU51bSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHN0ZXAuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgb3JpZ2luYWwgc3RlcFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5vcm1hbGl6ZWQgc3RlcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVN0ZXA6IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0b3Iubm9ybWFsaXplQXhpc051bWJlcihzdGVwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWluaW1pemUgdGljayBsaW1pdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudXNlck1pbiB1c2VyIG1pblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy51c2VyTWF4IHVzZXIgbWF4XG4gICAgICogICAgICBAcGFyYW0ge3t0aWNrQ291bnQ6IG51bWJlciwgbGltaXQ6IG9iamVjdH19IHBhcmFtcy50aWNrSW5mbyB0aWNrIGluZm9cbiAgICAgKiAgICAgIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6bnVtYmVyfX0gcGFyYW1zLm9wdGlvbnMgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3t0aWNrQ291bnQ6IG51bWJlciwgbGltaXQ6IG9iamVjdCwgbGFiZWxzOiBBcnJheX19IGNvcnJlY3RlZCB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9taW5pbWl6ZVRpY2tMaW1pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0aWNrSW5mbyA9IHBhcmFtcy50aWNrSW5mbyxcbiAgICAgICAgICAgIHRpY2tzID0gdHVpLnV0aWwucmFuZ2UoMSwgdGlja0luZm8udGlja0NvdW50KSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyxcbiAgICAgICAgICAgIHN0ZXAgPSB0aWNrSW5mby5zdGVwLFxuICAgICAgICAgICAgbGltaXQgPSB0aWNrSW5mby5saW1pdCxcbiAgICAgICAgICAgIHRpY2tNYXggPSBsaW1pdC5tYXgsXG4gICAgICAgICAgICB0aWNrTWluID0gbGltaXQubWluLFxuICAgICAgICAgICAgaXNVbmRlZmluZWRNaW4gPSB0dWkudXRpbC5pc1VuZGVmaW5lZChvcHRpb25zLm1pbiksXG4gICAgICAgICAgICBpc1VuZGVmaW5lZE1heCA9IHR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWF4KSxcbiAgICAgICAgICAgIGxhYmVscztcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGlja3MsIGZ1bmN0aW9uKHRpY2tJbmRleCkge1xuICAgICAgICAgICAgdmFyIGN1clN0ZXAgPSAoc3RlcCAqIHRpY2tJbmRleCksXG4gICAgICAgICAgICAgICAgY3VyTWluID0gdGlja01pbiArIGN1clN0ZXAsXG4gICAgICAgICAgICAgICAgY3VyTWF4ID0gdGlja01heCAtIGN1clN0ZXA7XG5cbiAgICAgICAgICAgIC8vIOuNlOydtOyDgSDrs4Dqsr3snbQg7ZWE7JqUIOyXhuydhCDqsr3smrBcbiAgICAgICAgICAgIGlmIChwYXJhbXMudXNlck1pbiA8PSBjdXJNaW4gJiYgcGFyYW1zLnVzZXJNYXggPj0gY3VyTWF4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtaW4g6rCS7JeQIOuzgOqyvSDsl6zsnKDqsIAg7J6I7J2EIOqyveyasFxuICAgICAgICAgICAgaWYgKChpc1VuZGVmaW5lZE1pbiAmJiBwYXJhbXMudXNlck1pbiA+IGN1ck1pbikgfHxcbiAgICAgICAgICAgICAgICAoIWlzVW5kZWZpbmVkTWluICYmIG9wdGlvbnMubWluID49IGN1ck1pbikpIHtcbiAgICAgICAgICAgICAgICBsaW1pdC5taW4gPSBjdXJNaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1heCDqsJLsl5Ag67OA6rK9IOyXrOycoOqwgCDsnojsnYQg6rK97JqwXG4gICAgICAgICAgICBpZiAoKGlzVW5kZWZpbmVkTWluICYmIHBhcmFtcy51c2VyTWF4IDwgY3VyTWF4KSB8fFxuICAgICAgICAgICAgICAgICghaXNVbmRlZmluZWRNYXggJiYgb3B0aW9ucy5tYXggPD0gY3VyTWF4KSkge1xuICAgICAgICAgICAgICAgIGxpbWl0Lm1heCA9IGN1ck1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGFiZWxzID0gY2FsY3VsYXRvci5tYWtlTGFiZWxzRnJvbUxpbWl0KGxpbWl0LCBzdGVwKTtcbiAgICAgICAgdGlja0luZm8ubGFiZWxzID0gbGFiZWxzO1xuICAgICAgICB0aWNrSW5mby5zdGVwID0gc3RlcDtcbiAgICAgICAgdGlja0luZm8udGlja0NvdW50ID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdGljayBzdGVwLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7e2xpbWl0OiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSwgdGlja0NvdW50OiBudW1iZXIsIHN0ZXA6IG51bWJlciwgbGFiZWxzOiBBcnJheS48bnVtYmVyPn19IHRpY2tJbmZvIHRpY2sgaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcmdUaWNrQ291bnQgb3JpZ2luYWwgdGlja0NvdW50XG4gICAgICogQHJldHVybnMge3tsaW1pdDoge21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn0sIHRpY2tDb3VudDogbnVtYmVyLCBzdGVwOiBudW1iZXIsIGxhYmVsczogQXJyYXkuPG51bWJlcj59fSB0aWNrIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXZpZGVUaWNrU3RlcDogZnVuY3Rpb24odGlja0luZm8sIG9yZ1RpY2tDb3VudCkge1xuICAgICAgICB2YXIgc3RlcCA9IHRpY2tJbmZvLnN0ZXAsXG4gICAgICAgICAgICBsaW1pdCA9IHRpY2tJbmZvLmxpbWl0LFxuICAgICAgICAgICAgdGlja0NvdW50ID0gdGlja0luZm8udGlja0NvdW50O1xuICAgICAgICAvLyBzdGVwIDLsnZgg67Cw7IiYIOydtOuptOyEnCDrs4Dqsr3rkJwgdGlja0NvdW507J2YIOuRkOuwsOyImC0x7J20IHRpY2tDb3VudOuztOuLpCBvcmdUaWNrQ291bnTsmYAg7LCo7J206rCAIOuNnOuCmOqxsOuCmCDqsJnsnLzrqbQgc3RlcOydhCDrsJjsnLzroZwg67OA6rK97ZWc64ukLlxuICAgICAgICBpZiAoKHN0ZXAgJSAyID09PSAwKSAmJlxuICAgICAgICAgICAgYWJzKG9yZ1RpY2tDb3VudCAtICgodGlja0NvdW50ICogMikgLSAxKSkgPD0gYWJzKG9yZ1RpY2tDb3VudCAtIHRpY2tDb3VudCkpIHtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIC8gMjtcbiAgICAgICAgICAgIHRpY2tJbmZvLmxhYmVscyA9IGNhbGN1bGF0b3IubWFrZUxhYmVsc0Zyb21MaW1pdChsaW1pdCwgc3RlcCk7XG4gICAgICAgICAgICB0aWNrSW5mby50aWNrQ291bnQgPSB0aWNrSW5mby5sYWJlbHMubGVuZ3RoO1xuICAgICAgICAgICAgdGlja0luZm8uc3RlcCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgaW5mb1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy50aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5taW4gbGltaXQgbWluXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heCBsaW1pdCBtYXhcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudXNlck1pbiBtaW5pbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy51c2VyTWF4IG1heGltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5pc01pbnVzIHdoZXRoZXIgbGltaXQgaXMgbWludXMgb3Igbm90XG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBwYXJhbXMub3B0aW9ucyBheGlzIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgbGltaXQ6IHttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9LFxuICAgICAqICAgICAgdGlja0NvdW50OiBudW1iZXIsXG4gICAgICogICAgICBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBsYWJlbHM6IEFycmF5LjxudW1iZXI+XG4gICAgICogfX0gdGljayBpbmZvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRpY2tJbmZvOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxpbWl0ID0gcGFyYW1zLmxpbWl0LFxuICAgICAgICAgICAgc3RlcCwgdGlja0luZm87XG5cbiAgICAgICAgLy8gMDEuIOq4sOuzuCBsaW1pdCDsoJXrs7TroZwgc3RlcCDslrvquLBcbiAgICAgICAgc3RlcCA9IGNhbGN1bGF0b3IuY2FsY3VsYXRlU3RlcEZyb21MaW1pdChsaW1pdCwgcGFyYW1zLnRpY2tDb3VudCk7XG5cbiAgICAgICAgLy8gMDIuIHN0ZXAg7KCV6rec7ZmUIOyLnO2CpOq4sCAoZXg6IDAuMyAtLT4gMC41LCA3IC0tPiAxMClcbiAgICAgICAgc3RlcCA9IHRoaXMuX25vcm1hbGl6ZVN0ZXAoc3RlcCk7XG5cbiAgICAgICAgLy8gMDMuIGxpbWl0IOygleq3nO2ZlCDsi5ztgqTquLBcbiAgICAgICAgbGltaXQgPSB0aGlzLm5vcm1hbGl6ZUxpbWl0KGxpbWl0LCBzdGVwLCBwYXJhbXMudGlja0NvdW50KTtcblxuICAgICAgICAvLyAwNC4gbGluZeywqO2KuOydmCDqsr3smrAg7IKs7Jqp7J6Q7J2YIG1pbuqwkuydtCBsaW1pdOydmCBtaW7qsJLqs7wg6rCZ7J2EIOqyveyasCwgbWlu6rCS7J2EIDEgc3RlcCDqsJDshowg7Iuc7YK0XG4gICAgICAgIGxpbWl0Lm1pbiA9IHRoaXMuX2FkZE1pblBhZGRpbmcoe1xuICAgICAgICAgICAgbWluOiBsaW1pdC5taW4sXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgdXNlck1pbjogcGFyYW1zLnVzZXJNaW4sXG4gICAgICAgICAgICBtaW5PcHRpb246IHBhcmFtcy5vcHRpb25zLm1pbixcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAwNC4g7IKs7Jqp7J6Q7J2YIG1heOqwkuydtCBzY2FlbCBtYXjsmYAg6rCZ7J2EIOqyveyasCwgbWF46rCS7J2EIDEgc3RlcCDspp3qsIAg7Iuc7YK0XG4gICAgICAgIGxpbWl0Lm1heCA9IHRoaXMuX2FkZE1heFBhZGRpbmcoe1xuICAgICAgICAgICAgbWF4OiBsaW1pdC5tYXgsXG4gICAgICAgICAgICBzdGVwOiBzdGVwLFxuICAgICAgICAgICAgdXNlck1heDogcGFyYW1zLnVzZXJNYXgsXG4gICAgICAgICAgICBtYXhPcHRpb246IHBhcmFtcy5vcHRpb25zLm1heCxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyAwNS4gYXhpcyBsaW1pdOydtCDsgqzsmqnsnpAgbWluLCBtYXjsmYAg6rGw66as6rCAIOupgCDqsr3smrAg7KGw7KCIXG4gICAgICAgIHRpY2tJbmZvID0gdGhpcy5fbWluaW1pemVUaWNrTGltaXQoe1xuICAgICAgICAgICAgdXNlck1pbjogcGFyYW1zLnVzZXJNaW4sXG4gICAgICAgICAgICB1c2VyTWF4OiBwYXJhbXMudXNlck1heCxcbiAgICAgICAgICAgIHRpY2tJbmZvOiB7bGltaXQ6IGxpbWl0LCBzdGVwOiBzdGVwLCB0aWNrQ291bnQ6IHBhcmFtcy50aWNrQ291bnR9LFxuICAgICAgICAgICAgb3B0aW9uczogcGFyYW1zLm9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGlja0luZm8gPSB0aGlzLl9kaXZpZGVUaWNrU3RlcCh0aWNrSW5mbywgcGFyYW1zLnRpY2tDb3VudCk7XG4gICAgICAgIHJldHVybiB0aWNrSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGxpbWl0IG1pbiBwYWRkaW5nLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHByYW1zIHtudW1iZXJ9IHBhcmFtcy5taW4gbGltaXQgbWluXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVzZXJNaW4gbWluaW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWluT3B0aW9uIG1pbiBvcHRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsaW1pdCBtaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRNaW5QYWRkaW5nOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1pbiA9IHBhcmFtcy5taW47XG5cbiAgICAgICAgaWYgKCghcHJlZGljYXRlLmlzTGluZUNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpICYmIHBhcmFtcy51c2VyTWluID49IDApIHx8ICF0dWkudXRpbC5pc1VuZGVmaW5lZChwYXJhbXMubWluT3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3JtYWxpemXrkJwgbGltaXQgbWlu6rCS7J20IHVzZXIgbWlu6rCS6rO8IOqwmeydhCDqsr3smrAgc3RlcCDqsJDshoxcbiAgICAgICAgaWYgKHBhcmFtcy5taW4gPT09IHBhcmFtcy51c2VyTWluKSB7XG4gICAgICAgICAgICBtaW4gLT0gcGFyYW1zLnN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGxpbWl0IG1heCBwYWRkaW5nLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHByYW1zIHtudW1iZXJ9IHBhcmFtcy5tYXggbGltaXQgbWF4XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnVzZXJNYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4T3B0aW9uIG1heCBvcHRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsaW1pdCBtYXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRNYXhQYWRkaW5nOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1heCA9IHBhcmFtcy5tYXg7XG5cbiAgICAgICAgaWYgKCghcHJlZGljYXRlLmlzTGluZUNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpICYmIHBhcmFtcy51c2VyTWF4IDw9IDApIHx8ICF0dWkudXRpbC5pc1VuZGVmaW5lZChwYXJhbXMubWF4T3B0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vcm1hbGl6ZeuQnCBsaW1pdCBtYXjqsJLsnbQgdXNlciBtYXjqsJLqs7wg6rCZ7J2EIOqyveyasCBzdGVwIOymneqwgFxuICAgICAgICBpZiAodHVpLnV0aWwuaXNVbmRlZmluZWQocGFyYW1zLm1heE9wdGlvbikgJiYgKHBhcmFtcy5tYXggPT09IHBhcmFtcy51c2VyTWF4KSkge1xuICAgICAgICAgICAgbWF4ICs9IHBhcmFtcy5zdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBtaW4uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBvcmlnaW5hbCBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCB0aWNrIHN0ZXBcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBub3JtYWxpemVkIG1pblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZU1pbjogZnVuY3Rpb24obWluLCBzdGVwKSB7XG4gICAgICAgIHZhciBtb2QgPSB0dWkudXRpbC5tb2QobWluLCBzdGVwKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ7XG5cbiAgICAgICAgaWYgKG1vZCA9PT0gMCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZCA9IG1pbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSB0dWkudXRpbC5zdWJ0cmFjdGlvbihtaW4sIChtaW4gPj0gMCA/IG1vZCA6IHN0ZXAgKyBtb2QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBub3JtYWxpemVkIG1heC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHRpY2sgc3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG5vcm1hbGl6ZWQgbWF4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbGl6ZWRNYXg6IGZ1bmN0aW9uKGxpbWl0LCBzdGVwLCB0aWNrQ291bnQpIHtcbiAgICAgICAgdmFyIG1pbk1heERpZmYgPSB0dWkudXRpbC5tdWx0aXBsaWNhdGlvbihzdGVwLCB0aWNrQ291bnQgLSAxKSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXggPSB0dWkudXRpbC5hZGRpdGlvbihsaW1pdC5taW4sIG1pbk1heERpZmYpLFxuICAgICAgICAgICAgbWF4RGlmZiA9IGxpbWl0Lm1heCAtIG5vcm1hbGl6ZWRNYXgsXG4gICAgICAgICAgICBtb2REaWZmLCBkaXZpZGVEaWZmO1xuICAgICAgICAvLyBub3JtYWxpemXrkJwgbWF46rCS7J20IOybkOuemOydmCBtYXjqsJIg67O064ukIOyekeydhCDqsr3smrAgc3RlcOydhCDspp3qsIDsi5zsvJwg7YGwIOqwkuycvOuhnCDrp4zrk6TquLBcbiAgICAgICAgaWYgKG1heERpZmYgPiAwKSB7XG4gICAgICAgICAgICBtb2REaWZmID0gbWF4RGlmZiAlIHN0ZXA7XG4gICAgICAgICAgICBkaXZpZGVEaWZmID0gTWF0aC5mbG9vcihtYXhEaWZmIC8gc3RlcCk7XG4gICAgICAgICAgICBub3JtYWxpemVkTWF4ICs9IHN0ZXAgKiAobW9kRGlmZiA+IDAgPyBkaXZpZGVEaWZmICsgMSA6IGRpdmlkZURpZmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkTWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemUgbGltaXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpheGlzRGF0YU1ha2VyXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYmFzZSBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHRpY2sgc3RlcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgdGljayBjb3VudFxuICAgICAqIEByZXR1cm5zIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbm9ybWFsaXplZCBsaW1pdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplTGltaXQ6IGZ1bmN0aW9uKGxpbWl0LCBzdGVwLCB0aWNrQ291bnQpIHtcbiAgICAgICAgbGltaXQubWluID0gdGhpcy5fbm9ybWFsaXplTWluKGxpbWl0Lm1pbiwgc3RlcCk7XG4gICAgICAgIGxpbWl0Lm1heCA9IHRoaXMuX21ha2VOb3JtYWxpemVkTWF4KGxpbWl0LCBzdGVwLCB0aWNrQ291bnQpO1xuICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBjYW5kaWRhdGVzIGFib3V0IHRpY2sgaW5mby5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGFyYW1zLnRpY2tDb3VudHMgdGljayBjb3VudHNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4Om51bWJlcn19IG9wdGlvbnMgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5fSBjYW5kaWRhdGVzIGFib3V0IHRpY2sgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENhbmRpZGF0ZVRpY2tJbmZvczogZnVuY3Rpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1c2VyTWluID0gcGFyYW1zLm1pbixcbiAgICAgICAgICAgIHVzZXJNYXggPSBwYXJhbXMubWF4LFxuICAgICAgICAgICAgbWluID0gcGFyYW1zLm1pbixcbiAgICAgICAgICAgIG1heCA9IHBhcmFtcy5tYXgsXG4gICAgICAgICAgICBsaW1pdCwgY2FuZGlkYXRlcztcblxuICAgICAgICAvLyBtaW4sIG1heOunjOycvOuhnCDquLDrs7ggbGltaXQg7Ja76riwXG4gICAgICAgIGxpbWl0ID0gdGhpcy5fbWFrZUJhc2VMaW1pdChtaW4sIG1heCwgb3B0aW9ucyk7XG5cbiAgICAgICAgY2FuZGlkYXRlcyA9IHR1aS51dGlsLm1hcChwYXJhbXMudGlja0NvdW50cywgZnVuY3Rpb24odGlja0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVRpY2tJbmZvKHtcbiAgICAgICAgICAgICAgICB0aWNrQ291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICAgICAgICBsaW1pdDogdHVpLnV0aWwuZXh0ZW5kKHt9LCBsaW1pdCksXG4gICAgICAgICAgICAgICAgdXNlck1pbjogdXNlck1pbixcbiAgICAgICAgICAgICAgICB1c2VyTWF4OiB1c2VyTWF4LFxuICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgbGltaXRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmF4aXNEYXRhTWFrZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIG9mIHVzZXIgZGF0YVxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IG9wdGlvbnMgYXhpcyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBiYXNlIGxpbWl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2VMaW1pdDogZnVuY3Rpb24obWluLCBtYXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlzTWludXMgPSBmYWxzZSxcbiAgICAgICAgICAgIHRtcE1pbiwgbGltaXQ7XG5cbiAgICAgICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICAgICAgICBpZiAobWluID4gMCkge1xuICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1heCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluIDwgMCAmJiBtYXggPD0gMCkge1xuICAgICAgICAgICAgaXNNaW51cyA9IHRydWU7XG4gICAgICAgICAgICB0bXBNaW4gPSBtaW47XG4gICAgICAgICAgICBtaW4gPSAtbWF4O1xuICAgICAgICAgICAgbWF4ID0gLXRtcE1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbWl0ID0gY2FsY3VsYXRvci5jYWxjdWxhdGVMaW1pdChtaW4sIG1heCk7XG5cbiAgICAgICAgaWYgKGlzTWludXMpIHtcbiAgICAgICAgICAgIHRtcE1pbiA9IGxpbWl0Lm1pbjtcbiAgICAgICAgICAgIGxpbWl0Lm1pbiA9IC1saW1pdC5tYXg7XG4gICAgICAgICAgICBsaW1pdC5tYXggPSAtdG1wTWluO1xuICAgICAgICB9XG5cbiAgICAgICAgbGltaXQubWluID0gIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wdGlvbnMubWluKSA/IG9wdGlvbnMubWluIDogbGltaXQubWluO1xuICAgICAgICBsaW1pdC5tYXggPSAhdHVpLnV0aWwuaXNVbmRlZmluZWQob3B0aW9ucy5tYXgpID8gb3B0aW9ucy5tYXggOiBsaW1pdC5tYXg7XG5cbiAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgbGFiZWxzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6YXhpc0RhdGFNYWtlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxhYmVscyB0YXJnZXQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbltdfSBmb3JtYXRGdW5jdGlvbnMgZm9ybWF0IGZ1bmN0aW9uc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gZm9ybWF0dGVkIGxhYmVsc1xuICAgICAqL1xuICAgIGZvcm1hdExhYmVsczogZnVuY3Rpb24obGFiZWxzLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKCFmb3JtYXRGdW5jdGlvbnMgfHwgIWZvcm1hdEZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwubWFwKGxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKGxhYmVsLCBmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aXNEYXRhTWFrZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm91bmRzIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY2FsY3VsYXRvcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4vcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIERpbWVuc2lvbi5cbiAqIEB0eXBlZGVmIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvblxuICovXG5cbi8qKlxuICogUG9zaXRpb24uXG4gKiBAdHlwZWRlZiB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19IHBvc2l0aW9uXG4gKi9cblxuLyoqXG4gKiBCb3VuZC5cbiAqIEB0eXBlZGVmIHt7ZGltZW5zaW9uOiBkaW1lbnNpb24sIHBvc2l0aW9uOnBvc2l0aW9ufX0gYm91bmRcbiAqL1xuXG52YXIgQm91bmRzTWFrZXIgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEJvdW5kc01ha2VyLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBCb3VuZHMgbWFrZXIuXG4gICAgICogQGNvbnN0cnVjdHMgQm91bmRzTWFrZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG9wdGlvbnNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZWdlbmQgPSB0aGlzLm9wdGlvbnMubGVnZW5kIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGVtZVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZSB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgYXhlcyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0F4ZXMgPSBwYXJhbXMuaGFzQXhlcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCBsZWZ0IHBhZGRpbmdcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRMZWZ0UGFkZGluZyA9IGNoYXJ0Q29uc3QuQ0hBUlRfUEFERElORztcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwcm9jZXNzb3JcbiAgICAgICAgICogQHR5cGUge0RhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSBwYXJhbXMuZGF0YVByb2Nlc3NvcjtcblxuICAgICAgICB0aGlzLmluaXRCb3VuZHNEYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYm91bmRzIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0T3B0aW9uIGNoYXJ0IG9wdGlvblxuICAgICAqL1xuICAgIGluaXRCb3VuZHNEYXRhOiBmdW5jdGlvbihjaGFydE9wdGlvbikge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHlBeGlzOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodFlBeGlzOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4QXhpczoge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy5heGVzRGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMueEF4aXNEZWdyZWUgPSAwO1xuXG4gICAgICAgIGlmIChjaGFydE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNoYXJ0ID0gY2hhcnRPcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWdpc3RlckNoYXJ0RGltZW5zaW9uKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyVGl0bGVEaW1lbnNpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtkaW1lbnNpb259IGRpbWVuc2lvbiBjb21wb25lbnQgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJEaW1lbnNpb246IGZ1bmN0aW9uKG5hbWUsIGRpbWVuc2lvbikge1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNbbmFtZV0gPSB0dWkudXRpbC5leHRlbmQodGhpcy5kaW1lbnNpb25zW25hbWVdIHx8IHt9LCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBiYXNlIGRpbWVuc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb21wb25lbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZGltZW5zaW9ufSBkaW1lbnNpb24gY29tcG9uZW50IGRpbWVuc2lvblxuICAgICAqL1xuICAgIHJlZ2lzdGVyQmFzZURpbWVuc2lvbjogZnVuY3Rpb24obmFtZSwgZGltZW5zaW9uKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKG5hbWUsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGF4ZXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXhlc0RhdGEgYXhlcyBkYXRhXG4gICAgICovXG4gICAgcmVnaXN0ZXJBeGVzRGF0YTogZnVuY3Rpb24oYXhlc0RhdGEpIHtcbiAgICAgICAgdGhpcy5heGVzRGF0YSA9IGF4ZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYm91bmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym91bmR9IGNvbXBvbmVudCBib3VuZFxuICAgICAqL1xuICAgIGdldEJvdW5kOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHRoaXMuZGltZW5zaW9uc1tuYW1lXSB8fCB7fSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uc1tuYW1lXSB8fCB7fVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbXBvbmVudCBuYW1lXG4gICAgICogQHJldHVybnMge2RpbWVuc2lvbn0gY29tcG9uZW50IGRpbWVuc2lvblxuICAgICAqL1xuICAgIGdldERpbWVuc2lvbjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zW25hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29tcG9uZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7cG9zaXRpb259IGNvbXBvbmVudCBwb3NpdGlvblxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJDaGFydERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY2hhcnQgfHwge30sXG4gICAgICAgICAgICBkaW1lbnNpb24gPSB7XG4gICAgICAgICAgICB3aWR0aDogY2hhcnRPcHRpb25zLndpZHRoIHx8IGNoYXJ0Q29uc3QuQ0hBUlRfREVGQVVMVF9XSURUSCxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRPcHRpb25zLmhlaWdodCB8fCBjaGFydENvbnN0LkNIQVJUX0RFRkFVTFRfSEVJR0hUXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ2NoYXJ0JywgZGltZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdGl0bGUgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJUaXRsZURpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY2hhcnQgfHwge30sXG4gICAgICAgICAgICBkaW1lbnNpb24gPSB7XG4gICAgICAgICAgICBoZWlnaHQ6IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChjaGFydE9wdGlvbnMudGl0bGUsIHRoaXMudGhlbWUudGl0bGUpICsgY2hhcnRDb25zdC5USVRMRV9QQURESU5HXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3RpdGxlJywgZGltZW5zaW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGxpbWl0IHdpZHRoIG9mIHggYXhpcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsaW1pdCB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVhBeGlzTGFiZWxMaW1pdFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc1dpZHRoID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpLndpZHRoLFxuICAgICAgICAgICAgbGFiZWxDb3VudCA9IHRoaXMuYXhlc0RhdGEueEF4aXMubGFiZWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGlzQWxpZ24gPSBwcmVkaWNhdGUuaXNMaW5lVHlwZUNoYXJ0KHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgcmV0dXJuIHNlcmllc1dpZHRoIC8gKGlzQWxpZ24gPyBsYWJlbENvdW50IC0gMSA6IGxhYmVsQ291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHJvdGF0aW9uIGRlZ3JlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRXaWR0aCBsaW1pdCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBjYW5kaWRhdGVzIGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn0gcm90YXRpb24gZGVncmVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZFJvdGF0aW9uRGVncmVlOiBmdW5jdGlvbihsaW1pdFdpZHRoLCBsYWJlbFdpZHRoLCBsYWJlbEhlaWdodCkge1xuICAgICAgICB2YXIgZm91bmREZWdyZWUsXG4gICAgICAgICAgICBoYWxmV2lkdGggPSBsYWJlbFdpZHRoIC8gMixcbiAgICAgICAgICAgIGhhbGZIZWlnaHQgPSBsYWJlbEhlaWdodCAvIDI7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGNoYXJ0Q29uc3QuREVHUkVFX0NBTkRJREFURVMsIGZ1bmN0aW9uKGRlZ3JlZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVXaWR0aCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZUFkamFjZW50KGRlZ3JlZSwgaGFsZldpZHRoKSArIGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoY2hhcnRDb25zdC5BTkdMRV85MCAtIGRlZ3JlZSwgaGFsZkhlaWdodCkpICogMjtcbiAgICAgICAgICAgIGZvdW5kRGVncmVlID0gZGVncmVlO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVXaWR0aCA8PSBsaW1pdFdpZHRoICsgY2hhcnRDb25zdC5YQVhJU19MQUJFTF9DT01QQVJFX01BUkdJTikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kRGVncmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJvdGF0aW9uIGluZm8gYWJvdXQgaG9yaXpvbnRhbCBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRXaWR0aCBsaW1pdCB3aWR0aFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBheGlzIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0aGVtZSBheGlzIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMgez9vYmplY3R9IHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbExhYmVsUm90YXRpb25JbmZvOiBmdW5jdGlvbihsaW1pdFdpZHRoKSB7XG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmF4ZXNEYXRhLnhBeGlzLmxhYmVscyxcbiAgICAgICAgICAgIHRoZW1lID0gdGhpcy50aGVtZS54QXhpcy5sYWJlbCxcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4V2lkdGgobGFiZWxzLCB0aGVtZSksXG4gICAgICAgICAgICBkZWdyZWUsIGxhYmVsSGVpZ2h0O1xuXG4gICAgICAgIGlmIChtYXhMYWJlbFdpZHRoIDw9IGxpbWl0V2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0KGxhYmVscywgdGhlbWUpO1xuICAgICAgICBkZWdyZWUgPSB0aGlzLl9maW5kUm90YXRpb25EZWdyZWUobGltaXRXaWR0aCwgbWF4TGFiZWxXaWR0aCwgbGFiZWxIZWlnaHQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXhMYWJlbFdpZHRoOiBtYXhMYWJlbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgZGVncmVlOiBkZWdyZWVcbiAgICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb3ZlcmZsb3cgcG9zaXRpb24gbGVmdC5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbGFiZWxIZWlnaHQ6IG51bWJlcn19IHJvdGF0aW9uSW5mbyByb3RhdGlvbiBpbmZvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpcnN0TGFiZWwgZmlyc3RMYWJlbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG92ZXJmbG93IHBvc2l0aW9uIGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVPdmVyZmxvd0xlZnQ6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbywgZmlyc3RMYWJlbCkge1xuICAgICAgICB2YXIgZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcm90YXRpb25JbmZvLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgZmlyc3RMYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgoZmlyc3RMYWJlbCwgdGhpcy50aGVtZS54QXhpcy5sYWJlbCksXG4gICAgICAgICAgICBuZXdMYWJlbFdpZHRoID0gKGNhbGN1bGF0b3IuY2FsY3VsYXRlQWRqYWNlbnQoZGVncmVlLCBmaXJzdExhYmVsV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICsgY2FsY3VsYXRvci5jYWxjdWxhdGVBZGphY2VudChjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBsYWJlbEhlaWdodCAvIDIpKSAqIDIsXG4gICAgICAgICAgICBkaWZmTGVmdCA9IG5ld0xhYmVsV2lkdGggLSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aDtcbiAgICAgICAgcmV0dXJuIGRpZmZMZWZ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggb2YgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmZsb3dMZWZ0IG92ZXJmbG93IGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zV2lkdGg6IGZ1bmN0aW9uKG92ZXJmbG93TGVmdCkge1xuICAgICAgICBpZiAob3ZlcmZsb3dMZWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFydExlZnRQYWRkaW5nICs9IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5wbG90LndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucy5zZXJpZXMud2lkdGggLT0gb3ZlcmZsb3dMZWZ0O1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zLnhBeGlzLndpZHRoIC09IG92ZXJmbG93TGVmdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZGVncmVlIG9mIHJvdGF0aW9uSW5mby5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxMZW5ndGggbGFiZWxMZW5ndGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ZlcmZsb3dMZWZ0IG92ZXJmbG93IGxlZnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEZWdyZWU6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbywgbGFiZWxMZW5ndGgsIG92ZXJmbG93TGVmdCkge1xuICAgICAgICB2YXIgbGltaXRXaWR0aCwgbmV3RGVncmVlO1xuICAgICAgICBpZiAob3ZlcmZsb3dMZWZ0ID4gMCkge1xuICAgICAgICAgICAgbGltaXRXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKS53aWR0aCAvIGxhYmVsTGVuZ3RoICsgY2hhcnRDb25zdC5YQVhJU19MQUJFTF9HVVRURVI7XG4gICAgICAgICAgICBuZXdEZWdyZWUgPSB0aGlzLl9maW5kUm90YXRpb25EZWdyZWUobGltaXRXaWR0aCwgcm90YXRpb25JbmZvLm1heExhYmVsV2lkdGgsIHJvdGF0aW9uSW5mby5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgICByb3RhdGlvbkluZm8uZGVncmVlID0gbmV3RGVncmVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3RhdGVkIGhlaWdodCBvZiB4QXhpcy5cbiAgICAgKiBAcGFyYW0ge3tkZWdyZWU6IG51bWJlciwgbWF4TGFiZWxXaWR0aDogbnVtYmVyLCBsYWJlbEhlaWdodDogbnVtYmVyfX0gcm90YXRpb25JbmZvIHJvdGF0aW9uIGluZm9cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB4QXhpcyBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVYQXhpc1JvdGF0ZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvdGF0aW9uSW5mbykge1xuICAgICAgICB2YXIgZGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZSxcbiAgICAgICAgICAgIG1heExhYmVsV2lkdGggPSByb3RhdGlvbkluZm8ubWF4TGFiZWxXaWR0aCxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcm90YXRpb25JbmZvLmxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgYXhpc0hlaWdodCA9IChjYWxjdWxhdG9yLmNhbGN1bGF0ZU9wcG9zaXRlKGRlZ3JlZSwgbWF4TGFiZWxXaWR0aCAvIDIpICsgY2FsY3VsYXRvci5jYWxjdWxhdGVPcHBvc2l0ZShjaGFydENvbnN0LkFOR0xFXzkwIC0gZGVncmVlLCBsYWJlbEhlaWdodCAvIDIpKSAqIDI7XG4gICAgICAgIHJldHVybiBheGlzSGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IGRpZmZlcmVuY2UgYmV0d2VlbiBvcmlnaW4gY2F0ZWdvcnkgYW5kIHJvdGF0aW9uIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7e2RlZ3JlZTogbnVtYmVyLCBtYXhMYWJlbFdpZHRoOiBudW1iZXIsIGxhYmVsSGVpZ2h0OiBudW1iZXJ9fSByb3RhdGlvbkluZm8gcm90YXRpb24gaW5mb1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGhlaWdodCBkaWZmZXJlbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlRGlmZldpdGhSb3RhdGVkSGVpZ2h0OiBmdW5jdGlvbihyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgdmFyIHJvdGF0ZWRIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVYQXhpc1JvdGF0ZWRIZWlnaHQocm90YXRpb25JbmZvKTtcbiAgICAgICAgcmV0dXJuIHJvdGF0ZWRIZWlnaHQgLSByb3RhdGlvbkluZm8ubGFiZWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgZGlmZmVyZW5jZSBiZXR3ZWVuIG9yaWdpbiBjYXRlZ29yeSBhbmQgbXVsdGlsaW5lIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGltaXRXaWR0aCBsaW1pdCB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGNhbGN1bGF0ZWQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlRGlmZldpdGhNdWx0aWxpbmVIZWlnaHQ6IGZ1bmN0aW9uKGxhYmVscywgbGltaXRXaWR0aCkge1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnRoZW1lLnhBeGlzLmxhYmVsLFxuICAgICAgICAgICAgbXVsdGlsaW5lTGFiZWxzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldE11bHRpbGluZUNhdGVnb3JpZXMobGltaXRXaWR0aCwgdGhlbWUpLFxuICAgICAgICAgICAgbm9ybWFsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsc01heEhlaWdodChsYWJlbHMsIHRoZW1lKSxcbiAgICAgICAgICAgIG11bHRpbGluZUhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhIZWlnaHQobXVsdGlsaW5lTGFiZWxzLCB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIGNzc1RleHQ6ICdsaW5lLWhlaWdodDoxLjI7d2lkdGg6JyArIGxpbWl0V2lkdGggKyAncHgnXG4gICAgICAgICAgICB9LCB0aGVtZSkpO1xuXG4gICAgICAgIHJldHVybiBtdWx0aWxpbmVIZWlnaHQgLSBub3JtYWxIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBoZWlnaHQgb2YgZGltZW5zaW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlmZkhlaWdodCBkaWZmIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZURpbWVuc2lvbnNIZWlnaHQ6IGZ1bmN0aW9uKGRpZmZIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnBsb3QuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy5zZXJpZXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy55QXhpcy5oZWlnaHQgLT0gZGlmZkhlaWdodDtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zLnJpZ2h0WUF4aXMuaGVpZ2h0IC09IGRpZmZIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGltZW5zaW9ucy54QXhpcy5oZWlnaHQgKz0gZGlmZkhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGRpbWVuc2lvbnMgYW5kIGRlZ3JlZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVEaW1lbnNpb25zQW5kRGVncmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHhBeGlzT3B0aW9ucyA9IHRoaXMub3B0aW9ucy54QXhpcyB8fCB7fSxcbiAgICAgICAgICAgIGxpbWl0V2lkdGggPSB0aGlzLl9jYWxjdWxhdGVYQXhpc0xhYmVsTGltaXRXaWR0aCgpLFxuICAgICAgICAgICAgbGFiZWxzID0gdGhpcy5heGVzRGF0YS54QXhpcy5sYWJlbHMsXG4gICAgICAgICAgICByb3RhdGlvbkluZm8sIG92ZXJmbG93TGVmdCwgZGlmZkhlaWdodDtcblxuICAgICAgICBpZiAoeEF4aXNPcHRpb25zLnJvdGF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcm90YXRpb25JbmZvID0gdGhpcy5fbWFrZUhvcml6b250YWxMYWJlbFJvdGF0aW9uSW5mbyhsaW1pdFdpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbkluZm8pIHtcbiAgICAgICAgICAgIG92ZXJmbG93TGVmdCA9IHRoaXMuX2NhbGN1bGF0ZU92ZXJmbG93TGVmdChyb3RhdGlvbkluZm8sIGxhYmVsc1swXSk7XG4gICAgICAgICAgICB0aGlzLnhBeGlzRGVncmVlID0gcm90YXRpb25JbmZvLmRlZ3JlZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnNXaWR0aChvdmVyZmxvd0xlZnQpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGVncmVlKHJvdGF0aW9uSW5mbywgbGFiZWxzLmxlbmd0aCwgb3ZlcmZsb3dMZWZ0KTtcbiAgICAgICAgICAgIGRpZmZIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVEaWZmV2l0aFJvdGF0ZWRIZWlnaHQocm90YXRpb25JbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpZmZIZWlnaHQgPSB0aGlzLl9jYWxjdWxhdGVEaWZmV2l0aE11bHRpbGluZUhlaWdodChsYWJlbHMsIGxpbWl0V2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uc0hlaWdodChkaWZmSGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwbG90IGRpbWVudGlvblxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwbG90IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQbG90RGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXJpZXNEaW1lbnNpb24ud2lkdGggKyBjaGFydENvbnN0LkhJRERFTl9XSURUSCxcbiAgICAgICAgICAgIGhlaWdodDogc2VyaWVzRGltZW5zaW9uLmhlaWdodCArIGNoYXJ0Q29uc3QuSElEREVOX1dJRFRIXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGF4aXMgY29tcG9uZW50cyBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJBeGlzQ29tcG9uZW50c0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwbG90RGltZW5zaW9uID0gdGhpcy5fbWFrZVBsb3REaW1lbnNpb24oKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbigncGxvdCcsIHBsb3REaW1lbnNpb24pO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd4QXhpcycsIHtcbiAgICAgICAgICAgIHdpZHRoOiBwbG90RGltZW5zaW9uLndpZHRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGltZW5zaW9uKCd5QXhpcycsIHtcbiAgICAgICAgICAgIGhlaWdodDogcGxvdERpbWVuc2lvbi5oZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3JpZ2h0WUF4aXMnLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IHBsb3REaW1lbnNpb24uaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyB3aWR0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzZXJpZXMgd2lkdGhcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGVnZW5kV2lkdGgsIHJpZ2h0QXJlYVdpZHRoO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKHRoaXMub3B0aW9ucy5sZWdlbmQuYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJpZ2h0QXJlYVdpZHRoID0gbGVnZW5kV2lkdGggKyB0aGlzLmdldERpbWVuc2lvbigncmlnaHRZQXhpcycpLndpZHRoO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAtIChjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKiAyKSAtIHRoaXMuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoIC0gcmlnaHRBcmVhV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNlcmllcyBoZWlnaHRcbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEhlaWdodCwgYm90dG9tQXJlYVdpZHRoO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKHRoaXMub3B0aW9ucy5sZWdlbmQuYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWdlbmRIZWlnaHQgPSB0aGlzLmdldERpbWVuc2lvbignbGVnZW5kJykuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kSGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJvdHRvbUFyZWFXaWR0aCA9IGxlZ2VuZEhlaWdodCArIHRoaXMuZGltZW5zaW9ucy54QXhpcy5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9uKCdjaGFydCcpLmhlaWdodCAtIChjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKiAyKSAtIHRoaXMuZ2V0RGltZW5zaW9uKCd0aXRsZScpLmhlaWdodCAtIGJvdHRvbUFyZWFXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGltZW5zaW9uLlxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBzZXJpZXMgZGltZW5zaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0RpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5tYWtlU2VyaWVzV2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5tYWtlU2VyaWVzSGVpZ2h0KClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2VudGVyIGNvbXBvbmV0cyBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJDZW50ZXJDb21wb25lbnRzRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuX21ha2VTZXJpZXNEaW1lbnNpb24oKTtcblxuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbignc2VyaWVzJywgc2VyaWVzRGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEaW1lbnNpb24oJ3Rvb2x0aXAnLCBzZXJpZXNEaW1lbnNpb24pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRpbWVuc2lvbignY3VzdG9tRXZlbnQnLCBzZXJpZXNEaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBheGVzIHR5cGUgY29tcG9uZW50IHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3Bvc2l0aW9ufSBzZXJpZXNQb3NpdGlvbiBzZXJpZXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdExlZ2VuZFdpZHRoIGxlZ2VuZCB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQXhpc0NvbXBvbmVudHNQb3NpdGlvbjogZnVuY3Rpb24oc2VyaWVzUG9zaXRpb24sIGxlZnRMZWdlbmRXaWR0aCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zWydwbG90J10gPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHNlcmllc1Bvc2l0aW9uLmxlZnQgLSBjaGFydENvbnN0LkhJRERFTl9XSURUSFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zWyd5QXhpcyddID0ge1xuICAgICAgICAgICAgdG9wOiBzZXJpZXNQb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNoYXJ0TGVmdFBhZGRpbmcgKyBsZWZ0TGVnZW5kV2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uc1sneEF4aXMnXSA9IHtcbiAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wICsgc2VyaWVzRGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IHNlcmllc1Bvc2l0aW9uLmxlZnQgLSBjaGFydENvbnN0LkhJRERFTl9XSURUSFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zWydyaWdodFlBeGlzJ10gPSB7XG4gICAgICAgICAgICB0b3A6IHNlcmllc1Bvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMuY2hhcnRMZWZ0UGFkZGluZyArIHRoaXMuZ2V0RGltZW5zaW9uKCd5QXhpcycpLndpZHRoICsgc2VyaWVzRGltZW5zaW9uLndpZHRoICsgbGVmdExlZ2VuZFdpZHRoIC0gY2hhcnRDb25zdC5ISURERU5fV0lEVEhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWdlbmQgYm91bmQuXG4gICAgICogQHJldHVybnMge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19fSBsZWdlbmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGVnZW5kUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZGltZW5zaW9ucyxcbiAgICAgICAgICAgIHNlcmVpc0RpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGxlZ2VuZE9wdGlvbiA9IHRoaXMub3B0aW9ucy5sZWdlbmQsXG4gICAgICAgICAgICB0b3AgPSBkaW1lbnNpb25zLnRpdGxlLmhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0JvdHRvbUxlZ2VuZEFsaWduKGxlZ2VuZE9wdGlvbi5hbGlnbikpIHtcbiAgICAgICAgICAgIHRvcCArPSBzZXJlaXNEaW1lbnNpb24uaGVpZ2h0ICsgdGhpcy5nZXREaW1lbnNpb24oJ3hBeGlzJykuaGVpZ2h0ICsgY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0hvcml6b250YWxMZWdlbmQobGVnZW5kT3B0aW9uLmFsaWduKSkge1xuICAgICAgICAgICAgbGVmdCA9ICh0aGlzLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAtIHRoaXMuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS53aWR0aCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWRpY2F0ZS5pc0xlZnRMZWdlbmRBbGlnbihsZWdlbmRPcHRpb24uYWxpZ24pKSB7XG4gICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLmdldERpbWVuc2lvbigneUF4aXMnKS53aWR0aCArIHNlcmVpc0RpbWVuc2lvbi53aWR0aCArIHRoaXMuZ2V0RGltZW5zaW9uKCdyaWdodFlBeGlzJykud2lkdGggKyB0aGlzLmNoYXJ0TGVmdFBhZGRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGVzc2VudGlhbCBjb21wb25lbnRzIHBvc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3Bvc2l0aW9ufSBzZXJpZXNQb3NpdGlvbiBzZXJpZXMgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckVzc2VudGlhbENvbXBvbmVudHNQb3NpdGlvbnM6IGZ1bmN0aW9uKHNlcmllc1Bvc2l0aW9uKSB7XG4gICAgICAgIHZhciB0b29sdGlwUG9zaXRpb247XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbJ3NlcmllcyddID0gc2VyaWVzUG9zaXRpb247XG4gICAgICAgIHRoaXMucG9zaXRpb25zWydjdXN0b21FdmVudCddPSBzZXJpZXNQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbJ2xlZ2VuZCddID0gdGhpcy5fbWFrZUxlZ2VuZFBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQXhlcykge1xuICAgICAgICAgICAgdG9vbHRpcFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRvcDogc2VyaWVzUG9zaXRpb24udG9wIC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgbGVmdDogc2VyaWVzUG9zaXRpb24ubGVmdCAtIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b29sdGlwUG9zaXRpb24gPSBzZXJpZXNQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zaXRpb25zWyd0b29sdGlwJ10gPSB0b29sdGlwUG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHBvc2l0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlclBvc2l0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGlnbk9wdGlvbiA9IHRoaXMub3B0aW9ucy5sZWdlbmQuYWxpZ24sXG4gICAgICAgICAgICBsZWdlbmREaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbignbGVnZW5kJyksXG4gICAgICAgICAgICB0b3BMZWdlbmRIZWlnaHQgPSBwcmVkaWNhdGUuaXNUb3BMZWdlbmRBbGlnbihhbGlnbk9wdGlvbikgPyBsZWdlbmREaW1lbnNpb24uaGVpZ2h0IDogMCxcbiAgICAgICAgICAgIGxlZnRMZWdlbmRXaWR0aCA9IHByZWRpY2F0ZS5pc0xlZnRMZWdlbmRBbGlnbihhbGlnbk9wdGlvbikgPyBsZWdlbmREaW1lbnNpb24ud2lkdGggOiAwLFxuICAgICAgICAgICAgc2VyaWVzUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLmdldERpbWVuc2lvbigndGl0bGUnKS5oZWlnaHQgKyBjaGFydENvbnN0LkNIQVJUX1BBRERJTkcgKyB0b3BMZWdlbmRIZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5nZXREaW1lbnNpb24oJ3lBeGlzJykud2lkdGggKyB0aGlzLmNoYXJ0TGVmdFBhZGRpbmcgKyBsZWZ0TGVnZW5kV2lkdGhcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQXhlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9uc0FuZERlZ3JlZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJBeGlzQ29tcG9uZW50c1Bvc2l0aW9uKHNlcmllc1Bvc2l0aW9uLCBsZWZ0TGVnZW5kV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFc3NlbnRpYWxDb21wb25lbnRzUG9zaXRpb25zKHNlcmllc1Bvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYm91bmRzIGRhdGEuXG4gICAgICogQHBhcmFtIHt7eEF4aXM6IG9iamVjdCwgeUF4aXM6IG9iamVjdCwgcmlnaHRZQXhpczogP29iamVjdH19IGF4ZXNEYXRhIGF4ZXMgZGF0YVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQm91bmRzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2VudGVyQ29tcG9uZW50c0RpbWVuc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5oYXNBeGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckF4aXNDb21wb25lbnRzRGltZW5zaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJQb3NpdGlvbnMoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZHNNYWtlcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBjYWxjdWxhdG9yLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvci5cbiAqIEBtb2R1bGUgY2FsY3VsYXRvclxuICovXG52YXIgY2FsY3VsYXRvciA9IHtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgbGltaXQgZnJvbSBjaGFydCBtaW4sIG1heCBkYXRhLlxuICAgICAqICAtIGh0dHA6Ly9wZWx0aWVydGVjaC5jb20vaG93LWV4Y2VsLWNhbGN1bGF0ZXMtYXV0b21hdGljLWNoYXJ0LWF4aXMtbGltaXRzL1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluIG1pbmltdW0gdmFsdWUgb2YgdXNlciBkYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXggbWF4aW11bSB2YWx1ZSBvZiB1c2VyIGRhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja0NvdW50IHRpY2sgY291bnRcbiAgICAgKiBAcmV0dXJucyB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGF4aXMgbGltaXRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVMaW1pdDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHNhdmVNaW4gPSAwLFxuICAgICAgICAgICAgbGltaXQgPSB7fSxcbiAgICAgICAgICAgIGlvZFZhbHVlOyAvLyBpbmNyZWFzZSBvciBkZWNyZWFzZSB2YWx1ZTtcblxuICAgICAgICBpZiAobWluIDwgMCkge1xuICAgICAgICAgICAgc2F2ZU1pbiA9IG1pbjtcbiAgICAgICAgICAgIG1heCAtPSBtaW47XG4gICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaW9kVmFsdWUgPSAobWF4IC0gbWluKSAvIDIwO1xuICAgICAgICBsaW1pdC5tYXggPSBtYXggKyBpb2RWYWx1ZSArIHNhdmVNaW47XG5cbiAgICAgICAgaWYgKG1heCAvIDYgPiBtaW4pIHtcbiAgICAgICAgICAgIGxpbWl0Lm1pbiA9IDAgKyBzYXZlTWluO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGltaXQubWluID0gbWluIC0gaW9kVmFsdWUgKyBzYXZlTWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW1pdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG51bWJlci5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGFyZ2V0IHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbm9ybWFsaXplZCBudW1iZXJcbiAgICAgKi9cbiAgICBub3JtYWxpemVBeGlzTnVtYmVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhbmRhcmQgPSAwLFxuICAgICAgICAgICAgZmxhZyA9IDEsXG4gICAgICAgICAgICBub3JtYWxpemVkLCBtb2Q7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBmbGFnID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSAqPSBmbGFnO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGFydENvbnN0LkFYSVNfU1RBTkRBUkRfTVVMVElQTEVfTlVNUywgZnVuY3Rpb24obnVtKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAobnVtID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZCA9IG51bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IGNoYXJ0Q29uc3QuQVhJU19MQVNUX1NUQU5EQVJEX01VTFRJUExFX05VTSkge1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkID0gbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhbmRhcmQgPCAxKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdGhpcy5ub3JtYWxpemVBeGlzTnVtYmVyKHZhbHVlICogMTApICogMC4xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kID0gdHVpLnV0aWwubW9kKHZhbHVlLCBzdGFuZGFyZCk7XG4gICAgICAgICAgICBub3JtYWxpemVkID0gdHVpLnV0aWwuYWRkaXRpb24odmFsdWUsIChtb2QgPiAwID8gc3RhbmRhcmQgLSBtb2QgOiAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkICo9IGZsYWc7XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdGljayBwb3NpdGlvbnMgb2YgcGl4ZWwgdHlwZS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmNhbGN1bGF0b3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBhcmVhIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCB0aWNrIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBtYWtlVGlja1BpeGVsUG9zaXRpb25zOiBmdW5jdGlvbihzaXplLCBjb3VudCkge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gW10sXG4gICAgICAgICAgICBweExpbWl0LCBweFN0ZXA7XG5cbiAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgcHhMaW1pdCA9IHttaW46IDAsIG1heDogc2l6ZSAtIDF9O1xuICAgICAgICAgICAgcHhTdGVwID0gdGhpcy5jYWxjdWxhdGVTdGVwRnJvbUxpbWl0KHB4TGltaXQsIGNvdW50KTtcbiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgwLCBzaXplLCBweFN0ZXApLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA9IHNpemUgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWxzIGZyb20gbGltaXQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjYWxjdWxhdG9yXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIHN0ZXAgYmV0d2VlbiBtYXggYW5kIG1pblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWtlTGFiZWxzRnJvbUxpbWl0OiBmdW5jdGlvbihsaW1pdCwgc3RlcCkge1xuICAgICAgICB2YXIgbXVsdGlwbGVOdW0gPSB0dWkudXRpbC5maW5kTXVsdGlwbGVOdW0oc3RlcCksXG4gICAgICAgICAgICBtaW4gPSBsaW1pdC5taW4gKiBtdWx0aXBsZU51bSxcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1heCAqIG11bHRpcGxlTnVtLFxuICAgICAgICAgICAgbGFiZWxzID0gdHVpLnV0aWwucmFuZ2UobWluLCBtYXggKyAxLCBzdGVwICogbXVsdGlwbGVOdW0pO1xuICAgICAgICBsYWJlbHMgPSB0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsIC8gbXVsdGlwbGVOdW07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc3RlcCBmcm9tIGxpbWl0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Y2FsY3VsYXRvclxuICAgICAqIEBwYXJhbSB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlcn19IGxpbWl0IGF4aXMgbGltaXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgdmFsdWUgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdGVwXG4gICAgICovXG4gICAgY2FsY3VsYXRlU3RlcEZyb21MaW1pdDogZnVuY3Rpb24obGltaXQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiAobGltaXQubWF4IC0gbGltaXQubWluKSAvIChjb3VudCAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYWRqYWNlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHlwb3RlbnVzZSBoeXBvdGVudXNlXG4gICAgICogQHJldHVybnMge251bWJlcn0gYWRqYWNlbnRcbiAgICAgKlxuICAgICAqICAgSCA6IEh5cG90ZW51c2VcbiAgICAgKiAgIEEgOiBBZGphY2VudFxuICAgICAqICAgTyA6IE9wcG9zaXRlXG4gICAgICogICBEIDogRGVncmVlXG4gICAgICpcbiAgICAgKiAgICAgICAgL3xcbiAgICAgKiAgICAgICAvIHxcbiAgICAgKiAgICBIIC8gIHwgT1xuICAgICAqICAgICAvICAgfFxuICAgICAqICAgIC9cXCBEIHxcbiAgICAgKiAgICAtLS0tLVxuICAgICAqICAgICAgIEFcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVBZGphY2VudDogZnVuY3Rpb24oZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNvcyhkZWdyZWUgKiBjaGFydENvbnN0LlJBRCkgKiBoeXBvdGVudXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb3Bwb3NpdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZSBkZWdyZWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaHlwb3RlbnVzZSBoeXBvdGVudXNlXG4gICAgICogQHJldHVybnMge251bWJlcn0gb3Bwb3NpdGVcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVPcHBvc2l0ZTogZnVuY3Rpb24oZGVncmVlLCBoeXBvdGVudXNlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbihkZWdyZWUgKiBjaGFydENvbnN0LlJBRCkgKiBoeXBvdGVudXNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdW0gcGx1cyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHN1bVxuICAgICAqL1xuICAgIHN1bVBsdXNWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgcGx1c1ZhbHVlcyA9IHR1aS51dGlsLmZpbHRlcih2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnN1bShwbHVzVmFsdWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VtIG1pbnVzIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtXG4gICAgICovXG4gICAgc3VtTWludXNWYWx1ZXM6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgbWludXNWYWx1ZXMgPSB0dWkudXRpbC5maWx0ZXIodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5zdW0obWludXNWYWx1ZXMpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2FsY3VsYXRvcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZSBjb2xvcnNcbiAqIEBhdXRob3IgTkhOIEVudC4gRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZXhSWCA9IC8oXiNbMC05QS1GXXs2fSQpfCheI1swLTlBLUZdezN9JCkvaTtcblxuLyoqXG4gKiBDb2xvciBtYXAuXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NzMwNTMvamF2YXNjcmlwdC1mdW5jdGlvbi10by1jb252ZXJ0LWNvbG9yLW5hbWVzLXRvLWhleC1jb2Rlc1xuICogaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL0hUTUwvaHRtbF9jb2xvcm5hbWVzLmFzcFxuICogQHR5cGUge29iamVjdH1cbiAqL1xudmFyIGNvbG9yTWFwID0ge1xuICAgICdhbGljZWJsdWUnOiAnI2YwZjhmZicsXG4gICAgJ2FudGlxdWV3aGl0ZSc6ICcjZmFlYmQ3JyxcbiAgICAnYXF1YSc6ICcjMDBmZmZmJyxcbiAgICAnYXF1YW1hcmluZSc6ICcjN2ZmZmQ0JyxcbiAgICAnYXp1cmUnOiAnI2YwZmZmZicsXG4gICAgJ2JlaWdlJzogJyNmNWY1ZGMnLFxuICAgICdiaXNxdWUnOiAnI2ZmZTRjNCcsXG4gICAgJ2JsYWNrJzogJyMwMDAwMDAnLFxuICAgICdibGFuY2hlZGFsbW9uZCc6ICcjZmZlYmNkJyxcbiAgICAnYmx1ZSc6ICcjMDAwMGZmJyxcbiAgICAnYmx1ZXZpb2xldCc6ICcjOGEyYmUyJyxcbiAgICAnYnJvd24nOiAnI2E1MmEyYScsXG4gICAgJ2J1cmx5d29vZCc6ICcjZGViODg3JyxcbiAgICAnY2FkZXRibHVlJzogJyM1ZjllYTAnLFxuICAgICdjaGFydHJldXNlJzogJyM3ZmZmMDAnLFxuICAgICdjaG9jb2xhdGUnOiAnI2QyNjkxZScsXG4gICAgJ2NvcmFsJzogJyNmZjdmNTAnLFxuICAgICdjb3JuZmxvd2VyYmx1ZSc6ICcjNjQ5NWVkJyxcbiAgICAnY29ybnNpbGsnOiAnI2ZmZjhkYycsXG4gICAgJ2NyaW1zb24nOiAnI2RjMTQzYycsXG4gICAgJ2N5YW4nOiAnIzAwZmZmZicsXG4gICAgJ2RhcmtibHVlJzogJyMwMDAwOGInLFxuICAgICdkYXJrY3lhbic6ICcjMDA4YjhiJyxcbiAgICAnZGFya2dvbGRlbnJvZCc6ICcjYjg4NjBiJyxcbiAgICAnZGFya2dyYXknOiAnI2E5YTlhOScsXG4gICAgJ2RhcmtncmVlbic6ICcjMDA2NDAwJyxcbiAgICAnZGFya2toYWtpJzogJyNiZGI3NmInLFxuICAgICdkYXJrbWFnZW50YSc6ICcjOGIwMDhiJyxcbiAgICAnZGFya29saXZlZ3JlZW4nOiAnIzU1NmIyZicsXG4gICAgJ2RhcmtvcmFuZ2UnOiAnI2ZmOGMwMCcsXG4gICAgJ2RhcmtvcmNoaWQnOiAnIzk5MzJjYycsXG4gICAgJ2RhcmtyZWQnOiAnIzhiMDAwMCcsXG4gICAgJ2RhcmtzYWxtb24nOiAnI2U5OTY3YScsXG4gICAgJ2RhcmtzZWFncmVlbic6ICcjOGZiYzhmJyxcbiAgICAnZGFya3NsYXRlYmx1ZSc6ICcjNDgzZDhiJyxcbiAgICAnZGFya3NsYXRlZ3JheSc6ICcjMmY0ZjRmJyxcbiAgICAnZGFya3R1cnF1b2lzZSc6ICcjMDBjZWQxJyxcbiAgICAnZGFya3Zpb2xldCc6ICcjOTQwMGQzJyxcbiAgICAnZGVlcHBpbmsnOiAnI2ZmMTQ5MycsXG4gICAgJ2RlZXBza3libHVlJzogJyMwMGJmZmYnLFxuICAgICdkaW1ncmF5JzogJyM2OTY5NjknLFxuICAgICdkb2RnZXJibHVlJzogJyMxZTkwZmYnLFxuICAgICdmaXJlYnJpY2snOiAnI2IyMjIyMicsXG4gICAgJ2Zsb3JhbHdoaXRlJzogJyNmZmZhZjAnLFxuICAgICdmb3Jlc3RncmVlbic6ICcjMjI4YjIyJyxcbiAgICAnZnVjaHNpYSc6ICcjZmYwMGZmJyxcbiAgICAnZ2FpbnNib3JvJzogJyNkY2RjZGMnLFxuICAgICdnaG9zdHdoaXRlJzogJyNmOGY4ZmYnLFxuICAgICdnb2xkJzogJyNmZmQ3MDAnLFxuICAgICdnb2xkZW5yb2QnOiAnI2RhYTUyMCcsXG4gICAgJ2dyYXknOiAnIzgwODA4MCcsXG4gICAgJ2dyZWVuJzogJyMwMDgwMDAnLFxuICAgICdncmVlbnllbGxvdyc6ICcjYWRmZjJmJyxcbiAgICAnaG9uZXlkZXcnOiAnI2YwZmZmMCcsXG4gICAgJ2hvdHBpbmsnOiAnI2ZmNjliNCcsXG4gICAgJ2luZGlhbnJlZCAnOiAnI2NkNWM1YycsXG4gICAgJ2luZGlnbyc6ICcjNGIwMDgyJyxcbiAgICAnaXZvcnknOiAnI2ZmZmZmMCcsXG4gICAgJ2toYWtpJzogJyNmMGU2OGMnLFxuICAgICdsYXZlbmRlcic6ICcjZTZlNmZhJyxcbiAgICAnbGF2ZW5kZXJibHVzaCc6ICcjZmZmMGY1JyxcbiAgICAnbGF3bmdyZWVuJzogJyM3Y2ZjMDAnLFxuICAgICdsZW1vbmNoaWZmb24nOiAnI2ZmZmFjZCcsXG4gICAgJ2xpZ2h0Ymx1ZSc6ICcjYWRkOGU2JyxcbiAgICAnbGlnaHRjb3JhbCc6ICcjZjA4MDgwJyxcbiAgICAnbGlnaHRjeWFuJzogJyNlMGZmZmYnLFxuICAgICdsaWdodGdvbGRlbnJvZHllbGxvdyc6ICcjZmFmYWQyJyxcbiAgICAnbGlnaHRncmV5JzogJyNkM2QzZDMnLFxuICAgICdsaWdodGdyZWVuJzogJyM5MGVlOTAnLFxuICAgICdsaWdodHBpbmsnOiAnI2ZmYjZjMScsXG4gICAgJ2xpZ2h0c2FsbW9uJzogJyNmZmEwN2EnLFxuICAgICdsaWdodHNlYWdyZWVuJzogJyMyMGIyYWEnLFxuICAgICdsaWdodHNreWJsdWUnOiAnIzg3Y2VmYScsXG4gICAgJ2xpZ2h0c2xhdGVncmF5JzogJyM3Nzg4OTknLFxuICAgICdsaWdodHN0ZWVsYmx1ZSc6ICcjYjBjNGRlJyxcbiAgICAnbGlnaHR5ZWxsb3cnOiAnI2ZmZmZlMCcsXG4gICAgJ2xpbWUnOiAnIzAwZmYwMCcsXG4gICAgJ2xpbWVncmVlbic6ICcjMzJjZDMyJyxcbiAgICAnbGluZW4nOiAnI2ZhZjBlNicsXG4gICAgJ21hZ2VudGEnOiAnI2ZmMDBmZicsXG4gICAgJ21hcm9vbic6ICcjODAwMDAwJyxcbiAgICAnbWVkaXVtYXF1YW1hcmluZSc6ICcjNjZjZGFhJyxcbiAgICAnbWVkaXVtYmx1ZSc6ICcjMDAwMGNkJyxcbiAgICAnbWVkaXVtb3JjaGlkJzogJyNiYTU1ZDMnLFxuICAgICdtZWRpdW1wdXJwbGUnOiAnIzkzNzBkOCcsXG4gICAgJ21lZGl1bXNlYWdyZWVuJzogJyMzY2IzNzEnLFxuICAgICdtZWRpdW1zbGF0ZWJsdWUnOiAnIzdiNjhlZScsXG4gICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogJyMwMGZhOWEnLFxuICAgICdtZWRpdW10dXJxdW9pc2UnOiAnIzQ4ZDFjYycsXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6ICcjYzcxNTg1JyxcbiAgICAnbWlkbmlnaHRibHVlJzogJyMxOTE5NzAnLFxuICAgICdtaW50Y3JlYW0nOiAnI2Y1ZmZmYScsXG4gICAgJ21pc3R5cm9zZSc6ICcjZmZlNGUxJyxcbiAgICAnbW9jY2FzaW4nOiAnI2ZmZTRiNScsXG4gICAgJ25hdmFqb3doaXRlJzogJyNmZmRlYWQnLFxuICAgICduYXZ5JzogJyMwMDAwODAnLFxuICAgICdvbGRsYWNlJzogJyNmZGY1ZTYnLFxuICAgICdvbGl2ZSc6ICcjODA4MDAwJyxcbiAgICAnb2xpdmVkcmFiJzogJyM2YjhlMjMnLFxuICAgICdvcmFuZ2UnOiAnI2ZmYTUwMCcsXG4gICAgJ29yYW5nZXJlZCc6ICcjZmY0NTAwJyxcbiAgICAnb3JjaGlkJzogJyNkYTcwZDYnLFxuICAgICdwYWxlZ29sZGVucm9kJzogJyNlZWU4YWEnLFxuICAgICdwYWxlZ3JlZW4nOiAnIzk4ZmI5OCcsXG4gICAgJ3BhbGV0dXJxdW9pc2UnOiAnI2FmZWVlZScsXG4gICAgJ3BhbGV2aW9sZXRyZWQnOiAnI2Q4NzA5MycsXG4gICAgJ3BhcGF5YXdoaXAnOiAnI2ZmZWZkNScsXG4gICAgJ3BlYWNocHVmZic6ICcjZmZkYWI5JyxcbiAgICAncGVydSc6ICcjY2Q4NTNmJyxcbiAgICAncGluayc6ICcjZmZjMGNiJyxcbiAgICAncGx1bSc6ICcjZGRhMGRkJyxcbiAgICAncG93ZGVyYmx1ZSc6ICcjYjBlMGU2JyxcbiAgICAncHVycGxlJzogJyM4MDAwODAnLFxuICAgICdyZWQnOiAnI2ZmMDAwMCcsXG4gICAgJ3Jvc3licm93bic6ICcjYmM4ZjhmJyxcbiAgICAncm95YWxibHVlJzogJyM0MTY5ZTEnLFxuICAgICdzYWRkbGVicm93bic6ICcjOGI0NTEzJyxcbiAgICAnc2FsbW9uJzogJyNmYTgwNzInLFxuICAgICdzYW5keWJyb3duJzogJyNmNGE0NjAnLFxuICAgICdzZWFncmVlbic6ICcjMmU4YjU3JyxcbiAgICAnc2Vhc2hlbGwnOiAnI2ZmZjVlZScsXG4gICAgJ3NpZW5uYSc6ICcjYTA1MjJkJyxcbiAgICAnc2lsdmVyJzogJyNjMGMwYzAnLFxuICAgICdza3libHVlJzogJyM4N2NlZWInLFxuICAgICdzbGF0ZWJsdWUnOiAnIzZhNWFjZCcsXG4gICAgJ3NsYXRlZ3JheSc6ICcjNzA4MDkwJyxcbiAgICAnc25vdyc6ICcjZmZmYWZhJyxcbiAgICAnc3ByaW5nZ3JlZW4nOiAnIzAwZmY3ZicsXG4gICAgJ3N0ZWVsYmx1ZSc6ICcjNDY4MmI0JyxcbiAgICAndGFuJzogJyNkMmI0OGMnLFxuICAgICd0ZWFsJzogJyMwMDgwODAnLFxuICAgICd0aGlzdGxlJzogJyNkOGJmZDgnLFxuICAgICd0b21hdG8nOiAnI2ZmNjM0NycsXG4gICAgJ3R1cnF1b2lzZSc6ICcjNDBlMGQwJyxcbiAgICAndmlvbGV0JzogJyNlZTgyZWUnLFxuICAgICd3aGVhdCc6ICcjZjVkZWIzJyxcbiAgICAnd2hpdGUnOiAnI2ZmZmZmZicsXG4gICAgJ3doaXRlc21va2UnOiAnI2Y1ZjVmNScsXG4gICAgJ3llbGxvdyc6ICcjZmZmZjAwJyxcbiAgICAneWVsbG93Z3JlZW4nOiAnIzlhY2QzMidcbn07XG5cbnZhciBjb2xvcnV0aWwgPSB7XG4gICAgLyoqXG4gICAgICogcGFkIGxlZnQgemVybyBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgbnVtYmVyIHZhbHVlIHRvIHBhZCB6ZXJvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggcGFkIGxlbmd0aCB0byB3YW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBhZGRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgbGVhZGluZ1plcm86IGZ1bmN0aW9uKG51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJycsXG4gICAgICAgICAgICBpID0gMDtcblxuICAgICAgICBpZiAoKG51bWJlciArICcnKS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgKGxlbmd0aCAtIDEpOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHplcm8gKz0gJzAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh6ZXJvICsgbnVtYmVyKS5zbGljZShsZW5ndGggKiAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkYXRlIG9mIGhleCBzdHJpbmcgdmFsdWUgaXMgUkdCXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIHJnYiBoZXggc3RyaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybiB0cnVlIHdoZW4gc3VwcGxpZWQgc3RyIGlzIHZhbGlkIFJHQiBoZXggc3RyaW5nXG4gICAgICovXG4gICAgaXNWYWxpZFJHQjogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBoZXhSWC50ZXN0KHN0cik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgY29sb3IgaGV4IHN0cmluZyB0byByZ2IgbnVtYmVyIGFycmF5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciAtIGhleCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHJnYiBudW1iZXJzXG4gICAgICovXG4gICAgaGV4VG9SR0I6IGZ1bmN0aW9uKGhleFN0cikge1xuICAgICAgICB2YXIgciwgZywgYjtcblxuICAgICAgICBpZiAoIWNvbG9ydXRpbC5pc1ZhbGlkUkdCKGhleFN0cikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhleFN0ciA9IGhleFN0ci5zdWJzdHJpbmcoMSk7XG5cbiAgICAgICAgciA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMCwgMiksIDE2KTtcbiAgICAgICAgZyA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMiwgMiksIDE2KTtcbiAgICAgICAgYiA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoNCwgMiksIDE2KTtcblxuICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHJnYiBudW1iZXIgdG8gaGV4IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gcmVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGcgLSBncmVlblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gYmx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Ym9vbGVhbn0gcmV0dXJuIGZhbHNlIHdoZW4gc3VwcGxpZWQgcmdiIG51bWJlciBpcyBub3QgdmFsaWQuIG90aGVyd2lzZSwgY29udmVydGVkIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICByZ2JUb0hFWDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgICB2YXIgaGV4U3RyID0gJyMnICtcbiAgICAgICAgICAgIGNvbG9ydXRpbC5sZWFkaW5nWmVybyhyLnRvU3RyaW5nKDE2KSwgMikgK1xuICAgICAgICAgICAgY29sb3J1dGlsLmxlYWRpbmdaZXJvKGcudG9TdHJpbmcoMTYpLCAyKSArXG4gICAgICAgICAgICBjb2xvcnV0aWwubGVhZGluZ1plcm8oYi50b1N0cmluZygxNiksIDIpO1xuXG4gICAgICAgIGlmIChjb2xvcnV0aWwuaXNWYWxpZFJHQihoZXhTdHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4U3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBuYW1lIHRvIGhleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JOYW1lIGNvbG9yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBoZXhcbiAgICAgKi9cbiAgICBjb2xvck5hbWVUb0hleDogZnVuY3Rpb24gKGNvbG9yTmFtZSkge1xuICAgICAgICByZXR1cm4gY29sb3JNYXBbY29sb3JOYW1lLnRvTG93ZXJDYXNlKCldIHx8IGNvbG9yTmFtZTtcbiAgICB9XG59O1xuXG50dWkudXRpbC5kZWZpbmVOYW1lc3BhY2UoJ3R1aS5jaGFydCcpO1xudHVpLmNoYXJ0LmNvbG9ydXRpbCA9IGNvbG9ydXRpbDtcblxubW9kdWxlLmV4cG9ydHMgPSBjb2xvcnV0aWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGF0YSBwcm9jZXNzb3IuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmVkaWNhdGUgPSByZXF1aXJlKCcuL3ByZWRpY2F0ZScpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuL3JlbmRlclV0aWwnKSxcbiAgICBjYWxjdWxhdG9yID0gcmVxdWlyZSgnLi9jYWxjdWxhdG9yJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4vKipcbiAqIFJhdyBkYXRhLlxuICogQHR5cGVkZWYge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBkYXRhOiBBcnJheS48bnVtYmVyPn0+fSByYXdTZXJpZXNEYXRhXG4gKi9cblxudmFyIERhdGFQcm9jZXNzb3IgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIERhdGFQcm9jZXNzb3IucHJvdG90eXBlICove1xuICAgIC8qKlxuICAgICAqIERhdGEgcHJvY2Vzc29yLlxuICAgICAqIEBjb25zdHJ1Y3RzIERhdGFQcm9jZXNzb3JcbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGNhdGVnb3JpZXM6IEFycmF5LjxzdHJpbmc+LFxuICAgICAqICAgICAgc2VyaWVzOiAocmF3U2VyaWVzRGF0YSB8IHtsaW5lOiA/cmF3U2VyaWVzRGF0YSwgY29sdW1uOiA/cmF3U2VyaWVzRGF0YX0pXG4gICAgICogfX0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHJhd0RhdGEpIHtcbiAgICAgICAgdGhpcy5vcmdSYXdEYXRhID0gcmF3RGF0YTtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJhdyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHt7Y2F0ZWdvcmllczogQXJyYXkuPHN0cmluZz4sIHNlcmllczogKHJhd1Nlcmllc0RhdGF8e2xpbmU6ID9yYXdTZXJpZXNEYXRhLCBjb2x1bW46ID9yYXdTZXJpZXNEYXRhfSl9fSByYXcgZGF0YVxuICAgICAqL1xuICAgIGdldFJhd0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmdSYXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHJhdyBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gcmF3RGF0YSByYXcgZGF0YVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBzZXJpZXNDaGFydFR5cGVzIGNoYXJ0IHR5cGVzXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24ocmF3RGF0YSwgb3B0aW9ucywgc2VyaWVzQ2hhcnRUeXBlcykge1xuICAgICAgICB2YXIgY2hhcnRUeXBlID0gb3B0aW9ucy5jaGFydFR5cGUsXG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gdGhpcy5fcHJvY2Vzc0NhdGVnb3JpZXMocmF3RGF0YS5jYXRlZ29yaWVzKSxcbiAgICAgICAgICAgIHNlcmllc0RhdGEgPSByYXdEYXRhLnNlcmllcyxcbiAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuX3BpY2tWYWx1ZXMoc2VyaWVzRGF0YSksXG4gICAgICAgICAgICB3aG9sZVZhbHVlcyA9IHRoaXMuX21ha2VXaG9sZVZhbHVlcyh2YWx1ZXMsIHNlcmllc0NoYXJ0VHlwZXMpLFxuICAgICAgICAgICAgbGVnZW5kTGFiZWxzID0gdGhpcy5fcGlja0xlZ2VuZExhYmVscyhzZXJpZXNEYXRhKSxcbiAgICAgICAgICAgIHdob2xlTGVnZW5kRGF0YSA9IHRoaXMuX21ha2VXaG9sZUxlZ2VuZERhdGEobGVnZW5kTGFiZWxzLCBjaGFydFR5cGUsIHNlcmllc0NoYXJ0VHlwZXMpLFxuICAgICAgICAgICAgZm9ybWF0ID0gb3B0aW9ucy5jaGFydCAmJiBvcHRpb25zLmNoYXJ0LmZvcm1hdCB8fCAnJyxcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHRoaXMuX2ZpbmRGb3JtYXRGdW5jdGlvbnMoZm9ybWF0KSxcbiAgICAgICAgICAgIHNlcmllc09wdGlvbiA9IG9wdGlvbnMuc2VyaWVzIHx8IHt9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzLCB3aG9sZUZvcm1hdHRlZFZhbHVlcztcblxuICAgICAgICB0aGlzLmRpdmVyZ2luZ09wdGlvbiA9IHByZWRpY2F0ZS5pc0JhclR5cGVDaGFydChvcHRpb25zLmNoYXJ0VHlwZSkgJiYgc2VyaWVzT3B0aW9uLmRpdmVyZ2luZztcbiAgICAgICAgZm9ybWF0dGVkVmFsdWVzID0gdGhpcy5fZm9ybWF0VmFsdWVzKHZhbHVlcywgZm9ybWF0RnVuY3Rpb25zKTtcbiAgICAgICAgd2hvbGVGb3JtYXR0ZWRWYWx1ZXMgPSB0aGlzLl9tYWtlV2hvbGVWYWx1ZXMoZm9ybWF0dGVkVmFsdWVzLCBzZXJpZXNDaGFydFR5cGVzKTtcblxuICAgICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICB3aG9sZVZhbHVlczogd2hvbGVWYWx1ZXMsXG4gICAgICAgICAgICBsZWdlbmRMYWJlbHM6IGxlZ2VuZExhYmVscyxcbiAgICAgICAgICAgIHdob2xlTGVnZW5kRGF0YTogd2hvbGVMZWdlbmREYXRhLFxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zOiBmb3JtYXRGdW5jdGlvbnMsXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXM6IGZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgICAgIHdob2xlRm9ybWF0dGVkVmFsdWVzOiB3aG9sZUZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgICAgIHBlcmNlbnRWYWx1ZXM6IHt9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBDYXRlZ29yaWVzXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fX1cbiAgICAgKi9cbiAgICBnZXRDYXRlZ29yaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jYXRlZ29yaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2F0ZWdvcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gY2F0ZWdvcnlcbiAgICAgKi9cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jYXRlZ29yaWVzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGdyb3VwIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuQXJyYXkuPG51bWJlcj59IGdyb3VwIHZhbHVlc1xuICAgICAqL1xuICAgIGdldEdyb3VwVmFsdWVzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZXNbY2hhcnRUeXBlXSB8fCB0aGlzLmRhdGEudmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgZ3JvdXBWYWx1ZXMgPSB0aGlzLmdldEdyb3VwVmFsdWVzKGNoYXJ0VHlwZSk7XG4gICAgICAgIHJldHVybiBncm91cFZhbHVlc1tncm91cEluZGV4XVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB3aG9sZSBncm91cCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59IGdydW9wIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFdob2xlR3JvdXBWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLndob2xlVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGVnZW5kIGxhYmVscy5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+IHwge2NvbHVtbjogP0FycmF5LjxzdHJpbmc+LCBsaW5lOiA/QXJyYXkuPHN0cmluZz59fSBsZWdlbmQgbGFiZWxzXG4gICAgICovXG4gICAgZ2V0TGVnZW5kTGFiZWxzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZWdlbmRMYWJlbHNbY2hhcnRUeXBlXSB8fCB0aGlzLmRhdGEubGVnZW5kTGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2hvbGUgbGVnZW5kIGRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSBsZWdlbmQgZGF0YVxuICAgICAqL1xuICAgIGdldFdob2xlTGVnZW5kRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEud2hvbGVMZWdlbmREYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgd2hvbGUgbGVnZW5kIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfT59IHdob2xlTGVnZW5kRGF0YSBsZWdlbmQgZGF0YVxuICAgICAqL1xuICAgIHNldFdob2xlTGVnZW5kRGF0YTogZnVuY3Rpb24od2hvbGVMZWdlbmREYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YS53aG9sZUxlZ2VuZERhdGEgPSB3aG9sZUxlZ2VuZERhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsZWdlbmQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nfX0gbGVnZW5kIGRhdGFcbiAgICAgKi9cbiAgICBnZXRMZWdlbmREYXRhOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLndob2xlTGVnZW5kRGF0YVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBmb3JtYXQgZnVuY3Rpb25zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48ZnVuY3Rpb24+fSBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBnZXRGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmZvcm1hdEZ1bmN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGZvcm1hdHRlZCBncm91cCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IGdyb3VwIHZhbHVlc1xuICAgICAqL1xuICAgIGdldEZvcm1hdHRlZEdyb3VwVmFsdWVzOiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5mb3JtYXR0ZWRWYWx1ZXNbY2hhcnRUeXBlXSB8fCB0aGlzLmRhdGEuZm9ybWF0dGVkVmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZm9ybWF0dGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBjaGFydFR5cGUgY2hhcnRUeXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uKGdyb3VwSW5kZXgsIGluZGV4LCBjaGFydFR5cGUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZEdyb3VwVmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0ZWRHcm91cFZhbHVlcyhjaGFydFR5cGUpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkR3JvdXBWYWx1ZXNbZ3JvdXBJbmRleF1baW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgZm9ybWF0dGVkIHZsYXVlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0VHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldEZpcnN0Rm9ybWF0dGVkVmFsdWU6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtYXR0ZWRWYWx1ZSgwLCAwLCBjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2hvbGUgZm9ybWF0dGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuQXJyYXkuPHN0cmluZz59IGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRXaG9sZUZvcm1hdHRlZFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEud2hvbGVGb3JtYXR0ZWRWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgY2F0ZWdvcmllc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNhdGVnb3JpZXMgY2F0ZWdvcmllc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gcHJvY2Vzc2VkIGNhdGVnb3JpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzQ2F0ZWdvcmllczogZnVuY3Rpb24oY2F0ZWdvcmllcykge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGNhdGVnb3JpZXMsIHR1aS51dGlsLmVuY29kZUhUTUxFbnRpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgZGF0YTogKEFycmF5LjxudW1iZXI+IHwgbnVtYmVyKX19IGl0ZW1zIGl0ZW1zXG4gICAgICogQHJldHVybnMge0FycmF5fSBwaWNrZWQgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9waWNrVmFsdWU6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoW10uY29uY2F0KGl0ZW1zLmRhdGEpLCBwYXJzZUZsb2F0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayB2YWx1ZXMgZnJvbSBheGlzIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSB2YWx1ZXNcbiAgICAgKi9cbiAgICBfcGlja1ZhbHVlczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgdmFsdWVzLCByZXN1bHQ7XG4gICAgICAgIGlmICh0dWkudXRpbC5pc0FycmF5KHNlcmllc0RhdGEpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0dWkudXRpbC5tYXAoc2VyaWVzRGF0YSwgdGhpcy5fcGlja1ZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHR1aS51dGlsLnBpdm90KHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzRGF0YSwgZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0dWkudXRpbC5tYXAoZ3JvdXBWYWx1ZXMsIHRoaXMuX3BpY2tWYWx1ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0gdHVpLnV0aWwucGl2b3QodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugd2hvbGUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Pn0gZ3JvdXBWYWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gam9pbiB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlV2hvbGVWYWx1ZXM6IGZ1bmN0aW9uKGdyb3VwVmFsdWVzLCBzZXJpZXNDaGFydFR5cGVzKSB7XG4gICAgICAgIHZhciB3aG9sZVZhbHVlcyA9IFtdO1xuXG4gICAgICAgIGlmICghc2VyaWVzQ2hhcnRUeXBlcykge1xuICAgICAgICAgICAgd2hvbGVWYWx1ZXMgPSBncm91cFZhbHVlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShzZXJpZXNDaGFydFR5cGVzLCBmdW5jdGlvbihfY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChncm91cFZhbHVlc1tfY2hhcnRUeXBlXSwgZnVuY3Rpb24odmFsdWVzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdob2xlVmFsdWVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hvbGVWYWx1ZXNbaW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hvbGVWYWx1ZXNbaW5kZXhdID0gd2hvbGVWYWx1ZXNbaW5kZXhdLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd2hvbGVWYWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgbGVnZW5kIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tMZWdlbmRMYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuZW5jb2RlSFRNTEVudGl0eShpdGVtLm5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGxlZ2VuZCBsYWJlbHMgZnJvbSBheGlzIGRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXk+fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfSBsYWJlbHNcbiAgICAgKi9cbiAgICBfcGlja0xlZ2VuZExhYmVsczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShzZXJpZXNEYXRhKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHVpLnV0aWwubWFwKHNlcmllc0RhdGEsIHRoaXMuX3BpY2tMZWdlbmRMYWJlbCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goc2VyaWVzRGF0YSwgZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdHlwZV0gPSB0dWkudXRpbC5tYXAoZ3JvdXBWYWx1ZXMsIHRoaXMuX3BpY2tMZWdlbmRMYWJlbCwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHdob2xlIGxlZ2VuZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxlZ2VuZExhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gc2VyaWVzQ2hhcnRUeXBlcyBjaGFydCB0eXBlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVdob2xlTGVnZW5kRGF0YTogZnVuY3Rpb24obGVnZW5kTGFiZWxzLCBjaGFydFR5cGUsIHNlcmllc0NoYXJ0VHlwZXMpIHtcbiAgICAgICAgdmFyIHdob2xlTGFiZWxzO1xuICAgICAgICBpZiAoIXNlcmllc0NoYXJ0VHlwZXMgfHwgIXNlcmllc0NoYXJ0VHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB3aG9sZUxhYmVscyA9IHR1aS51dGlsLm1hcChsZWdlbmRMYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdob2xlTGFiZWxzID0gW107XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoc2VyaWVzQ2hhcnRUeXBlcywgZnVuY3Rpb24oX2NoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbHMgPSB0dWkudXRpbC5tYXAobGVnZW5kTGFiZWxzW19jaGFydFR5cGVdLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnRUeXBlOiBfY2hhcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2hvbGVMYWJlbHMgPSB3aG9sZUxhYmVscy5jb25jYXQobGFiZWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aG9sZUxhYmVscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IGdyb3VwIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IGdyb3VwVmFsdWVzIGdyb3VwIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRHcm91cFZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIGZvcm1hdEZ1bmN0aW9ucykge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdmVyZ2luZ09wdGlvbikge1xuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHR1aS51dGlsLm1hcCh2YWx1ZXMsIE1hdGguYWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmbnMgPSBbdmFsdWVdLmNvbmNhdChmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoZm5zLCBmdW5jdGlvbihzdG9yZWQsIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihzdG9yZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgY29udmVydGVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheT59IGNoYXJ0VmFsdWVzIGNoYXJ0IHZhbHVlc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gZm9ybWF0RnVuY3Rpb25zIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IGZvcm1hdHRlZCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb3JtYXRWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VmFsdWVzLCBmb3JtYXRGdW5jdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0gZm9ybWF0RnVuY3Rpb25zIHx8IFtdO1xuICAgICAgICBpZiAodHVpLnV0aWwuaXNBcnJheShjaGFydFZhbHVlcykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2Zvcm1hdEdyb3VwVmFsdWVzKGNoYXJ0VmFsdWVzLCBmb3JtYXRGdW5jdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGNoYXJ0VmFsdWVzLCBmdW5jdGlvbihncm91cFZhbHVlcywgY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2NoYXJ0VHlwZV0gPSB0aGlzLl9mb3JtYXRHcm91cFZhbHVlcyhncm91cFZhbHVlcywgZm9ybWF0RnVuY3Rpb25zKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgbWF4IGxlbmd0aCB1bmRlciBwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB2YWx1ZXMgY2hhcnQgdmFsdWVzXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IGxlbmd0aCB1bmRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BpY2tNYXhMZW5VbmRlclBvaW50OiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIG1heCA9IDA7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0dWkudXRpbC5sZW5ndGhBZnRlclBvaW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsZW4gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgemVybyBmaWxsIGZvcm1hdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1plcm9GaWxsOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdC5sZW5ndGggPiAyICYmIGZvcm1hdC5jaGFyQXQoMCkgPT09ICcwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBkZWNpbWFsIGZvcm1hdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0RlY2ltYWw6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgaW5kZXhPZiA9IGZvcm1hdC5pbmRleE9mKCcuJyk7XG4gICAgICAgIHJldHVybiBpbmRleE9mID4gLTEgJiYgaW5kZXhPZiA8IGZvcm1hdC5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNvbW1hIGZvcm1hdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCBmb3JtYXRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NvbW1hOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdC5pbmRleE9mKCcsJykgPT09IGZvcm1hdC5zcGxpdCgnLicpWzBdLmxlbmd0aCAtIDQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB6ZXJvIGZpbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbiBsZW5ndGggb2YgcmVzdWx0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdFplcm9GaWxsOiBmdW5jdGlvbihsZW4sIHZhbHVlKSB7XG4gICAgICAgIHZhciB6ZXJvID0gJzAnLFxuICAgICAgICAgICAgaXNNaW51cyA9IHZhbHVlIDwgMDtcblxuICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKSArICcnO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHplcm8gKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoaXNNaW51cyA/ICctJyA6ICcnKSArIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgRGVjaW1hbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIGxlbmd0aCBvZiB1bmRlciBkZWNpbWFsIHBvaW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRhcmdldCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Zvcm1hdERlY2ltYWw6IGZ1bmN0aW9uKGxlbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBvdztcblxuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcG93ID0gTWF0aC5wb3coMTAsIGxlbik7XG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHBvdykgLyBwb3c7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZChsZW4pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBDb21tYS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGFyZ2V0IHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9ybWF0Q29tbWE6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBjb21tYSA9ICcsJyxcbiAgICAgICAgICAgIHVuZGVyUG9pbnRWYWx1ZSA9ICcnLFxuICAgICAgICAgICAgdmFsdWVzLCBsYXN0SW5kZXg7XG5cbiAgICAgICAgdmFsdWUgKz0gJyc7XG5cbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJy4nKSA+IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICB1bmRlclBvaW50VmFsdWUgPSAnLicgKyB2YWx1ZXNbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgdW5kZXJQb2ludFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzID0gKHZhbHVlKS5zcGxpdCgnJykucmV2ZXJzZSgpO1xuICAgICAgICBsYXN0SW5kZXggPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFsdWVzID0gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24oY2hhciwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbY2hhcl07XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsYXN0SW5kZXggJiYgKGluZGV4ICsgMSkgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29tbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgdmFsdWVzKS5yZXZlcnNlKCkuam9pbignJykgKyB1bmRlclBvaW50VmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgZm9ybWF0IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IGZvcm1hdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHZhbHVlcyBjaGFydCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb25bXX0gZnVuY3Rpb25zXG4gICAgICovXG4gICAgX2ZpbmRGb3JtYXRGdW5jdGlvbnM6IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgZnVuY3MgPSBbXSxcbiAgICAgICAgICAgIGxlbjtcblxuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRGVjaW1hbChmb3JtYXQpKSB7XG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9waWNrTWF4TGVuVW5kZXJQb2ludChbZm9ybWF0XSk7XG4gICAgICAgICAgICBmdW5jcyA9IFt0dWkudXRpbC5iaW5kKHRoaXMuX2Zvcm1hdERlY2ltYWwsIHRoaXMsIGxlbildO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzWmVyb0ZpbGwoZm9ybWF0KSkge1xuICAgICAgICAgICAgbGVuID0gZm9ybWF0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZ1bmNzID0gW3R1aS51dGlsLmJpbmQodGhpcy5fZm9ybWF0WmVyb0ZpbGwsIHRoaXMsIGxlbildO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzQ29tbWEoZm9ybWF0KSkge1xuICAgICAgICAgICAgZnVuY3MucHVzaCh0aGlzLl9mb3JtYXRDb21tYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbXVsdGlsaW5lIGNhdGVnb3J5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gbXVsdGlsaW5lIGNhdGVnb3J5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU11bHRpbGluZUNhdGVnb3J5OiBmdW5jdGlvbihjYXRlZ29yeSwgbGltaXRXaWR0aCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIHdvcmRzID0gY2F0ZWdvcnkuc3BsaXQoL1xccysvKSxcbiAgICAgICAgICAgIGxpbmVXb3JkcyA9IHdvcmRzWzBdLFxuICAgICAgICAgICAgbGluZXMgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkod29yZHMuc2xpY2UoMSksIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxpbmVXb3JkcyArICcgJyArIHdvcmQsIHRoZW1lKTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoID4gbGltaXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZVdvcmRzKTtcbiAgICAgICAgICAgICAgICBsaW5lV29yZHMgPSB3b3JkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lV29yZHMgKz0gJyAnICsgd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxpbmVXb3Jkcykge1xuICAgICAgICAgICAgbGluZXMucHVzaChsaW5lV29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IG11bHRpbGluZSBjYXRlZ29yaWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdFdpZHRoIGxpbWl0IHdpZHRoXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge0FycmF5fSBtdWx0aWxpbmUgY2F0ZWdvcmllc1xuICAgICAqL1xuICAgIGdldE11bHRpbGluZUNhdGVnb3JpZXM6IGZ1bmN0aW9uKGxpbWl0V2lkdGgsIHRoZW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhLm11bHRpbGluZUNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5tdWx0aWxpbmVDYXRlZ29yaWVzID0gdHVpLnV0aWwubWFwKHRoaXMuZ2V0Q2F0ZWdvcmllcygpLCBmdW5jdGlvbihjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlTXVsdGlsaW5lQ2F0ZWdvcnkoY2F0ZWdvcnksIGxpbWl0V2lkdGgsIHRoZW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5tdWx0aWxpbmVDYXRlZ29yaWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBncm91cFZhbHVlcyBncnVvcCB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gcGVyY2VudCB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGllQ2hhcnRQZXJjZW50VmFsdWVzOiBmdW5jdGlvbihncm91cFZhbHVlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSB0dWkudXRpbC5zdW0odmFsdWVzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIC8gc3VtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnQgdmFsdWVzIGZvciBub3JtYWwgc3RhY2tlZCBvcHRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBncm91cFZhbHVlcyBncnVvcCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICogQHJldHVybnMge0FycmF5fSBwZXJjZW50IHZhbHVlcyBhYm91dCBub3JtYWwgc3RhY2tlZCBvcHRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbFN0YWNrZWRQZXJjZW50VmFsdWVzOiBmdW5jdGlvbihncm91cFZhbHVlcywgbGltaXQpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMobGltaXQubWF4IC0gbGltaXQubWluKTtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnQgdmFsdWVzIGZvciBwZXJjZW50IHN0YWNrZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gZ3JvdXBWYWx1ZXMgZ3J1b3AgdmFsdWVzXG4gICAgICogQHJldHVybnMge0FycmF5fSBwZXJjZW50IHZhbHVlcyBhYm91dCBwZXJjZW50IHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBlcmNlbnRTdGFja2VkUGVyY2VudFZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGZsYXR0ZW5WYWx1ZXMgPSBjb25jYXQuYXBwbHkoW10sIGdyb3VwVmFsdWVzKSxcbiAgICAgICAgICAgIHBsdXNTdW0gPSBjYWxjdWxhdG9yLnN1bVBsdXNWYWx1ZXMoZmxhdHRlblZhbHVlcyksXG4gICAgICAgICAgICBtaW51c1N1bSA9IE1hdGguYWJzKGNhbGN1bGF0b3Iuc3VtTWludXNWYWx1ZXMoZmxhdHRlblZhbHVlcykpLFxuICAgICAgICAgICAgcmF0aW8gPSAocGx1c1N1bSA+IDAgJiYgbWludXNTdW0gPiAwKSA/IDAuNSA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gdHVpLnV0aWwuc3VtKHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKTtcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSA9PT0gMCA/IDAgOiByYXRpbyAqICh2YWx1ZSAvIHN1bSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGVyY2VudCB2YWx1ZXMgZm9yIHBlcmNlbnQgZGl2ZXJnaW5nIHN0YWNrZWQgb3B0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gZ3JvdXBWYWx1ZXMgZ3JvdXAgdmFsdWVzXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHBlcmNlbnQgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVBlcmNlbnREaXZlcmdlbnRTdGFja2VkUGVyY2VudFZhbHVlczogZnVuY3Rpb24oZ3JvdXBWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcGx1c1N1bSA9IGNhbGN1bGF0b3Iuc3VtUGx1c1ZhbHVlcyh2YWx1ZXMpLFxuICAgICAgICAgICAgICAgIG1pbnVzU3VtID0gTWF0aC5hYnMoY2FsY3VsYXRvci5zdW1NaW51c1ZhbHVlcyh2YWx1ZXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IHZhbHVlID49IDAgPyBwbHVzU3VtIDogbWludXNTdW07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSA9PT0gMCA/IDAgOiAwLjUgKiAodmFsdWUgLyBzdW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBncm91cFZhbHVlcyBncm91cCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmVUeXBlQ2hhcnQgd2hldGhlciBsaW5lIHR5cGUgY2hhcnQgb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwZXJjZW50IHZhbHVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQZXJjZW50VmFsdWVzOiBmdW5jdGlvbihncm91cFZhbHVlcywgbGltaXQsIGlzTGluZVR5cGVDaGFydCkge1xuICAgICAgICB2YXIgbWluID0gbGltaXQubWluLFxuICAgICAgICAgICAgbWF4ID0gbGltaXQubWF4LFxuICAgICAgICAgICAgZGlzdGFuY2UgPSBtYXggLSBtaW4sXG4gICAgICAgICAgICBmbGFnID0gMSxcbiAgICAgICAgICAgIHN1YlZhbHVlID0gMCxcbiAgICAgICAgICAgIHBlcmNlbnRWYWx1ZXM7XG5cbiAgICAgICAgaWYgKCFpc0xpbmVUeXBlQ2hhcnQgJiYgbWluIDwgMCAmJiBtYXggPD0gMCkge1xuICAgICAgICAgICAgZmxhZyA9IC0xO1xuICAgICAgICAgICAgc3ViVmFsdWUgPSBtYXg7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1pbiAtIG1heDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUeXBlQ2hhcnQgfHwgbWluID49IDApIHtcbiAgICAgICAgICAgIHN1YlZhbHVlID0gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgcGVyY2VudFZhbHVlcyA9IHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlIC0gc3ViVmFsdWUpICogZmxhZyAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwZXJjZW50VmFsdWVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwZXJjZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKi9cbiAgICByZWdpc3RlclBpZUNoYXJ0UGVyY2VudFZhbHVlczogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBncm91cFZhbHVlcyA9IHRoaXMuZ2V0R3JvdXBWYWx1ZXMoY2hhcnRUeXBlKTtcbiAgICAgICAgdGhpcy5kYXRhLnBlcmNlbnRWYWx1ZXNbY2hhcnRUeXBlXSA9IHRoaXMuX21ha2VQaWVDaGFydFBlcmNlbnRWYWx1ZXMoZ3JvdXBWYWx1ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBwZXJjZW50IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBheGlzIGxpbWl0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWNrZWQgc3RhY2tlZCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGVyY2VudFZhbHVlczogZnVuY3Rpb24obGltaXQsIHN0YWNrZWQsIGNoYXJ0VHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgZ3JvdXBWYWx1ZXMgPSB0aGlzLmdldEdyb3VwVmFsdWVzKGNoYXJ0VHlwZSksXG4gICAgICAgICAgICBpc0FsbG93ZWRTdGFja2VkT3B0aW9uID0gcHJlZGljYXRlLmlzQWxsb3dlZFN0YWNrZWRPcHRpb24oY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGlzTGluZVR5cGVDaGFydCA9IHByZWRpY2F0ZS5pc0xpbmVUeXBlQ2hhcnQoY2hhcnRUeXBlKTtcblxuICAgICAgICBpZiAoaXNBbGxvd2VkU3RhY2tlZE9wdGlvbiAmJiBwcmVkaWNhdGUuaXNOb3JtYWxTdGFja2VkKHN0YWNrZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYWtlTm9ybWFsU3RhY2tlZFBlcmNlbnRWYWx1ZXMoZ3JvdXBWYWx1ZXMsIGxpbWl0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FsbG93ZWRTdGFja2VkT3B0aW9uICYmIHByZWRpY2F0ZS5pc1BlcmNlbnRTdGFja2VkKHN0YWNrZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXZlcmdpbmdPcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYWtlUGVyY2VudERpdmVyZ2VudFN0YWNrZWRQZXJjZW50VmFsdWVzKGdyb3VwVmFsdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWFrZVBlcmNlbnRTdGFja2VkUGVyY2VudFZhbHVlcyhncm91cFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYWtlUGVyY2VudFZhbHVlcyhncm91cFZhbHVlcywgbGltaXQsIGlzTGluZVR5cGVDaGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGEucGVyY2VudFZhbHVlc1tjaGFydFR5cGVdID0gaXNMaW5lVHlwZUNoYXJ0ID8gdHVpLnV0aWwucGl2b3QocmVzdWx0KSA6IHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBlcmNlbnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwZXJjZW50IHZhbHVlc1xuICAgICAqL1xuICAgIGdldFBlcmNlbnRWYWx1ZXM6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnBlcmNlbnRWYWx1ZXNbY2hhcnRUeXBlXTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhUHJvY2Vzc29yO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERPTSBIYW5kbGVyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXBzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIERPTSBIYW5kbGVyLlxuICogQG1vZHVsZSBkb21IYW5kbGVyXG4gKi9cbnZhciBkb21IYW5kbGVyID0ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgaHRtbCB0YWdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgY2xhc3MgbmFtZVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gY3JlYXRlZCBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbih0YWcsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgICAgICBpZiAobmV3Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoZWwsIG5ld0NsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNsYXNzIG5hbWVzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0FycmF5fSBuYW1lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENsYXNzTmFtZXM6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUsIGNsYXNzTmFtZXM7XG5cbiAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGFwcy5jYWxsKGVsLmNsYXNzTGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBlbC5jbGFzc05hbWUgfHwgJyc7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lICYmIHR1aS51dGlsLmlzU3RyaW5nKGNsYXNzTmFtZSkgPyBjbGFzc05hbWUuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjc3MgY2xhc3MgdG8gdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2xhc3MgYWRkIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oZWwsIG5ld0NsYXNzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5fZ2V0Q2xhc3NOYW1lcyhlbCksXG4gICAgICAgICAgICBpbmRleCA9IHR1aS51dGlsLmluQXJyYXkobmV3Q2xhc3MsIGNsYXNzTmFtZXMpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJtQ2xhc3MgcmVtb3ZlIGNsYXNzIG5hbWVcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIHJtQ2xhc3MpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSB0aGlzLl9nZXRDbGFzc05hbWVzKGVsKSxcbiAgICAgICAgICAgIGluZGV4ID0gdHVpLnV0aWwuaW5BcnJheShybUNsYXNzLCBjbGFzc05hbWVzKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjbGFzc05hbWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNsYXNzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmRvbUhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaW5kQ2xhc3MgdGFyZ2V0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBoYXMgY2xhc3NcbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oZWwsIGZpbmRDbGFzcykge1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMuX2dldENsYXNzTmFtZXMoZWwpLFxuICAgICAgICAgICAgaW5kZXggPSB0dWkudXRpbC5pbkFycmF5KGZpbmRDbGFzcywgY2xhc3NOYW1lcyk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHBhcmVudCBieSBjbGFzcyBuYW1lLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZG9tSGFuZGxlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0YXJnZXQgY3NzIGNsYXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhc3RDbGFzcyBsYXN0IGNzcyBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcmVzdWx0IGVsZW1lbnRcbiAgICAgKi9cbiAgICBmaW5kUGFyZW50QnlDbGFzczogZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSwgbGFzdENsYXNzKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzQ2xhc3MocGFyZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWScgfHwgdGhpcy5oYXNDbGFzcyhwYXJlbnQsIGxhc3RDbGFzcykpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbmRQYXJlbnRCeUNsYXNzKHBhcmVudCwgY2xhc3NOYW1lLCBsYXN0Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGNoaWxkIGVsZW1lbnQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpkb21IYW5kbGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRyZW4gY2hpbGQgZWxlbWVudFxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24oY29udGFpbmVyLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IHR1aS51dGlsLmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUhhbmRsZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXZlbnQgbGlzdGVuZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXZlbnQgbGlzdGVuZXIuXG4gKiBAbW9kdWxlIGV2ZW50TGlzdGVuZXJcbiAqL1xudmFyIGV2ZW50TGlzdGVuZXIgPSB7XG4gICAgLyoqXG4gICAgICogRXZlbnQgbGlzdGVuZXIgZm9yIElFLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgbGlzdGVuZXIgZm9yIG90aGVyIGJyb3dzZXJzLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6ZXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnQgZnVuY3Rpb24uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpldmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIGJpbmRFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBiaW5kRXZlbnQ7XG4gICAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWwpIHtcbiAgICAgICAgICAgIGJpbmRFdmVudCA9IHRoaXMuX2FkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2F0dGFjaEV2ZW50JyBpbiBlbCkge1xuICAgICAgICAgICAgYmluZEV2ZW50ID0gdGhpcy5fYXR0YWNoRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRXZlbnQgPSBiaW5kRXZlbnQ7XG4gICAgICAgIGJpbmRFdmVudChldmVudE5hbWUsIGVsLCBjYWxsYmFjayk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IERhdGEgcHJvY2Vzc29yIGZvciBtYXAgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhUHJvY2Vzc29yID0gcmVxdWlyZSgnLi9kYXRhUHJvY2Vzc29yJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmVuZGVyVXRpbCcpO1xuXG4vKipcbiAqIFJhdyBkYXRhLlxuICogQHR5cGVkZWYge0FycmF5Ljx7bmFtZTogc3RyaW5nLCBkYXRhOiBBcnJheS48bnVtYmVyPn0+fSByYXdTZXJpZXNEYXRhXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjIERhdGEgcHJvY2Vzc29yIGZvciBtYXAgY2hhcnQuXG4gKiBAY2xhc3MgTWFwQ2hhcnREYXRhUHJvY2Vzc29yXG4gKi9cbnZhciBNYXBDaGFydERhdGFQcm9jZXNzb3IgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhEYXRhUHJvY2Vzc29yLCAvKiogQGxlbmRzIE1hcENoYXJ0RGF0YVByb2Nlc3Nvci5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyByYXcgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3tzZXJpZXM6IEFycmF5Ljx7Y29kZTogc3RyaW5nLCBuYW1lOiA/c3RyaW5nLCBkYXRhOiBudW1iZXJ9Pn19IHJhd0RhdGEgcmF3IGRhdGFcbiAgICAgKiBAcGFyYW0ge3tjaGFydDoge2Zvcm1hdDogc3RyaW5nfX19IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKHJhd0RhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGEgPSByYXdEYXRhLnNlcmllcyxcbiAgICAgICAgICAgIHZhbHVlTWFwID0gdGhpcy5fbWFrZVZhbHVlTWFwKHNlcmllc0RhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgICAgIHZhbHVlTWFwOiB2YWx1ZU1hcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHZhbHVlIG1hcC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7Y29kZTogc3RyaW5nLCBuYW1lOiA/c3RyaW5nLCBkYXRhOiBudW1iZXJ9Pn0gcmF3U2VyaWVzRGF0YSByYXcgc2VyaWVzIGRhdGFcbiAgICAgKiBAcGFyYW0ge3tjaGFydDoge2Zvcm1hdDogc3RyaW5nfX19IG9wdGlvbnMgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgZm9ybWF0dGVkVmFsdWU6IHN0cmluZywgbmFtZTogP3N0cmluZ319IHZhbHVlIG1hcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWYWx1ZU1hcDogZnVuY3Rpb24ocmF3U2VyaWVzRGF0YSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdmFsdWVNYXAgPSB7fSxcbiAgICAgICAgICAgIGZvcm1hdCA9IG9wdGlvbnMuY2hhcnQgJiYgb3B0aW9ucy5jaGFydC5mb3JtYXQgfHwgJycsXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLl9maW5kRm9ybWF0RnVuY3Rpb25zKGZvcm1hdCk7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHJhd1Nlcmllc0RhdGEsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkYXR1bS5kYXRhLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKGRhdHVtLmRhdGEsIGZvcm1hdEZ1bmN0aW9ucylcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChkYXR1bS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBkYXR1bS5uYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0dW0ubGFiZWxDb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxhYmVsQ29vcmRpbmF0ZSA9IGRhdHVtLmxhYmVsQ29vcmRpbmF0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVNYXBbZGF0dW0uY29kZV0gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZU1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlIG1hcC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldFZhbHVlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS52YWx1ZU1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IHBpY2tlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnBsdWNrKHRoaXMuZGF0YS52YWx1ZU1hcCwgJ3ZhbHVlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB2YWx1ZU1hcCBkYXR1bS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBtYXAgY29kZVxuICAgICAqIEByZXR1cm5zIHt7Y29kZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGZvcm1hdHRlZFZhbHVlOiBudW1iZXIsIGxhYmVsQ29vcmRpbmF0ZToge3g6IG51bWJlciwgeTogbnVtYmVyfX19IHZhbHVlTWFwIGRhdHVtXG4gICAgICovXG4gICAgZ2V0VmFsdWVNYXBEYXR1bTogZnVuY3Rpb24oY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnZhbHVlTWFwW2NvZGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBlcmNlbnQgdmFsdWUuXG4gICAgICogQHBhcmFtIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX0gbGltaXQgYXhpcyBsaW1pdFxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGVyY2VudFZhbHVlczogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgdmFyIG1pbiA9IGxpbWl0Lm1pbixcbiAgICAgICAgICAgIG1heCA9IGxpbWl0Lm1heCAtIG1pbjtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaCh0aGlzLmdldFZhbHVlTWFwKCksIGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgbWFwLnBlcmNlbnRWYWx1ZSA9IChtYXAudmFsdWUgLSBtaW4pIC8gbWF4O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDaGFydERhdGFQcm9jZXNzb3I7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUHJlZGljYXRlLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbi8qKlxuICogcHJlZGljYXRlLlxuICogQG1vZHVsZSBwcmVkaWNhdGVcbiAqL1xudmFyIHByZWRpY2F0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGJhciBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0JhckNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0JBUjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjb2x1bW4gY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNDb2x1bW5DaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT0xVTU47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYmFyIHR5cGUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNCYXJUeXBlQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0JhckNoYXJ0KGNoYXJ0VHlwZSkgfHwgdGhpcy5pc0NvbHVtbkNoYXJ0KGNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY29tYm8gY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNDb21ib0NoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTUJPO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxpbmUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNMaW5lQ2hhcnQ6IGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2hhcnRUeXBlID09PSBjaGFydENvbnN0LkNIQVJUX1RZUEVfTElORTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhcmVhIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzQXJlYUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX0FSRUE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbGluZSB0eXBlIGNoYXJ0IG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzTGluZVR5cGVDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGluZUNoYXJ0KGNoYXJ0VHlwZSkgfHwgdGhpcy5pc0FyZWFDaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHBpZSBjaGFydCBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc1BpZUNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJ0VHlwZSA9PT0gY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBtYXAgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNNYXBDaGFydDogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjaGFydFR5cGUgPT09IGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9NQVA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbW91c2UgcG9zaXRpb24gY2hhcnQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzTW91c2VQb3NpdGlvbkNoYXJ0OiBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQaWVDaGFydChjaGFydFR5cGUpIHx8IHRoaXMuaXNNYXBDaGFydChjaGFydFR5cGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG91dGVyIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc091dGVyTGVnZW5kQWxpZ246IGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBhbGlnbiA9PT0gY2hhcnRDb25zdC5MRUdFTkRfQUxJR05fT1VURVI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2VudGVyIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0NlbnRlckxlZ2VuZEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX0FMSUdOX0NFTlRFUjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBsZWZ0IGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0xlZnRMZWdlbmRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSBjaGFydENvbnN0LkxFR0VORF9BTElHTl9MRUZUO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvcCBsZWdlbmQgYWxpZ24gb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGxlZ2VuZCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNUb3BMZWdlbmRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFsaWduID09PSBjaGFydENvbnN0LkxFR0VORF9BTElHTl9UT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYm90dG9tIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gbGVnZW5kIHR5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0JvdHRvbUxlZ2VuZEFsaWduOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gYWxpZ24gPT09IGNoYXJ0Q29uc3QuTEVHRU5EX0FMSUdOX0JPVFRPTTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBob3Jpem9udGFsIGxlZ2VuZCBhbGlnbiBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWduIGFsaWduXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNIb3Jpem9udGFsTGVnZW5kOiBmdW5jdGlvbihhbGlnbikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1RvcExlZ2VuZEFsaWduKGFsaWduKSB8fCB0aGlzLmlzQm90dG9tTGVnZW5kQWxpZ24oYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGxlZ2VuZCBhbGlnbiBvZiBwaWUgY2hhcnQgb3Igbm90LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbiBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNQaWVMZWdlbmRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaXNPdXRlckxlZ2VuZEFsaWduKGFsaWduKSB8fCB0aGlzLmlzQ2VudGVyTGVnZW5kQWxpZ24oYWxpZ24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxsb3dlZCBzdGFja2VkIG9wdGlvbiBvciBub3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNBbGxvd2VkU3RhY2tlZE9wdGlvbjogZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFyQ2hhcnQoY2hhcnRUeXBlKSB8fCB0aGlzLmlzQ29sdW1uQ2hhcnQoY2hhcnRUeXBlKSB8fCB0aGlzLmlzQXJlYUNoYXJ0KGNoYXJ0VHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgbm9ybWFsIHN0YWNrZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhY2tlZCBzdGFja2VkIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqL1xuICAgIGlzTm9ybWFsU3RhY2tlZDogZnVuY3Rpb24oc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PT0gY2hhcnRDb25zdC5TVEFDS0VEX05PUk1BTF9UWVBFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHBlcmNlbnQgc3RhY2tlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNQZXJjZW50U3RhY2tlZDogZnVuY3Rpb24oc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PT0gY2hhcnRDb25zdC5TVEFDS0VEX1BFUkNFTlRfVFlQRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB2YWxpZCBzdGFja2VkIG9wdGlvbiBvciBub3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFja2VkIHN0YWNrZWQgb3B0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICovXG4gICAgaXNWYWxpZFN0YWNrZWRPcHRpb246IGZ1bmN0aW9uKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgJiYgKHRoaXMuaXNOb3JtYWxTdGFja2VkKHN0YWNrZWQpIHx8IHRoaXMuaXNQZXJjZW50U3RhY2tlZChzdGFja2VkKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmVkaWNhdGU7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVXRpbCBmb3IgcmVuZGVyaW5nLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb21IYW5kbGVyJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4vLi4vY29uc3QnKTtcblxudmFyIGJyb3dzZXIgPSB0dWkudXRpbC5icm93c2VyLFxuICAgIGlzSUU3ID0gYnJvd3Nlci5tc2llICYmIGJyb3dzZXIudmVyc2lvbiA9PT0gNyxcbiAgICBpc09sZEJyb3dzZXIgPSBicm93c2VyLm1zaWUgJiYgYnJvd3Nlci52ZXJzaW9uIDw9IDg7XG5cbi8qKlxuICogVXRpbCBmb3IgcmVuZGVyaW5nLlxuICogQG1vZHVsZSByZW5kZXJVdGlsXG4gKi9cbnZhciByZW5kZXJVdGlsID0ge1xuICAgIC8qKlxuICAgICAqIENvbmNhdCBzdHJpbmcuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtcyB7Li4uc3RyaW5nfSB0YXJnZXQgc3RyaW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvbmNhdCBzdHJpbmdcbiAgICAgKi9cbiAgICBjb25jYXRTdHI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5jb25jYXQuYXBwbHkoJycsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY3NzVGV4dCBmb3IgZm9udC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBmb250IHRoZW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3NzVGV4dFxuICAgICAqL1xuICAgIG1ha2VGb250Q3NzVGV4dDogZnVuY3Rpb24odGhlbWUpIHtcbiAgICAgICAgdmFyIGNzc1RleHRzID0gW107XG5cbiAgICAgICAgaWYgKCF0aGVtZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoZW1lLmZvbnRTaXplKSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHRoaXMuY29uY2F0U3RyKCdmb250LXNpemU6JywgdGhlbWUuZm9udFNpemUsICdweCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGVtZS5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICBjc3NUZXh0cy5wdXNoKHRoaXMuY29uY2F0U3RyKCdmb250LWZhbWlseTonLCB0aGVtZS5mb250RmFtaWx5KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuY29sb3IpIHtcbiAgICAgICAgICAgIGNzc1RleHRzLnB1c2godGhpcy5jb25jYXRTdHIoJ2NvbG9yOicsIHRoZW1lLmNvbG9yKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3NzVGV4dHMuam9pbignOycpO1xuICAgIH0sXG5cbiAgICBjaGVja0VsOiBudWxsLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlbGVtZW50IGZvciBzaXplIGNoZWNrLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVNpemVDaGVja0VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpdiwgc3BhbjtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrRWwpIHtcbiAgICAgICAgICAgIGRpdiA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtc2l6ZS1jaGVjay1lbGVtZW50Jyk7XG4gICAgICAgICAgICBzcGFuID0gZG9tLmNyZWF0ZSgnU1BBTicpO1xuICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgdGhpcy5jaGVja0VsID0gZGl2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VsLnN0eWxlLmNzc1RleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2FjaGluZyBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIGxhYmVrXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogc3RyaW5nfX0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0VHlwZSBvZmZzZXQgdHlwZSAob2Zmc2V0V2lkdGggb3Igb2Zmc2V0SGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDYWNoaW5nS2V5OiBmdW5jdGlvbihsYWJlbCwgdGhlbWUsIG9mZnNldFR5cGUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbbGFiZWwsIG9mZnNldFR5cGVdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2godGhlbWUsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkgKyB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBrZXlzLmpvaW4oJy0nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBjYWNoZS5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHNpemVDYWNoZToge30sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3NzIHN0eWxlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpdiBkaXYgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IHN0cmluZywgY3NzVGV4dDogc3RyaW5nfX0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRDc3NTdHlsZTogZnVuY3Rpb24oZGl2LCB0aGVtZSkge1xuICAgICAgICBkaXYuc3R5bGUuZm9udFNpemUgPSAodGhlbWUuZm9udFNpemUgfHwgY2hhcnRDb25zdC5ERUZBVUxUX0xBQkVMX0ZPTlRfU0laRSkgKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGVtZS5mb250RmFtaWx5KSB7XG4gICAgICAgICAgICBkaXYuc3R5bGUuZm9udEZhbWlseSA9IHRoZW1lLmZvbnRGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhlbWUuY3NzVGV4dCkge1xuICAgICAgICAgICAgZGl2LnN0eWxlLmNzc1RleHQgKz0gdGhlbWUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWwgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gbGFiZWwgbGFiZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0VHlwZSBvZmZzZXQgdHlwZSAob2Zmc2V0V2lkdGggb3Igb2Zmc2V0SGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZExhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWwsIHRoZW1lLCBvZmZzZXRUeXBlKSB7XG4gICAgICAgIHZhciBrZXksIGRpdiwgc3BhbiwgbGFiZWxTaXplO1xuXG4gICAgICAgIHRoZW1lID0gdGhlbWUgfHwge307XG5cbiAgICAgICAgbGFiZWwgKz0gJyc7XG5cbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSB0aGlzLl9tYWtlQ2FjaGluZ0tleShsYWJlbCwgdGhlbWUsIG9mZnNldFR5cGUpO1xuICAgICAgICBsYWJlbFNpemUgPSB0aGlzLnNpemVDYWNoZVtrZXldO1xuXG4gICAgICAgIGlmICghbGFiZWxTaXplKSB7XG4gICAgICAgICAgICBkaXYgPSB0aGlzLl9jcmVhdGVTaXplQ2hlY2tFbCgpO1xuICAgICAgICAgICAgc3BhbiA9IGRpdi5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICBzcGFuLmlubmVySFRNTCA9IGxhYmVsO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRDc3NTdHlsZShkaXYsIHRoZW1lKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgbGFiZWxTaXplID0gc3BhbltvZmZzZXRUeXBlXTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcblxuICAgICAgICAgICAgdGhpcy5zaXplQ2FjaGVba2V5XSA9IGxhYmVsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYWJlbFNpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCByZW5kZXJlZCBsYWJlbCB3aWR0aC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHdpZHRoXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbFdpZHRoOiBmdW5jdGlvbihsYWJlbCwgdGhlbWUpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSB0aGlzLl9nZXRSZW5kZXJlZExhYmVsU2l6ZShsYWJlbCwgdGhlbWUsICdvZmZzZXRXaWR0aCcpO1xuICAgICAgICByZXR1cm4gbGFiZWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVsIGhlaWdodC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkTGFiZWxIZWlnaHQ6IGZ1bmN0aW9uKGxhYmVsLCB0aGVtZSkge1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSB0aGlzLl9nZXRSZW5kZXJlZExhYmVsU2l6ZShsYWJlbCwgdGhlbWUsICdvZmZzZXRIZWlnaHQnKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsSGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgUmVuZGVyZWQgTGFiZWxzIE1heCBTaXplKHdpZHRoIG9yIGhlaWdodCkuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIGl0ZXJhdGVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbWF4IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJlZExhYmVsc01heFNpemU6IGZ1bmN0aW9uKGxhYmVscywgdGhlbWUsIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBzaXplcyA9IHR1aS51dGlsLm1hcChsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGxhYmVsLCB0aGVtZSk7XG4gICAgICAgICAgICB9LCB0aGlzKSxcbiAgICAgICAgICAgIG1heFNpemUgPSB0dWkudXRpbC5tYXgoc2l6ZXMpO1xuICAgICAgICByZXR1cm4gbWF4U2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHJlbmRlcmVkIGxhYmVscyBtYXggd2lkdGguXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1heCB3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aDogZnVuY3Rpb24obGFiZWxzLCB0aGVtZSkge1xuICAgICAgICB2YXIgaXRlcmF0ZWUgPSB0dWkudXRpbC5iaW5kKHRoaXMuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoLCB0aGlzKSxcbiAgICAgICAgICAgIG1heFdpZHRoID0gdGhpcy5fZ2V0UmVuZGVyZWRMYWJlbHNNYXhTaXplKGxhYmVscywgdGhlbWUsIGl0ZXJhdGVlKTtcbiAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgcmVuZGVyZWQgbGFiZWxzIG1heCBoZWlnaHQuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpib3VuZHNNYWtlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxhYmVscyBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBzdHJpbmcsIGNvbG9yOiBzdHJpbmd9fSB0aGVtZSBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG1heCBoZWlnaHRcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZExhYmVsc01heEhlaWdodDogZnVuY3Rpb24obGFiZWxzLCB0aGVtZSkge1xuICAgICAgICB2YXIgaXRlcmF0ZWUgPSB0dWkudXRpbC5iaW5kKHRoaXMuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodCwgdGhpcyksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLl9nZXRSZW5kZXJlZExhYmVsc01heFNpemUobGFiZWxzLCB0aGVtZSwgaXRlcmF0ZWUpO1xuICAgICAgICByZXR1cm4gbWF4SGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZGltZW5zaW9uLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICovXG4gICAgcmVuZGVyRGltZW5zaW9uOiBmdW5jdGlvbihlbCwgZGltZW5zaW9uKSB7XG4gICAgICAgIGVsLnN0eWxlLmNzc1RleHQgPSBbXG4gICAgICAgICAgICB0aGlzLmNvbmNhdFN0cignd2lkdGg6JywgZGltZW5zaW9uLndpZHRoLCAncHgnKSxcbiAgICAgICAgICAgIHRoaXMuY29uY2F0U3RyKCdoZWlnaHQ6JywgZGltZW5zaW9uLmhlaWdodCwgJ3B4JylcbiAgICAgICAgXS5qb2luKCc7Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwb3NpdGlvbih0b3AsIHJpZ2h0KS5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqL1xuICAgIHJlbmRlclBvc2l0aW9uOiBmdW5jdGlvbihlbCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHR1aS51dGlsLmlzVW5kZWZpbmVkKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi50b3ApKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBwb3NpdGlvbi50b3AgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi5sZWZ0KSkge1xuICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHBvc2l0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi5yaWdodCkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnJpZ2h0ID0gcG9zaXRpb24ucmlnaHQgKyAncHgnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBiYWNrZ3JvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHRhcmdldCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmQgYmFja2dyb3VuZCBvcHRpb25cbiAgICAgKi9cbiAgICByZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihlbCwgYmFja2dyb3VuZCkge1xuICAgICAgICBpZiAoIWJhY2tncm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZm9udCBmYW1pbHkuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgdGFyZ2V0IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9udEZhbWlseSBmb250IGZhbWlseSBvcHRpb25cbiAgICAgKi9cbiAgICByZW5kZXJGb250RmFtaWx5OiBmdW5jdGlvbihlbCwgZm9udEZhbWlseSkge1xuICAgICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGl0bGUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyZW5kZXJVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIHRpdGxlXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgY29sb3I6IHN0cmluZywgYmFja2dyb3VuZDogc3RyaW5nfX0gdGhlbWUgdGl0bGUgdGhlbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIGNzcyBjbGFzcyBuYW1lXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aXRsZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyVGl0bGU6IGZ1bmN0aW9uKHRpdGxlLCB0aGVtZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBlbFRpdGxlLCBjc3NUZXh0O1xuXG4gICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxUaXRsZSA9IGRvbS5jcmVhdGUoJ0RJVicsIGNsYXNzTmFtZSk7XG4gICAgICAgIGVsVGl0bGUuaW5uZXJIVE1MID0gdGl0bGU7XG5cbiAgICAgICAgY3NzVGV4dCA9IHJlbmRlclV0aWwubWFrZUZvbnRDc3NUZXh0KHRoZW1lKTtcblxuICAgICAgICBpZiAodGhlbWUuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgY3NzVGV4dCArPSAnOycgKyB0aGlzLmNvbmNhdFN0cignYmFja2dyb3VuZDonLCB0aGVtZS5iYWNrZ3JvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVGl0bGUuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7XG5cbiAgICAgICAgcmV0dXJuIGVsVGl0bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZCBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBleHBlbmRlZCBib3VuZFxuICAgICAqL1xuICAgIGV4cGFuZEJvdW5kOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gYm91bmQuZGltZW5zaW9uLFxuICAgICAgICAgICAgcG9zaXRpb24gPSBib3VuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBkaW1lbnNpb24ud2lkdGggKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAqIDIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb24uaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUgKiAyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGN1c3RvbSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggcHJlZml4XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1ZmZpeCBzdWZmaXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBjdXN0b20gZXZlbnQgbmFtZVxuICAgICAqL1xuICAgIG1ha2VDdXN0b21FdmVudE5hbWU6IGZ1bmN0aW9uKHByZWZpeCwgdmFsdWUsIHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgdHVpLnV0aWwucHJvcGVyQ2FzZSh2YWx1ZSkgKyB0dWkudXRpbC5wcm9wZXJDYXNlKHN1ZmZpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxmdW5jdGlvbj59IGZvcm1hdEZ1bmN0aW9ucyBmdW5jdGlvbnMgZm9yIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqL1xuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0RnVuY3Rpb25zKSB7XG4gICAgICAgIHZhciBmbnMgPSBbdmFsdWVdLmNvbmNhdChmb3JtYXRGdW5jdGlvbnMgfHwgW10pO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5yZWR1Y2UoZm5zLCBmdW5jdGlvbihzdG9yZWQsIGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oc3RvcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge3tpZDogbnVtYmVyfX0gYW5pbWF0aW9uIGFuaW1haW9uIG9iamVjdFxuICAgICAqL1xuICAgIGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLmlkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb24uaWQpO1xuICAgICAgICAgICAgZGVsZXRlIGFuaW1hdGlvbi5pZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvblRpbWUgYW5pbWF0aW9uIHRpbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHt7aWQ6IG51bWJlcn19IHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZFxuICAgICAqL1xuICAgIHN0YXJ0QW5pbWF0aW9uOiBmdW5jdGlvbihhbmltYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0ge30sXG4gICAgICAgICAgICBzdGFydFRpbWU7XG5cbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBkaWZmVGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgcmF0aW8gPSBNYXRoLm1pbigoZGlmZlRpbWUgLyBhbmltYXRpb25UaW1lKSwgMSk7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKHJhdGlvKTtcblxuICAgICAgICAgICAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFuaW1hdGlvbi5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgYW5pbWF0aW9uLmlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuXG4gICAgICAgIHJldHVybiBhbmltYXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgSUU3IG9yIG5vdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc0lFNzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0lFNztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvbGRCcm93c2VyIG9yIG5vdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnJlbmRlclV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKi9cbiAgICBpc09sZEJyb3dzZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXNPbGRCcm93c2VyO1xuICAgIH1cbn07XG5cbnR1aS51dGlsLmRlZmluZU5hbWVzcGFjZSgndHVpLmNoYXJ0Jyk7XG50dWkuY2hhcnQucmVuZGVyVXRpbCA9IHJlbmRlclV0aWw7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyVXRpbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlIG1ha2VyLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRlbXBsYXRlIG1ha2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIGh0bWxcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IHRlbXBsYXRlIGZ1bmN0aW9uXG4gICAgICogQGVheG1wbGVcbiAgICAgKlxuICAgICAqICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVNYWtlci50ZW1wbGF0ZSgnPHNwYW4+e3sgbmFtZSB9fTwvc3Bhbj4nKSxcbiAgICAgKiAgICAgICByZXN1bHQgPSB0ZW1wbGF0ZSh7bmFtZTogJ0pvaG4nKTtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIDxzcGFuPkpvaG48L3NwYW4+XG4gICAgICpcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaHRtbDtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgne3tcXFxccyonICsga2V5ICsgJ1xcXFxzKn19JywgJ2cnKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWdFeHAsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVzZXJFdmVudExpc3RlbmVyIGlzIGxpc3RlbmVyIG9mIHVzZXIgZXZlbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVc2VyRXZlbnRMaXN0ZW5lciA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVXNlckV2ZW50TGlzdGVuZXIucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgZXZlbnQgY2FsbGJhY2tcbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24oZXZlbnROYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBmdW5jKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFVzZXJFdmVudExpc3RlbmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyRXZlbnRMaXN0ZW5lcjtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyAgTGVnZW5kIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExlZ2VuZE1vZGVsID0gcmVxdWlyZSgnLi9sZWdlbmRNb2RlbCcpLFxuICAgIExlZ2VuZERpbWVuc2lvbk1vZGVsID0gcmVxdWlyZSgnLi9sZWdlbmREaW1lbnNpb25Nb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBsZWdlbmRUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vLi4vbGVnZW5kcy9sZWdlbmRUZW1wbGF0ZScpO1xuXG52YXIgTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBMZWdlbmQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMZWdlbmQgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBheGlzIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gcGFyYW1zLmNoYXJ0VHlwZXMgY2hhcnQgdHlwZXNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhcnQgdHlwZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGVnZW5kRGF0YTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgdHlwZXNcbiAgICAgICAgICogQHR5cGUgez9BcnJheS48c3RyaW5nPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlcyA9IHBhcmFtcy5jaGFydFR5cGVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IHBhcmFtcy5jaGFydFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZXIgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJFdmVudCA9IHBhcmFtcy51c2VyRXZlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlZ2VuZCB2aWV3IGNsYXNzTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LWxlZ2VuZC1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tlZCBpbmRleGVzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgbGVnZW5kRGF0YSA9IHBhcmFtcy5kYXRhUHJvY2Vzc29yLmdldFdob2xlTGVnZW5kRGF0YSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIG1vZGVsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsID0gbmV3IExlZ2VuZE1vZGVsKHtcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgbGFiZWxzOiBwYXJhbXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmRMYWJlbHMoKSxcbiAgICAgICAgICAgIGxlZ2VuZERhdGE6IGxlZ2VuZERhdGEsXG4gICAgICAgICAgICBjaGFydFR5cGVzOiB0aGlzLmNoYXJ0VHlwZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGltZW5zaW9uTW9kZWwgPSBuZXcgTGVnZW5kRGltZW5zaW9uTW9kZWwoe1xuICAgICAgICAgICAgbGVnZW5kTGFiZWxzOiB0dWkudXRpbC5wbHVjayhsZWdlbmREYXRhLCAnbGFiZWwnKSxcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB0aGVtZTogdGhpcy50aGVtZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbGVnZW5kIGRpbWVuc2lvbi5cbiAgICAgKi9cbiAgICByZWdpc3RlckRpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGFydFdpZHRoID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0Jykud2lkdGg7XG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCB0aGlzLmRpbWVuc2lvbk1vZGVsLm1ha2VEaW1lbnNpb24oY2hhcnRXaWR0aCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbGVnZW5kQ29udGFpbmVyIGxlZ2VuZCBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBib3VuZCBsZW5nZW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IGNoZWNrZWRJbmRleGVzIGNoZWNrZWQgaW5kZXhlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxlZ2VuZEFyZWE6IGZ1bmN0aW9uKGxlZ2VuZENvbnRhaW5lcikge1xuICAgICAgICBsZWdlbmRDb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy5fbWFrZUxlZ2VuZEh0bWwodGhpcy5sZWdlbmRNb2RlbC5nZXREYXRhKCkpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGxlZ2VuZENvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXRQb3NpdGlvbignbGVnZW5kJykpO1xuICAgICAgICBsZWdlbmRDb250YWluZXIuc3R5bGUuY3NzVGV4dCArPSAnOycgKyByZW5kZXJVdGlsLm1ha2VGb250Q3NzVGV4dCh0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBsZWdlbmQgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmxlZ2VuZENvbnRhaW5lciA9IGVsO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKHRoaXMub3B0aW9ucy5hbGlnbikpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhlbCwgJ2hvcml6b250YWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEoZWwpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFdmVudChlbCk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY3NzVGV4dCBvZiBsZWdlbmQgcmVjdC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGNoYXJ0VHlwZTogc3RyaW5nLFxuICAgICAqICAgICAgdGhlbWU6IHtjb2xvcjogc3RyaW5nLCBib3JkZXJDb2xvcjogP3N0cmluZywgc2luZ2xlQ29sb3I6ID9zdHJpbmd9XG4gICAgICogfX0gbGVnZW5kRGF0dW0gbGVnZW5kIGRhdHVtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VNYXJnaW5Ub3AgYmFzZSBtYXJnaW4tdG9wXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY3NzVGV4dCBvZiBsZWdlbmQgcmVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWdlbmRSZWN0Q3NzVGV4dDogZnVuY3Rpb24obGVnZW5kRGF0dW0sIGJhc2VNYXJnaW5Ub3ApIHtcbiAgICAgICAgdmFyIHRoZW1lID0gbGVnZW5kRGF0dW0udGhlbWUsXG4gICAgICAgICAgICBib3JkZXJDc3NUZXh0ID0gdGhlbWUuYm9yZGVyQ29sb3IgPyByZW5kZXJVdGlsLmNvbmNhdFN0cignO2JvcmRlcjoxcHggc29saWQgJywgdGhlbWUuYm9yZGVyQ29sb3IpIDogJycsXG4gICAgICAgICAgICByZWN0TWFyZ2luLCBtYXJnaW5Ub3A7XG4gICAgICAgIGlmIChsZWdlbmREYXR1bS5jaGFydFR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgbWFyZ2luVG9wID0gYmFzZU1hcmdpblRvcCArIGNoYXJ0Q29uc3QuTElORV9NQVJHSU5fVE9QO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFyZ2luVG9wID0gYmFzZU1hcmdpblRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3RNYXJnaW4gPSByZW5kZXJVdGlsLmNvbmNhdFN0cignO21hcmdpbi10b3A6JywgbWFyZ2luVG9wLCAncHgnKTtcblxuICAgICAgICByZXR1cm4gcmVuZGVyVXRpbC5jb25jYXRTdHIoJ2JhY2tncm91bmQtY29sb3I6JywgdGhlbWUuc2luZ2xlQ29sb3IgfHwgdGhlbWUuY29sb3IsIGJvcmRlckNzc1RleHQsIHJlY3RNYXJnaW4pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWxzIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtjaGFydFR5cGU6ID9zdHJpbmcsIGxhYmVsOiBzdHJpbmd9Pn0gbGVnZW5kRGF0YSBsZWdlbmQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gbGFiZWxzIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxhYmVsc1dpZHRoOiBmdW5jdGlvbihsZWdlbmREYXRhKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAobGVnZW5kRGF0YSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChpdGVtLmxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWdlbmQgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7Y2hhcnRUeXBlOiA/c3RyaW5nLCBsYWJlbDogc3RyaW5nfT59IGxlZ2VuZERhdGEgbGVnZW5kIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsZWdlbmQgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMZWdlbmRIdG1sOiBmdW5jdGlvbihsZWdlbmREYXRhKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGxlZ2VuZFRlbXBsYXRlLnRwbExlZ2VuZCxcbiAgICAgICAgICAgIGNoZWNrQm94VGVtcGxhdGUgPSBsZWdlbmRUZW1wbGF0ZS50cGxDaGVja2JveCxcbiAgICAgICAgICAgIGxhYmVsc1dpZHRoID0gdGhpcy5fbWFrZUxhYmVsc1dpZHRoKGxlZ2VuZERhdGEpLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGVnZW5kRGF0YVswXS5sYWJlbCwgbGVnZW5kRGF0YVswXS50aGVtZSksXG4gICAgICAgICAgICBpc0hvcml6b250YWxMZWdlbmQgPSBwcmVkaWNhdGUuaXNIb3Jpem9udGFsTGVnZW5kKHRoaXMub3B0aW9ucy5hbGlnbiksXG4gICAgICAgICAgICBoZWlnaHQgPSBsYWJlbEhlaWdodCArIChjaGFydENvbnN0LkxBQkVMX1BBRERJTkdfVE9QICogMiksXG4gICAgICAgICAgICBiYXNlTWFyZ2luVG9wID0gcGFyc2VJbnQoKGhlaWdodCAtIGNoYXJ0Q29uc3QuTEVHRU5EX1JFQ1RfV0lEVEgpIC8gMiwgMTApIC0gMSxcbiAgICAgICAgICAgIGh0bWwgPSB0dWkudXRpbC5tYXAobGVnZW5kRGF0YSwgZnVuY3Rpb24obGVnZW5kRGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3RDc3NUZXh0ID0gdGhpcy5fbWFrZUxlZ2VuZFJlY3RDc3NUZXh0KGxlZ2VuZERhdHVtLCBiYXNlTWFyZ2luVG9wKSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLm9wdGlvbnMuaGFzQ2hlY2tib3ggPT09IGZhbHNlID8gJycgOiBjaGVja0JveFRlbXBsYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRoaXMubGVnZW5kTW9kZWwuaXNDaGVja2VkSW5kZXgoaW5kZXgpID8gJyBjaGVja2VkJyA6ICcnXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdENzc1RleHQ6IHJlY3RDc3NUZXh0LFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB1bnNlbGVjdGVkOiB0aGlzLmxlZ2VuZE1vZGVsLmlzVW5zZWxlY3RlZEluZGV4KGluZGV4KSA/ICcgdW5zZWxlY3RlZCcgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxXaWR0aDogaXNIb3Jpem9udGFsTGVnZW5kID8gJzt3aWR0aDonICsgbGFiZWxzV2lkdGhbaW5kZXhdICsgJ3B4JyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBpY29uVHlwZTogbGVnZW5kRGF0dW0uY2hhcnRUeXBlIHx8ICdyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxlZ2VuZERhdHVtLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogY2hlY2tib3gsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGxlZ2VuZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVGFyZ2V0IHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBsZWdlbmQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRMZWdlbmRMYWJlbEVsZW1lbnQ6IGZ1bmN0aW9uKGVsVGFyZ2V0KSB7XG4gICAgICAgIHZhciBsZWdlbmRDb250YWluZXI7XG5cbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyhlbFRhcmdldCwgY2hhcnRDb25zdC5DTEFTU19OQU1FX0xFR0VORF9MQUJFTCkpIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbnRhaW5lciA9IGVsVGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnZW5kQ29udGFpbmVyID0gZG9tLmZpbmRQYXJlbnRCeUNsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfTEVHRU5EX0xBQkVMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZWdlbmRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgbGVnZW5kIGNoZWNrYm94IGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVMZWdlbmRDaGVja2JveEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2VDaGVja2VkTGVnZW5kcycsIHRoaXMubGVnZW5kTW9kZWwuZ2V0Q2hlY2tlZEluZGV4ZXMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgbGVnZW5kIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2NoYXJ0VHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfX0gZGF0YSBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUxlZ2VuZFNlbGVjdGlvbkV2ZW50OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBjaGFydFR5cGVzID0gdGhpcy5jaGFydFR5cGVzIHx8IFtkYXRhLmNoYXJ0VHlwZV0sXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMubGVnZW5kTW9kZWwuZ2V0U2VsZWN0ZWRJbmRleCgpLFxuICAgICAgICAgICAgbGVnZW5kSW5kZXggPSAhdHVpLnV0aWwuaXNOdWxsKGluZGV4KSA/IGRhdGEuc2VyaWVzSW5kZXggOiBpbmRleDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoY2hhcnRUeXBlcywgZnVuY3Rpb24oY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUocmVuZGVyVXRpbC5tYWtlQ3VzdG9tRXZlbnROYW1lKCdzZWxlY3QnLCBjaGFydFR5cGUsICdsZWdlbmQnKSwgZGF0YS5jaGFydFR5cGUsIGxlZ2VuZEluZGV4KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmUgdXNlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge3tsYWJlbDogc3RyaW5nLCBjaGFydFR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcn19IGRhdGEgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVVc2VyRXZlbnQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnc2VsZWN0TGVnZW5kJywge1xuICAgICAgICAgICAgbGVnZW5kOiBkYXRhLmxhYmVsLFxuICAgICAgICAgICAgY2hhcnRUeXBlOiBkYXRhLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGluZGV4OiBkYXRhLmluZGV4XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdExlZ2VuZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmxlZ2VuZE1vZGVsLmdldERhdHVtKGluZGV4KTtcblxuICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnRvZ2dsZVNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMubGVnZW5kTW9kZWwuZ2V0U2VsZWN0ZWRJbmRleCgpKSAmJiAhdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwuY2hlY2tTZWxlY3RlZEluZGV4KCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYSh0aGlzLmxlZ2VuZENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fZmlyZUxlZ2VuZFNlbGVjdGlvbkV2ZW50KGRhdGEpO1xuICAgICAgICB0aGlzLl9maXJlVXNlckV2ZW50KGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2hlY2tlZCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gY2hlY2tlZCBpbmRleGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q2hlY2tlZEluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tlZEluZGV4ZXMgPSBbXTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMubGVnZW5kQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLCBmdW5jdGlvbihjaGVja2JveCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hlY2tlZEluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGxlZ2VuZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja0xlZ2VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGVja2VkSW5kZXhlcyA9IHRoaXMuX2dldENoZWNrZWRJbmRleGVzKCksXG4gICAgICAgICAgICBjaGVja2VkQ291bnQgPSBjaGVja2VkSW5kZXhlcy5sZW5ndGgsXG4gICAgICAgICAgICBkYXRhO1xuXG4gICAgICAgIGlmICgocHJlZGljYXRlLmlzUGllQ2hhcnQodGhpcy5jaGFydFR5cGUpICYmIGNoZWNrZWRDb3VudCA9PT0gMSkgfHwgY2hlY2tlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMZWdlbmRBcmVhKHRoaXMubGVnZW5kQ29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVnZW5kTW9kZWwudXBkYXRlQ2hlY2tlZERhdGEoY2hlY2tlZEluZGV4ZXMpO1xuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5sZWdlbmRNb2RlbC5nZXRTZWxlY3RlZERhdHVtKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5sZWdlbmRNb2RlbC5pc0NoZWNrZWRTZWxlY3RlZEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZE1vZGVsLnVwZGF0ZVNlbGVjdGVkSW5kZXgobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9maXJlTGVnZW5kQ2hlY2tib3hFdmVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVMZWdlbmRTZWxlY3Rpb25FdmVudChkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljayBldmVudCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQ2xpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsVGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgbGVnZW5kQ29udGFpbmVyLCBpbmRleDtcblxuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfTEVHRU5EX0NIRUNLQk9YKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tMZWdlbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZ2VuZENvbnRhaW5lciA9IHRoaXMuX2ZpbmRMZWdlbmRMYWJlbEVsZW1lbnQoZWxUYXJnZXQpO1xuXG4gICAgICAgIGlmICghbGVnZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IHBhcnNlSW50KGxlZ2VuZENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApO1xuICAgICAgICB0aGlzLl9zZWxlY3RMZWdlbmQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggYnJvd3NlciBldmVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCB0YXJnZXQgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEV2ZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICBldmVudExpc3RlbmVyLmJpbmRFdmVudCgnY2xpY2snLCBlbCwgdHVpLnV0aWwuYmluZCh0aGlzLl9vbkNsaWNrLCB0aGlzKSk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihMZWdlbmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMZWdlbmREaW1lbnNpb25Nb2RlbCBpcyBsZWdlbmQgZGltZW5zaW9uIG1vZGVsLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBMZWdlbmREaW1lbnNpb25Nb2RlbCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTGVnZW5kRGltZW5zaW9uTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMZWdlbmREaW1lbnNpb25Nb2RlbCBpcyBsZWdlbmQgZGltZW5zaW9uIG1vZGVsLlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZERpbWVuc2lvbk1vZGVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgbGVnZW5kIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgbGVnZW5kIHRoZW1lXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXJhbXMubGVnZW5kTGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXG4gICAgICAgIHRoaXMudGhlbWUgPSBwYXJhbXMudGhlbWU7XG5cbiAgICAgICAgdGhpcy5sZWdlbmRMYWJlbHMgPSBwYXJhbXMubGVnZW5kTGFiZWxzO1xuXG4gICAgICAgIHRoaXMubGVnZW5kQ2hlY2tib3hXaWR0aCA9IHRoaXMub3B0aW9ucy5oYXNDaGVja2JveCA9PT0gZmFsc2UgPyAwIDogY2hhcnRDb25zdC5MRUdFTkRfQ0hFQ0tCT1hfV0lEVEg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGVnZW5kIHdpZHRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFdpZHRoIGxhYmVsIHdpZHRoXG4gICAgICogQHJldHVybnMge251bWJlcn0gbGVnZW5kIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUxlZ2VuZFdpZHRoOiBmdW5jdGlvbihsYWJlbFdpZHRoKSB7XG4gICAgICAgIHJldHVybiBsYWJlbFdpZHRoICsgdGhpcy5sZWdlbmRDaGVja2JveFdpZHRoICsgY2hhcnRDb25zdC5MRUdFTkRfUkVDVF9XSURUSCArXG4gICAgICAgICAgICBjaGFydENvbnN0LkxFR0VORF9MQUJFTF9MRUZUX1BBRERJTkcgKyBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdW0gb2YgbGVnZW5kcyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBsYWJlbHMgbGVnZW5kIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IG51bWJlcn19IGxhYmVsVGhlbWUgbGVnZW5kIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge251bWJlcn0gc3VtIG9mIHdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTGVnZW5kc1dpZHRoU3VtOiBmdW5jdGlvbihsYWJlbHMsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLnN1bSh0dWkudXRpbC5tYXAobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSB0aGlzLl9tYWtlTGVnZW5kV2lkdGgocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgobGFiZWwsIGxhYmVsVGhlbWUpKTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFdpZHRoO1xuICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSBsZWdlbmQgbGFiZWxzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGxhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IGRpdmlzaW9uIGNvdW50XG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48c3RyaW5nPj59IGRpdmlkZWQgbGFiZWxzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGl2aWRlTGVnZW5kTGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIGNvdW50KSB7XG4gICAgICAgIHZhciBsaW1pdENvdW50ID0gTWF0aC5yb3VuZChsYWJlbHMubGVuZ3RoIC8gY291bnQpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxuICAgICAgICAgICAgdGVtcCA9IFtdO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShsYWJlbHMsIGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICBpZiAodGVtcC5sZW5ndGggPCBsaW1pdENvdW50KSB7XG4gICAgICAgICAgICAgICAgdGVtcC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRlbXApO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBbbGFiZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGVtcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0ZW1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpdmlzaW9uIGxhYmVscyBhbmQgbWF4IGxpbmUgd2lkdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbGFiZWxzIGxlZ2VuZCBsYWJlbHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhcnRXaWR0aCBjaGFydCB3aWR0aFxuICAgICAqIEBwYXJhbSB7e2ZvbnRTaXplOiBudW1iZXIsIGZvbnRGYW1pbHk6IG51bWJlcn19IGxhYmVsVGhlbWUgbGVnZW5kIGxhYmVsIHRoZW1lXG4gICAgICogQHJldHVybnMge3tkaXZpZGVkTGFiZWxzOiBBcnJheS48QXJyYXkuPHN0cmluZz4+LCBtYXhMaW5lV2lkdGg6IG51bWJlcn19IHJlc3VsdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VEaXZpZGVkTGFiZWxzQW5kTWF4TGluZVdpZHRoOiBmdW5jdGlvbihsYWJlbHMsIGNoYXJ0V2lkdGgsIGxhYmVsVGhlbWUpIHtcbiAgICAgICAgdmFyIGRpdmlkZUNvdW50ID0gMSxcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IDAsXG4gICAgICAgICAgICBwcmV2TWF4V2lkdGggPSAwLFxuICAgICAgICAgICAgZGl2aWRlZExhYmVscywgbGluZVdpZHRocywgcHJldkxhYmVscztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaXZpZGVkTGFiZWxzID0gdGhpcy5fZGl2aWRlTGVnZW5kTGFiZWxzKGxhYmVscywgZGl2aWRlQ291bnQpO1xuICAgICAgICAgICAgbGluZVdpZHRocyA9IHR1aS51dGlsLm1hcChkaXZpZGVkTGFiZWxzLCBmdW5jdGlvbihfbGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUxlZ2VuZHNXaWR0aFN1bShfbGFiZWxzLCBsYWJlbFRoZW1lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgbGluZVdpZHRocyk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2TWF4V2lkdGggPT09IG1heExpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGRpdmlkZWRMYWJlbHMgPSBwcmV2TGFiZWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2TWF4V2lkdGggPSBtYXhMaW5lV2lkdGg7XG4gICAgICAgICAgICBwcmV2TGFiZWxzID0gZGl2aWRlZExhYmVscztcbiAgICAgICAgICAgIGRpdmlkZUNvdW50ICs9IDE7XG4gICAgICAgIH0gd2hpbGUgKG1heExpbmVXaWR0aCA+PSBjaGFydFdpZHRoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGl2aWRlZExhYmVsczogZGl2aWRlZExhYmVscyxcbiAgICAgICAgICAgIG1heExpbmVXaWR0aDogbWF4TGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgb2YgaG9yaXpvbnRhbCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSBkaXZpZGVkTGFiZWxzIGRpdmlkZWQgbGFiZWxzXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogbnVtYmVyfX0gbGFiZWxUaGVtZSBsZWdlbmQgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsZWdlbmQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlSG9yaXpvbnRhbExlZ2VuZEhlaWdodDogZnVuY3Rpb24oZGl2aWRlZExhYmVscywgbGFiZWxUaGVtZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwuc3VtKHR1aS51dGlsLm1hcChkaXZpZGVkTGFiZWxzLCBmdW5jdGlvbihsYWJlbHMpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxzTWF4SGVpZ2h0KGxhYmVscywgbGFiZWxUaGVtZSk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBkaW1lbnNpb24gb2YgaG9yaXpvbnRhbCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJ0V2lkdGggY2hhcnQgd2lkdGhcbiAgICAgKiBAcGFyYW0ge3tmb250U2l6ZTogbnVtYmVyLCBmb250RmFtaWx5OiBudW1iZXJ9fSBsYWJlbFRoZW1lIGxlZ2VuZCBsYWJlbCB0aGVtZVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiAobnVtYmVyKX19IGRpbWVuc2lvbiBvZiBob3Jpem9udGFsIGxlZ2VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsRGltZW5zaW9uOiBmdW5jdGlvbihjaGFydFdpZHRoKSB7XG4gICAgICAgIHZhciBsYWJlbHNBbmRNYXhXaWR0aCA9IHRoaXMuX21ha2VEaXZpZGVkTGFiZWxzQW5kTWF4TGluZVdpZHRoKHRoaXMubGVnZW5kTGFiZWxzLCBjaGFydFdpZHRoLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGxlZ2VuZEhlaWdodCA9IHRoaXMuX2NhbGN1bGF0ZUhvcml6b250YWxMZWdlbmRIZWlnaHQobGFiZWxzQW5kTWF4V2lkdGguZGl2aWRlZExhYmVscywgdGhpcy50aGVtZS5sYWJlbCkgKyAoY2hhcnRDb25zdC5MRUdFTkRfQVJFQV9QQURESU5HICogMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBsYWJlbHNBbmRNYXhXaWR0aC5tYXhMaW5lV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGxlZ2VuZEhlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRpbWVuc2lvbiBvZiB2ZXJ0aWNhbCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHt7Zm9udFNpemU6IG51bWJlciwgZm9udEZhbWlseTogbnVtYmVyfX0gbGFiZWxUaGVtZSBsZWdlbmQgbGFiZWwgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyKX19IGRpbWVuc2lvbiBvZiB2ZXJ0aWNhbCBsZWdlbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWF4TGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbHNNYXhXaWR0aCh0aGlzLmxlZ2VuZExhYmVscywgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMuX21ha2VMZWdlbmRXaWR0aChtYXhMYWJlbFdpZHRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBsZWdlbmRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHNraXBwZWQgbGVnZW5kIHNpemluZyBvciBub3QuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdCBib29sZWFuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNTa2lwTGVnZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChwcmVkaWNhdGUuaXNQaWVDaGFydCh0aGlzLmNoYXJ0VHlwZSkgJiYgcHJlZGljYXRlLmlzUGllTGVnZW5kQWxpZ24odGhpcy5vcHRpb25zLmFsaWduKSkgfHwgdGhpcy5vcHRpb25zLmhpZGRlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBsZWdlbmQgZGltZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFydFdpZHRoIGNoYXJ0IHdpZHRoXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGxlZ2VuZCBkaW1lbnRpb25cbiAgICAgKi9cbiAgICBtYWtlRGltZW5zaW9uOiBmdW5jdGlvbihjaGFydFdpZHRoKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5faXNTa2lwTGVnZW5kKCkpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbi53aWR0aCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pKSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlSG9yaXpvbnRhbERpbWVuc2lvbihjaGFydFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VWZXJ0aWNhbERpbWVuc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmREaW1lbnNpb25Nb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBMZWdlbmRNb2RlbCBpcyBsZWdlbmQgbW9kZWwuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyk7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG52YXIgTGVnZW5kTW9kZWwgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIExlZ2VuZE1vZGVsLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTGVnZW5kTW9kZWwgaXMgbGVnZW5kIG1vZGVsLlxuICAgICAqIEBjb25zdHJ1Y3RzIExlZ2VuZE1vZGVsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmxhYmVscyBsZWdlbmQgbGFiZWxzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmJvdW5kIGF4aXMgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgbGFiZWxzXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPiB8IHtjb2x1bW46ID9BcnJheS48c3RyaW5nPiwgbGluZTogP0FycmF5LjxzdHJpbmc+fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFiZWxzID0gcGFyYW1zLmxhYmVscztcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGFiZWwgaW5mb3NcbiAgICAgICAgICogQHR5cGUge0FycmF5Ljx7Y2hhcnRUeXBlOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kRGF0YSA9IHBhcmFtcy5sZWdlbmREYXRhO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFydCB0eXBlc1xuICAgICAgICAgKiBAdHlwZSB7P0FycmF5LjxzdHJpbmc+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGVzID0gcGFyYW1zLmNoYXJ0VHlwZXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IHR5cGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhcnRUeXBlID0gcGFyYW1zLmNoYXJ0VHlwZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVnZW5kIGRhdGFcbiAgICAgICAgICogQHR5cGUgez9BcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdGVkIGxlZ2VuZCBpbmRleC5cbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZW5kaW5nIGRhdGEgdG8gc2VyaWVzXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRJbmRleGVzTWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrZWQgaW5kZXhlc1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrZWRXaG9sZUluZGV4ZXMgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbml0Q2hlY2tlZEluZGV4ZXMoKTtcbiAgICAgICAgdGhpcy5fc2V0RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGNoZWNrZWQgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0Q2hlY2tlZEluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hlY2tlZFdob2xlSW5kZXhlcyA9IFtdO1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5sZWdlbmREYXRhLCBmdW5jdGlvbihsZWdlbmREYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNoZWNrZWRXaG9sZUluZGV4ZXNbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hlY2tlZFdob2xlSW5kZXhlcyA9IGNoZWNrZWRXaG9sZUluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbGFiZWwgaW5mbyB0aGF0IGFwcGxpZWQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gbGFiZWxJbmZvIGxhYmVsc1xuICAgICAqIEBwYXJhbSB7e2NvbG9yczogQXJyYXkuPG51bWJlcj4sIHNpbmdsZUNvbG9yOiA/c3RyaW5nLCBib3JkZXJjb2xvcjogP3N0cmluZ319IHRoZW1lIGxlZ2VuZCB0aGVtZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBjaGVja2VkSW5kZXhlcyBjaGVja2VkIGluZGV4ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IGxhYmVsc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbEluZm9BcHBsaWVkVGhlbWU6IGZ1bmN0aW9uKGxhYmVsSW5mbywgdGhlbWUsIGNoZWNrZWRJbmRleGVzKSB7XG4gICAgICAgIHZhciBzZXJpZXNJbmRleCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChsYWJlbEluZm8sIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaXRlbVRoZW1lID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5jb2xvcnNbaW5kZXhdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhlbWUuc2luZ2xlQ29sb3JzKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRoZW1lLnNpbmdsZUNvbG9yID0gdGhlbWUuc2luZ2xlQ29sb3JzW2luZGV4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoZW1lLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaXRlbVRoZW1lLmJvcmRlckNvbG9yID0gdGhlbWUuYm9yZGVyQ29sb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW0udGhlbWUgPSBpdGVtVGhlbWU7XG4gICAgICAgICAgICBpdGVtLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgIGlmICghY2hlY2tlZEluZGV4ZXMgfHwgIXR1aS51dGlsLmlzVW5kZWZpbmVkKGNoZWNrZWRJbmRleGVzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlcmllc0luZGV4ID0gc2VyaWVzSW5kZXg7XG4gICAgICAgICAgICAgICAgc2VyaWVzSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZXJpZXNJbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBsZWdlbmQgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlZ2VuZERhdGEgPSB0aGlzLmxlZ2VuZERhdGEsXG4gICAgICAgICAgICBkYXRhLCBkZWZhdWx0TGVnZW5kVGhlbWUsIHN0YXJ0SW5kZXgsIHN0YXJ0VGhlbWVJbmRleDtcblxuICAgICAgICBpZiAoIXRoaXMuY2hhcnRUeXBlcykge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX21ha2VMYWJlbEluZm9BcHBsaWVkVGhlbWUobGVnZW5kRGF0YSwgdGhpcy50aGVtZSwgdGhpcy5jaGVja2VkSW5kZXhlc01hcFt0aGlzLmNoYXJ0VHlwZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICBzdGFydFRoZW1lSW5kZXggPSAwO1xuICAgICAgICAgICAgZGVmYXVsdExlZ2VuZFRoZW1lID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yczogZGVmYXVsdFRoZW1lLnNlcmllcy5jb2xvcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkYXRhID0gY29uY2F0LmFwcGx5KFtdLCB0dWkudXRpbC5tYXAodGhpcy5jaGFydFR5cGVzLCBmdW5jdGlvbihjaGFydFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnRUaGVtZSA9IHRoaXMudGhlbWVbY2hhcnRUeXBlXSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxMZW4gPSB0aGlzLmxhYmVsc1tjaGFydFR5cGVdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGFiZWxMZW4sXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lRW5kSW5kZXgsIGRhdHVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjaGFydFRoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZW1lRW5kSW5kZXggPSBzdGFydFRoZW1lSW5kZXggKyBsYWJlbExlbjtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRUaGVtZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmYXVsdExlZ2VuZFRoZW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VGhlbWUuY29sb3JzID0gY2hhcnRUaGVtZS5jb2xvcnMuc2xpY2Uoc3RhcnRUaGVtZUluZGV4LCB0aGVtZUVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaGVtZUluZGV4ID0gdGhlbWVFbmRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXR1bSA9IHRoaXMuX21ha2VMYWJlbEluZm9BcHBsaWVkVGhlbWUobGVnZW5kRGF0YS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCksIGNoYXJ0VGhlbWUsIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbY2hhcnRUeXBlXSk7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXR1bTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBsZWdlbmQgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZywgdGhlbWU6IG9iamVjdH0+fSBsZWdlbmQgZGF0YVxuICAgICAqL1xuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGVnZW5kIGRhdHVtIGJ5IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2NoYXJ0VHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCB0aGVtZTogb2JqZWN0fX0gbGVnZW5kIGRhdHVtXG4gICAgICovXG4gICAgZ2V0RGF0dW06IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0ZWQgZGF0dW0uXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGFiZWw6IHN0cmluZywgdGhlbWU6IE9iamVjdH19IGxlZ2VuZCBkYXR1bVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkRGF0dW06IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXR1bSh0aGlzLnNlbGVjdGVkSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2VsZWN0ZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZVNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgc2VsZWN0ZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWxlY3RlZEluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdGVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHNlbGVjdGVkIGluZGV4XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdW5zZWxlY3RlZCBpbmRleCBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNVbnNlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiAhdHVpLnV0aWwuaXNOdWxsKHRoaXMuc2VsZWN0ZWRJbmRleCkgJiYgKHRoaXMuc2VsZWN0ZWRJbmRleCAhPT0gaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoZWNrZWQgc2VsZWN0ZWQgaW5kZXggb3Igbm90LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGNoZWNrZWRcbiAgICAgKi9cbiAgICBpc0NoZWNrZWRTZWxlY3RlZEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVja2VkSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoZWNrZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUNoZWNrZWRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkV2hvbGVJbmRleGVzW2luZGV4XSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hlY2tlZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbGVnZW5kIGluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgY2hlY2tlZFxuICAgICAqL1xuICAgIGlzQ2hlY2tlZEluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNoZWNrZWRXaG9sZUluZGV4ZXNbaW5kZXhdO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBzZW5kaW5nIGRhdHVtLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBfYWRkU2VuZGluZ0RhdHVtOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgbGVnZW5kRGF0dW0gPSB0aGlzLmdldERhdHVtKGluZGV4KTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrZWRJbmRleGVzTWFwW2xlZ2VuZERhdHVtLmNoYXJ0VHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbbGVnZW5kRGF0dW0uY2hhcnRUeXBlXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbbGVnZW5kRGF0dW0uY2hhcnRUeXBlXVtsZWdlbmREYXR1bS5pbmRleF0gPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzZWxlY3RlZCBpbmRleDtcbiAgICAgKi9cbiAgICBjaGVja1NlbGVjdGVkSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDaGVja2VkSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgdGhpcy5fYWRkU2VuZGluZ0RhdHVtKHRoaXMuc2VsZWN0ZWRJbmRleCk7XG4gICAgICAgIHRoaXMuX3NldERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNoZWNrZWQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7e2NvbHVtbjogP0FycmF5Ljxib29sZWFuPiwgbGluZTogP0FycmF5Ljxib29sZWFuPn0gfCBBcnJheS48Ym9vbGVhbj59IHNlbmRpbmcgZGF0YVxuICAgICAqL1xuICAgIGdldENoZWNrZWRJbmRleGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXBbdGhpcy5jaGFydFR5cGVdIHx8IHRoaXMuY2hlY2tlZEluZGV4ZXNNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IGNoZWNrZWQgZGF0YS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldENoZWNrZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkV2hvbGVJbmRleGVzID0gW107XG4gICAgICAgIHRoaXMuY2hlY2tlZEluZGV4ZXNNYXAgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNoZWNrZWQgZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbmRleGVzIGluZHhlc1xuICAgICAqL1xuICAgIHVwZGF0ZUNoZWNrZWREYXRhOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q2hlY2tlZERhdGEoKTtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDaGVja2VkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VuZGluZ0RhdHVtKGluZGV4KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3NldERhdGEoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdlbmRNb2RlbDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBUaGlzIGlzIHRlbXBsYXRlcyBvZiBsZWdlbmQgdmlldy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIGh0bWxzID0ge1xuICAgIEhUTUxfQ0hFQ0tCT1g6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1jaGVja2JveC1hcmVhXCI+PGlucHV0IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwie3sgaW5kZXggfX1cInt7IGNoZWNrZWQgfX0gLz48L2Rpdj4nLFxuICAgIEhUTUxfTEVHRU5EOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1sZWdlbmR7eyB1bnNlbGVjdGVkIH19XCIgc3R5bGU9XCJoZWlnaHQ6e3sgaGVpZ2h0IH19cHhcIj4nICtcbiAgICAgICAgJ3t7IGNoZWNrYm94IH19PGRpdiBjbGFzcz1cInR1aS1jaGFydC1sZWdlbmQtcmVjdCB7eyBpY29uVHlwZSB9fVwiIHN0eWxlPVwie3sgcmVjdENzc1RleHQgfX1cIj48L2Rpdj4nICtcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtbGVnZW5kLWxhYmVsXCIgc3R5bGU9XCJoZWlnaHQ6e3sgbGFiZWxIZWlnaHQgfX1weHt7IGxhYmVsV2lkdGggfX1cIiBkYXRhLWluZGV4PVwie3sgaW5kZXggfX1cIj57eyBsYWJlbCB9fTwvZGl2PjwvZGl2PicsXG4gICAgSFRNTF9USUNLOiAnPGRpdiBjbGFzcz1cInR1aS1jaGFydC1tYXAtbGVnZW5kLXRpY2tcIiBzdHlsZT1cInt7IHBvc2l0aW9uIH19XCI+PC9kaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LW1hcC1sZWdlbmQtdGljay1sYWJlbFwiIHN0eWxlPVwie3sgbGFiZWxQb3NpdGlvbiB9fVwiPnt7IGxhYmVsIH19PC9kaXY+J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdHBsQ2hlY2tib3g6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9DSEVDS0JPWCksXG4gICAgdHBsTGVnZW5kOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfTEVHRU5EKSxcbiAgICB0cGxUaWNrOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfVElDSylcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgIExlZ2VuZCBjb21wb25lbnQgZm9yIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpLFxuICAgIGxlZ2VuZFRlbXBsYXRlID0gcmVxdWlyZSgnLi8uLi9sZWdlbmRzL2xlZ2VuZFRlbXBsYXRlJyk7XG5cbnZhciBNYXBDaGFydExlZ2VuZCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTWFwQ2hhcnRMZWdlbmQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMZWdlbmQgY29tcG9uZW50IGZvciBtYXAgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRMZWdlbmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHs/QXJyYXkuPHN0cmluZz59IHBhcmFtcy5vcHRpb25zIGxlZ2VuZCBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge01hcENoYXJ0RGF0YVByb2Nlc3Nvcn0gcGFyYW1zLmRhdGFQcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3JcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxpYlR5cGUgPSBwYXJhbXMubGliVHlwZSB8fCBjaGFydENvbnN0LkRFRkFVTFRfUExVR0lOO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzcyBuYW1lLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LWxlZ2VuZC1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogbGVnZW5kIHRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoZW1lID0gcGFyYW1zLnRoZW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogZGF0YSBwcm9jZXNzb3JcbiAgICAgICAgICogQHR5cGUge0RhdGFQcm9jZXNzb3J9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFQcm9jZXNzb3IgPSBwYXJhbXMuZGF0YVByb2Nlc3NvcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoIHJlbmRlcmVyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIgPSBwbHVnaW5GYWN0b3J5LmdldChsaWJUeXBlLCAnbWFwTGVnZW5kJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgb3Igbm90LlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gcHJlZGljYXRlLmlzSG9yaXpvbnRhbExlZ2VuZCh0aGlzLm9wdGlvbnMuYWxpZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHZlcnRpY2FsIGxlZ2VuZCBkaW1lbnNpb24uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWZXJ0aWNhbERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRWYWx1ZXMoKSksXG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCksXG4gICAgICAgICAgICB2YWx1ZVN0ciA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUobWF4VmFsdWUsIGZvcm1hdEZ1bmN0aW9ucyksXG4gICAgICAgICAgICBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgodmFsdWVTdHIsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgcGFkZGluZyA9IGNoYXJ0Q29uc3QuTEVHRU5EX0FSRUFfUEFERElORyArIGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9MQUJFTF9QQURESU5HO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogIGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9HUkFQSF9TSVpFICsgbGFiZWxXaWR0aCArIHBhZGRpbmcsXG4gICAgICAgICAgICBoZWlnaHQ6IGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9TSVpFXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCBsZWdlbmQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlcygpKSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KG1heFZhbHVlLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBjaGFydENvbnN0LkxFR0VORF9BUkVBX1BBRERJTkcgKyBjaGFydENvbnN0Lk1BUF9MRUdFTkRfTEFCRUxfUEFERElORztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6ICBjaGFydENvbnN0Lk1BUF9MRUdFTkRfU0laRSxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkUgKyBsYWJlbEhlaWdodCArIHBhZGRpbmdcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZGltZW5zaW9uLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbjtcblxuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoaXMuX21ha2VIb3Jpem9udGFsRGltZW5zaW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSB0aGlzLl9tYWtlVmVydGljYWxEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIucmVnaXN0ZXJCYXNlRGltZW5zaW9uKCdsZWdlbmQnLCBkaW1lbnNpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgZGF0YSB0byBtYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7e3N0YXJ0UG9zaXRpb25WYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIsIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBsYWJlbFNpemU6ID9udW1iZXJ9fSBiYXNlIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQmFzZURhdGFUb01ha2VUaWNrSHRtbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignbGVnZW5kJyksXG4gICAgICAgICAgICBzdGVwQ291bnQgPSB0aGlzLmF4ZXNEYXRhLnRpY2tDb3VudCAtIDEsXG4gICAgICAgICAgICBiYXNlRGF0YSA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgYmFzZURhdGEuc3RhcnRQb3NpdGlvblZhbHVlID0gNTtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0ZXAgPSBkaW1lbnNpb24ud2lkdGggLyBzdGVwQ291bnQ7XG4gICAgICAgICAgICBiYXNlRGF0YS5wb3NpdGlvblR5cGUgPSAnbGVmdDonO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZURhdGEuc3RhcnRQb3NpdGlvblZhbHVlID0gMDtcbiAgICAgICAgICAgIGJhc2VEYXRhLnN0ZXAgPSBkaW1lbnNpb24uaGVpZ2h0IC8gc3RlcENvdW50O1xuICAgICAgICAgICAgYmFzZURhdGEucG9zaXRpb25UeXBlID0gJ3RvcDonO1xuICAgICAgICAgICAgYmFzZURhdGEubGFiZWxTaXplID0gcGFyc2VJbnQocmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KHRoaXMuYXhlc0RhdGEubGFiZWxzWzBdLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIsIDEwKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmFzZURhdGE7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYWtlIHRpY2sgaHRtbC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aWNrIGh0bWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRpY2tIdG1sOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2VEYXRhID0gdGhpcy5fbWFrZUJhc2VEYXRhVG9NYWtlVGlja0h0bWwoKSxcbiAgICAgICAgICAgIHBvc2l0aW9uVmFsdWUgPSBiYXNlRGF0YS5zdGFydFBvc2l0aW9uVmFsdWUsXG4gICAgICAgICAgICBodG1scztcblxuICAgICAgICBodG1scyA9IHR1aS51dGlsLm1hcCh0aGlzLmF4ZXNEYXRhLmxhYmVscywgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbFNpemUsIGh0bWw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGxhYmVsU2l6ZSA9IHBhcnNlSW50KHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIsIDEwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWxTaXplID0gYmFzZURhdGEubGFiZWxTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodG1sID0gbGVnZW5kVGVtcGxhdGUudHBsVGljayh7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGJhc2VEYXRhLnBvc2l0aW9uVHlwZSArIHBvc2l0aW9uVmFsdWUgKyAncHgnLFxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IGJhc2VEYXRhLnBvc2l0aW9uVHlwZSArIChwb3NpdGlvblZhbHVlIC0gbGFiZWxTaXplKSArICdweCcsXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcG9zaXRpb25WYWx1ZSArPSBiYXNlRGF0YS5zdGVwO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRpY2sgYXJlYS5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRpY2sgY291bnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclRpY2tBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRpY2tDb250YWluZXIgPSBkb20uY3JlYXRlKCdkaXYnLCAndHVpLWNoYXJ0LWxlZ2VuZC10aWNrLWFyZWEnKTtcblxuICAgICAgICB0aWNrQ29udGFpbmVyLmlubmVySFRNTCA9IHRoaXMuX21ha2VUaWNrSHRtbCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRpY2tDb250YWluZXIsICdob3Jpem9udGFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZ3JhcGggZGltZW5zaW9uIG9mIHZlcnRpY2FsIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxHcmFwaERpbWVuc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkUsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdsZWdlbmQnKS5oZWlnaHRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGdyYXBoIGRpbWVuc2lvbiBvZiBob3Jpem9udGFsIGxlZ2VuZFxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbEdyYXBoRGltZW5zaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignbGVnZW5kJykud2lkdGggKyAxMCxcbiAgICAgICAgICAgIGhlaWdodDogY2hhcnRDb25zdC5NQVBfTEVHRU5EX0dSQVBIX1NJWkVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZ3JhcGguXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgZGltZW5zaW9uO1xuXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5fbWFrZUhvcml6b250YWxHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGltZW5zaW9uID0gdGhpcy5fbWFrZVZlcnRpY2FsR3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZW5kZXIoY29udGFpbmVyLCBkaW1lbnNpb24sIHRoaXMuY29sb3JNb2RlbCwgdGhpcy5pc0hvcml6b250YWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbGVnZW5kIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGxlZ2VuZCBjb250YWluZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMZWdlbmRBcmVhOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIHRpY2tDb250YWluZXI7XG5cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGNvbnRhaW5lciwgdGhpcy5ib3VuZHNNYWtlci5nZXRQb3NpdGlvbignbGVnZW5kJykpO1xuICAgICAgICB0aGlzLl9yZW5kZXJHcmFwaChjb250YWluZXIpO1xuICAgICAgICB0aWNrQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyVGlja0FyZWEoKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpY2tDb250YWluZXIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCArPSAnOycgKyByZW5kZXJVdGlsLm1ha2VGb250Q3NzVGV4dCh0aGlzLnRoZW1lLmxhYmVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHt7Y29sb3JNb2RlbDogTWFwQ2hhcnRDb2xvck1vZGVsLCBheGVzRGF0YTogb2JqZWN0fX0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gbGVnZW5kIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmxlZ2VuZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb2xvck1vZGVsID0gZGF0YS5jb2xvck1vZGVsO1xuICAgICAgICB0aGlzLmF4ZXNEYXRhID0gZGF0YS5heGVzRGF0YTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGVnZW5kQXJlYShjb250YWluZXIpO1xuXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBsZWdlbmQgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZEFyZWEodGhpcy5sZWdlbmRDb250YWluZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBzaG93IHdlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYXRpbyByYXRpb1xuICAgICAqL1xuICAgIG9uU2hvd1dlZGdlOiBmdW5jdGlvbihyYXRpbykge1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd1dlZGdlKGNoYXJ0Q29uc3QuTUFQX0xFR0VORF9TSVpFICogcmF0aW8pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBoaWRlIHdlZGdlLlxuICAgICAqL1xuICAgIG9uSGlkZVdlZGdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVXZWRnZSgpO1xuICAgIH1cbn0pO1xuXG50dWkudXRpbC5DdXN0b21FdmVudHMubWl4aW4oTWFwQ2hhcnRMZWdlbmQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0TGVnZW5kO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFBsb3QgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsY3VsYXRvcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBwbG90VGVtcGxhdGUgPSByZXF1aXJlKCcuL3Bsb3RUZW1wbGF0ZScpO1xuXG52YXIgUGxvdCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUGxvdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFBsb3QgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFBsb3RcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudlRpY2tDb3VudCB2ZXJ0aWNhbCB0aWNrIGNvdW50XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmhUaWNrQ291bnQgaG9yaXpvbnRhbCB0aWNrIGNvdW50XG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbG90IHZpZXcgY2xhc3NOYW1lXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtcGxvdC1hcmVhJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHBsb3QgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwbG90Q29udGFpbmVyIHBsb3QgYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQbG90QXJlYTogZnVuY3Rpb24ocGxvdENvbnRhaW5lciwgZGF0YSkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3Bsb3QnKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihwbG90Q29udGFpbmVyLCBkaW1lbnNpb24pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHBsb3RDb250YWluZXIsIHRoaXMuYm91bmRzTWFrZXIuZ2V0UG9zaXRpb24oJ3Bsb3QnKSk7XG4gICAgICAgIHRoaXMuX3JlbmRlckxpbmVzKHBsb3RDb250YWluZXIsIGRpbWVuc2lvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwbG90IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gcGxvdCBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUGxvdEFyZWEoZWwsIGRhdGEpO1xuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIgPSBlbDtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnBsb3RDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMuX3JlbmRlclBsb3RBcmVhKHRoaXMucGxvdENvbnRhaW5lciwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBwbG90IGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSByZW5kZXJpbmcgZGF0YVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnJlcmVuZGVyKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcGxvdCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gcGxvdCBhcmVhIGRpbWVuc2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlckxpbmVzOiBmdW5jdGlvbihlbCwgZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBoUG9zaXRpb25zID0gdGhpcy5fbWFrZUhvcml6b250YWxQaXhlbFBvc2l0aW9ucyhkaW1lbnNpb24ud2lkdGgpLFxuICAgICAgICAgICAgdlBvc2l0aW9ucyA9IHRoaXMuX21ha2VWZXJ0aWNhbFBpeGVsUG9zaXRpb25zKGRpbWVuc2lvbi5oZWlnaHQpLFxuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLnRoZW1lLFxuICAgICAgICAgICAgbGluZUh0bWwgPSAnJztcblxuICAgICAgICBsaW5lSHRtbCArPSB0aGlzLl9tYWtlTGluZUh0bWwoe1xuICAgICAgICAgICAgcG9zaXRpb25zOiBoUG9zaXRpb25zLFxuICAgICAgICAgICAgc2l6ZTogZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2xlZnQnLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICdoZWlnaHQnLFxuICAgICAgICAgICAgbGluZUNvbG9yOiB0aGVtZS5saW5lQ29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmVIdG1sICs9IHRoaXMuX21ha2VMaW5lSHRtbCh7XG4gICAgICAgICAgICBwb3NpdGlvbnM6IHZQb3NpdGlvbnMsXG4gICAgICAgICAgICBzaXplOiBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2JvdHRvbScsXG4gICAgICAgICAgICBzaXplVHlwZTogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogdGhlbWUubGluZUNvbG9yXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsLmlubmVySFRNTCA9IGxpbmVIdG1sO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyQmFja2dyb3VuZChlbCwgdGhlbWUuYmFja2dyb3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBvZiBwbG90IGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBwYXJhbXMucG9zaXRpb25zIHBvc2l0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jbGFzc05hbWUgbGluZSBjbGFzc05hbWVcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgYm90dG9tKVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zaXplVHlwZSBzaXplIHR5cGUgKHNpemUgb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5saW5lQ29sb3IgbGluZSBjb2xvclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTGluZUh0bWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSBwbG90VGVtcGxhdGUudHBsUGxvdExpbmUsXG4gICAgICAgICAgICBsaW5lSHRtbCA9IHR1aS51dGlsLm1hcChwYXJhbXMucG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBjc3NUZXh0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclV0aWwuY29uY2F0U3RyKHBhcmFtcy5wb3NpdGlvblR5cGUsICc6JywgcG9zaXRpb24sICdweCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVXRpbC5jb25jYXRTdHIocGFyYW1zLnNpemVUeXBlLCAnOicsIHBhcmFtcy5zaXplLCAncHgnKVxuICAgICAgICAgICAgICAgICAgICBdLCBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5saW5lQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzVGV4dHMucHVzaChyZW5kZXJVdGlsLmNvbmNhdFN0cignYmFja2dyb3VuZC1jb2xvcjonLCBwYXJhbXMubGluZUNvbG9yKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IHtjbGFzc05hbWU6IHBhcmFtcy5jbGFzc05hbWUsIGNzc1RleHQ6IGNzc1RleHRzLmpvaW4oJzsnKX07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKGRhdGEpO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG4gICAgICAgIHJldHVybiBsaW5lSHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwaXhlbCB2YWx1ZSBvZiB2ZXJ0aWNhbCBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHBsb3QgaGVpZ2h0XG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxQaXhlbFBvc2l0aW9uczogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBjYWxjdWxhdG9yLm1ha2VUaWNrUGl4ZWxQb3NpdGlvbnMoaGVpZ2h0LCB0aGlzLmRhdGEudlRpY2tDb3VudCk7XG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBpeGVsIHZhbHVlIG9mIGhvcml6b250YWwgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBwbG90IHdpZHRoXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFBpeGVsUG9zaXRpb25zOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb25zID0gY2FsY3VsYXRvci5tYWtlVGlja1BpeGVsUG9zaXRpb25zKHdpZHRoLCB0aGlzLmRhdGEuaFRpY2tDb3VudCk7XG4gICAgICAgIHBvc2l0aW9ucy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3Q7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2YgcGxvdCB2aWV3IC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIHRhZ3MgPSB7XG4gICAgSFRNTF9QTE9UX0xJTkU6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LXBsb3QtbGluZSB7eyBjbGFzc05hbWUgfX1cIiBzdHlsZT1cInt7IGNzc1RleHQgfX1cIj48L2Rpdj4nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cGxQbG90TGluZTogdGVtcGxhdGVNYWtlci50ZW1wbGF0ZSh0YWdzLkhUTUxfUExPVF9MSU5FKVxufTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsIHJlbmRlciBwbHVnaW4uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBCYXJDaGFydCA9IHJlcXVpcmUoJy4vcmFwaGFlbEJhckNoYXJ0JyksXG4gICAgTGluZUNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsTGluZUNoYXJ0JyksXG4gICAgQXJlYUNoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsQXJlYUNoYXJ0JyksXG4gICAgUGllQ2hhcnQgPSByZXF1aXJlKCcuL3JhcGhhZWxQaWVDaGFydCcpLFxuICAgIE1hcENoYXJ0ID0gcmVxdWlyZSgnLi9yYXBoYWVsTWFwQ2hhcnQnKSxcbiAgICBNYXBMZWdlbmQgPSByZXF1aXJlKCcuL3JhcGhhZWxNYXBMZWdlbmQnKTtcblxudmFyIHBsdWdpbk5hbWUgPSAncmFwaGFlbCcsXG4gICAgcGx1Z2luUmFwaGFlbDtcblxucGx1Z2luUmFwaGFlbCA9IHtcbiAgICBiYXI6IEJhckNoYXJ0LFxuICAgIGNvbHVtbjogQmFyQ2hhcnQsXG4gICAgbGluZTogTGluZUNoYXJ0LFxuICAgIGFyZWE6IEFyZWFDaGFydCxcbiAgICBwaWU6IFBpZUNoYXJ0LFxuICAgIG1hcDogTWFwQ2hhcnQsXG4gICAgbWFwTGVnZW5kOiBNYXBMZWdlbmRcbn07XG5cbnR1aS5jaGFydC5yZWdpc3RlclBsdWdpbihwbHVnaW5OYW1lLCBwbHVnaW5SYXBoYWVsKTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsIGFyZWEgY2hhcnQgcmVuZGVyZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSYXBoYWVsTGluZUJhc2UgPSByZXF1aXJlKCcuL3JhcGhhZWxMaW5lVHlwZUJhc2UnKSxcbiAgICByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbCxcbiAgICBFTVBIQVNJU19PUEFDSVRZID0gMSxcbiAgICBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xuXG52YXIgY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcblxudmFyIFJhcGhhZWxBcmVhQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhSYXBoYWVsTGluZUJhc2UsIC8qKiBAbGVuZHMgUmFwaGFlbEFyZWFDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJhcGhhZWxBcmVhQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGFyZWEgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUmFwaGFlbEFyZWFDaGFydFxuICAgICAqIEBleHRlbmRzIFJhcGhhZWxMaW5lVHlwZUJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdGVkIGxlZ2VuZCBpbmRleFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tncm91cFBvc2l0aW9uczogQXJyYXkuPEFycmF5PiwgZGltZW5zaW9uOiBvYmplY3QsIHRoZW1lOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IGRhdGEgcmVuZGVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhlbWUgPSBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgY29sb3JzID0gdGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5oYXNEb3QgPyAxIDogMCxcbiAgICAgICAgICAgIGJvcmRlclN0eWxlID0gdGhpcy5tYWtlQm9yZGVyU3R5bGUodGhlbWUuYm9yZGVyQ29sb3IsIG9wYWNpdHkpLFxuICAgICAgICAgICAgb3V0RG90U3R5bGUgPSB0aGlzLm1ha2VPdXREb3RTdHlsZShvcGFjaXR5LCBib3JkZXJTdHlsZSksXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgMSwgZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHRoaXMuc3RhY2tlZE9wdGlvbiA9IGRhdGEub3B0aW9ucy5zdGFja2VkO1xuICAgICAgICB0aGlzLnNwbGluZSA9IGRhdGEub3B0aW9ucy5zcGxpbmU7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xuICAgICAgICB0aGlzLnplcm9Ub3AgPSBkYXRhLnplcm9Ub3A7XG5cbiAgICAgICAgdGhpcy5ncm91cFBhdGhzID0gZGF0YS5vcHRpb25zLnNwbGluZSA/IHRoaXMuX2dldFNwbGluZUFyZWFzUGF0aChncm91cFBvc2l0aW9ucykgOiB0aGlzLl9nZXRBcmVhc1BhdGgoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLmdyb3VwQXJlYXMgPSB0aGlzLl9yZW5kZXJBcmVhcyhwYXBlciwgdGhpcy5ncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lID0gdGhpcy5fcmVuZGVyVG9vbHRpcExpbmUocGFwZXIsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLmdyb3VwRG90cyA9IHRoaXMuX3JlbmRlckRvdHMocGFwZXIsIGdyb3VwUG9zaXRpb25zLCBjb2xvcnMsIG9wYWNpdHkpO1xuXG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHRoaXMuX21ha2VTZWxlY3Rpb25Eb3QocGFwZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IHRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXREb3RTdHlsZSA9IG91dERvdFN0eWxlO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZG90T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBpdm90R3JvdXBEb3RzO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFyZWEgZ3JhcGhzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciBwYXBlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGdyb3VwUGF0aHMgZ3JvdXAgcGF0aHNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgY29sb3JzXG4gICAgICogQHJldHVybnMge0FycmF5fSByYXBoYWVsIG9iamVjdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJBcmVhczogZnVuY3Rpb24ocGFwZXIsIGdyb3VwUGF0aHMsIGNvbG9ycykge1xuICAgICAgICB2YXIgZ3JvdXBBcmVhcztcblxuICAgICAgICBjb2xvcnMgPSBjb2xvcnMuc2xpY2UoMCwgZ3JvdXBQYXRocy5sZW5ndGgpO1xuICAgICAgICBjb2xvcnMucmV2ZXJzZSgpO1xuICAgICAgICBncm91cFBhdGhzLnJldmVyc2UoKTtcblxuICAgICAgICBncm91cEFyZWFzID0gdHVpLnV0aWwubWFwKGdyb3VwUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhQ29sb3IgPSBjb2xvcnNbZ3JvdXBJbmRleF0gfHwgJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICBsaW5lQ29sb3IgPSBhcmVhQ29sb3I7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXJlYTogcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyQXJlYShwYXBlciwgcGF0aC5hcmVhLmpvaW4oJyAnKSwgYXJlYUNvbG9yLCAwLjUsIGFyZWFDb2xvciksXG4gICAgICAgICAgICAgICAgbGluZTogcmFwaGFlbFJlbmRlclV0aWwucmVuZGVyTGluZShwYXBlciwgcGF0aC5saW5lLmpvaW4oJyAnKSwgbGluZUNvbG9yKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwQXJlYXMucmV2ZXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFRvcCBzdGFydCB0b3BcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSGVpZ2h0OiBmdW5jdGlvbih0b3AsIHN0YXJ0VG9wKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0b3AgLSBzdGFydFRvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYXJlYXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUFyZWFzUGF0aDogZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBsZW4gPSBwb3NpdGlvbnMubGVuZ3RoICogMixcbiAgICAgICAgICAgIHBhdGggPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgIHBhdGhbaW5kZXhdID0gWydMJywgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wXTtcbiAgICAgICAgICAgIHBhdGhbbGVuIC0gaW5kZXggLSAxXSA9IFsnTCcsIHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnN0YXJ0VG9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGF0aCA9IGNvbmNhdC5hcHBseShbXSwgcGF0aCk7XG4gICAgICAgIHBhdGhbMF0gPSAnTSc7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhcmVhIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHthcmVhOiBBcnJheS48c3RyaW5nIHwgbnVtYmVyPiwgbGluZTogQXJyYXkuPHN0cmluZyB8IG51bWJlcj59Pn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEFyZWFzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNbMF0ubGVmdCAtPSAxO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFyZWE6IHRoaXMuX21ha2VBcmVhc1BhdGgocG9zaXRpb25zKSxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLl9tYWtlTGluZXNQYXRoKHBvc2l0aW9ucylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNwbGluZSBhcmVhIGJvdHRvbSBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT59IHBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0+fSBwcmV2UG9zaXRpb25zIHByZXZpb3VzIHBvc2l0aW9uc1xuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nIHwgbnVtYmVyPn0gc3BsaW5lIGFyZWEgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTcGxpbmVBcmVhQm90dG9tUGF0aDogZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAocG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFsnTCcsIHBvc2l0aW9uLmxlZnQsIHRoaXMuemVyb1RvcF07XG4gICAgICAgIH0sIHRoaXMpLnJldmVyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNwbGluZSBhcmVhcyBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5Ljx7YXJlYTogQXJyYXkuPHN0cmluZyB8IG51bWJlcj4sIGxpbmU6IEFycmF5LjxzdHJpbmcgfCBudW1iZXI+fT59IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTcGxpbmVBcmVhc1BhdGg6IGZ1bmN0aW9uKGdyb3VwUG9zaXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgdmFyIGxpbmVzUGF0aCwgYXJlYXNCb3R0b21QYXRoO1xuXG4gICAgICAgICAgICBwb3NpdGlvbnNbMF0ubGVmdCAtPSAxO1xuICAgICAgICAgICAgbGluZXNQYXRoID0gdGhpcy5fbWFrZVNwbGluZUxpbmVzUGF0aChwb3NpdGlvbnMpO1xuICAgICAgICAgICAgYXJlYXNCb3R0b21QYXRoID0gdGhpcy5fbWFrZVNwbGluZUFyZWFCb3R0b21QYXRoKHBvc2l0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXJlYTogbGluZXNQYXRoLmNvbmNhdChhcmVhc0JvdHRvbVBhdGgpLFxuICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVzUGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaCBvZiBhcmVhIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IHBhcmFtcy5ncm91cFBvc2l0aW9ucztcblxuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuc3BsaW5lID8gdGhpcy5fZ2V0U3BsaW5lQXJlYXNQYXRoKGdyb3VwUG9zaXRpb25zKSA6IHRoaXMuX2dldEFyZWFzUGF0aChncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lLmF0dHIoe3RvcDogZGltZW5zaW9uLmhlaWdodH0pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhID0gdGhpcy5ncm91cEFyZWFzW2dyb3VwSW5kZXhdO1xuICAgICAgICAgICAgYXJlYS5hcmVhLmF0dHIoe3BhdGg6IHBhdGguYXJlYS5qb2luKCcgJyl9KTtcbiAgICAgICAgICAgIGFyZWEubGluZS5hdHRyKHtwYXRoOiBwYXRoLmxpbmUuam9pbignICcpfSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlRG90KGl0ZW0uZG90LCBncm91cFBvc2l0aW9uc1tncm91cEluZGV4XVtpbmRleF0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7P251bWJlcn0gbGVnZW5kSW5kZXggbGVnZW5kIGluZGV4XG4gICAgICovXG4gICAgc2VsZWN0TGVnZW5kOiBmdW5jdGlvbihsZWdlbmRJbmRleCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBub25lU2VsZWN0ZWQgPSB0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IGxlZ2VuZEluZGV4O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhID0gdGhpcy5ncm91cEFyZWFzW2dyb3VwSW5kZXhdLFxuICAgICAgICAgICAgICAgIG9wYWNpdHkgPSAobm9uZVNlbGVjdGVkIHx8IGxlZ2VuZEluZGV4ID09PSBncm91cEluZGV4KSA/IEVNUEhBU0lTX09QQUNJVFkgOiBERV9FTVBIQVNJU19PUEFDSVRZO1xuXG4gICAgICAgICAgICBhcmVhLmFyZWEuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgIGFyZWEubGluZS5hdHRyKHsnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5fSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmRvdE9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb3QuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbEFyZWFDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsIGJhciBjaGFydCByZW5kZXJlci5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbDtcblxudmFyIEFOSU1BVElPTl9USU1FID0gNzAwLFxuICAgIEVNUEhBU0lTX09QQUNJVFkgPSAxLFxuICAgIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsQmFyQ2hhcnQgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGJhciwgY29sdW1uIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxCYXJDaGFydFxuICovXG52YXIgUmFwaGFlbEJhckNoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsQmFyQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgYmFyIGNoYXJ0XG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7c2l6ZTogb2JqZWN0LCBtb2RlbDogb2JqZWN0LCBvcHRpb25zOiBvYmplY3QsIHRvb2x0aXBQb3NpdGlvbjogc3RyaW5nfX0gZGF0YSBjaGFydCBkYXRhXG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IGRhdGEuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBkaW1lbnNpb24gPSBkYXRhLmRpbWVuc2lvbixcbiAgICAgICAgICAgIHBhcGVyLCBiYXNlUGFyYW1zO1xuXG4gICAgICAgIGlmICghZ3JvdXBCb3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgYmFzZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIHRoZW1lOiBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgZ3JvdXBCb3VuZHM6IGdyb3VwQm91bmRzLFxuICAgICAgICAgICAgZ3JvdXBWYWx1ZXM6IGRhdGEuZ3JvdXBWYWx1ZXMsXG4gICAgICAgICAgICBjaGFydFR5cGU6IGRhdGEuY2hhcnRUeXBlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ncm91cEJhcnMgPSB0aGlzLl9yZW5kZXJCYXJzKGJhc2VQYXJhbXMpO1xuICAgICAgICB0aGlzLmdyb3VwQm9yZGVycyA9IHRoaXMuX3JlbmRlckJhckJvcmRlcnMoYmFzZVBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5ID0gdGhpcy5fcmVuZGVyT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLnRoZW1lID0gZGF0YS50aGVtZTtcbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IGdyb3VwQm91bmRzO1xuICAgICAgICB0aGlzLmNoYXJ0VHlwZSA9IGRhdGEuY2hhcnRUeXBlO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG92ZXJsYXkuXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZW5kZXJCYXIoe1xuICAgICAgICAgICAgYm91bmQ6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjogJyNmZmYnXG4gICAgICAgIH0pLmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByZWN0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNvbG9yIHNlcmllcyBjb2xvclxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ib3JkZXJDb2xvciBzZXJpZXMgYm9yZGVyQ29sb3JcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogQHJldHVybnMge29iamVjdH0gYmFyIHJlY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXI6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICByZWN0O1xuXG4gICAgICAgIGlmIChib3VuZC53aWR0aCA8IDAgfHwgYm91bmQuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gdGhpcy5wYXBlci5yZWN0KGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgYm91bmQud2lkdGgsIGJvdW5kLmhlaWdodCk7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBwYXJhbXMuY29sb3IsXG4gICAgICAgICAgICBzdHJva2U6ICdub25lJ1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJhcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tjb2xvcnM6IHN0cmluZ1tdLCBzaW5nbGVDb2xvcnM6IHN0cmluZ1tdLCBib3JkZXJDb2xvcjogc3RyaW5nfX0gcGFyYW1zLnRoZW1lIGJhciBjaGFydCB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBCb3VuZHMgYm91bmRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJhcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXJzOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNpbmdsZUNvbG9ycyA9IChwYXJhbXMuZ3JvdXBCb3VuZHNbMF0ubGVuZ3RoID09PSAxKSAmJiBwYXJhbXMudGhlbWUuc2luZ2xlQ29sb3JzIHx8IFtdLFxuICAgICAgICAgICAgY29sb3JzID0gcGFyYW1zLnRoZW1lLmNvbG9ycyxcbiAgICAgICAgICAgIGdyb3VwQmFycztcblxuICAgICAgICBncm91cEJhcnMgPSB0dWkudXRpbC5tYXAocGFyYW1zLmdyb3VwQm91bmRzLCBmdW5jdGlvbihib3VuZHMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVDb2xvciA9IHNpbmdsZUNvbG9yc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoYm91bmRzLCBmdW5jdGlvbihib3VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IsIHJlY3QsIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xvciA9IHNpbmdsZUNvbG9yIHx8IGNvbG9yc1tpbmRleF07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbXMuZ3JvdXBWYWx1ZXNbZ3JvdXBJbmRleF1baW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuX3JlbmRlckJhcih7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcGFyYW1zLnRoZW1lLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQuZW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwQmFycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSByZWN0IHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgcmVjdCBib3VuZFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBsZWZ0VG9wOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0sXG4gICAgICogICAgICByaWdodFRvcDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9LFxuICAgICAqICAgICAgcmlnaHRCb3R0b206IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGxlZnRCb3R0b206IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IHJlY3QgcG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVJlY3RQb2ludHM6IGZ1bmN0aW9uKGJvdW5kKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0VG9wOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodFRvcDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguY2VpbChib3VuZC5sZWZ0ICsgYm91bmQud2lkdGgpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByaWdodEJvdHRvbToge1xuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguY2VpbChib3VuZC5sZWZ0ICsgYm91bmQud2lkdGgpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcCArIGJvdW5kLmhlaWdodClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWZ0Qm90dG9tOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogTWF0aC5jZWlsKGJvdW5kLmxlZnQpLFxuICAgICAgICAgICAgICAgIHRvcDogTWF0aC5jZWlsKGJvdW5kLnRvcCArIGJvdW5kLmhlaWdodClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b3AgbGluZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJyZXIsIHRvcDogbnVtYmVyfX0gbGVmdFRvcCBsZWZ0IHRvcFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJyZXIsIHRvcDogbnVtYmVyfX0gcmlnaHRUb3AgcmlnaHQgdG9wXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9wIGxpbmUgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb3BMaW5lUGF0aDogZnVuY3Rpb24obGVmdFRvcCwgcmlnaHRUb3AsIGNoYXJ0VHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsb25lTGVmdFRvcCA9IHR1aS51dGlsLmV4dGVuZCh7fSwgbGVmdFRvcCk7XG4gICAgICAgIGNsb25lTGVmdFRvcC5sZWZ0IC09IGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgdmFsdWUgPCAwID8gMSA6IDA7XG4gICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoY2xvbmVMZWZ0VG9wLCByaWdodFRvcCkuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvcmRlciBsaW5lcyBwYXRocy5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgcmVjdCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBzdHJpbmcsIHJpZ2h0OiBzdHJpbmcsIGJvdHRvbTogc3RyaW5nLCBsZWZ0OiBzdHJpbmd9fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCb3JkZXJMaW5lc1BhdGhzOiBmdW5jdGlvbihib3VuZCwgY2hhcnRUeXBlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fbWFrZVJlY3RQb2ludHMoYm91bmQpLFxuICAgICAgICAgICAgcGF0aHMgPSB7fTtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnYmFyJyB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICBwYXRocy50b3AgPSB0aGlzLl9tYWtlVG9wTGluZVBhdGgocG9pbnRzLmxlZnRUb3AsIHBvaW50cy5yaWdodFRvcCwgY2hhcnRUeXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhcnRUeXBlID09PSAnY29sdW1uJyB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICBwYXRocy5yaWdodCA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb2ludHMucmlnaHRUb3AsIHBvaW50cy5yaWdodEJvdHRvbSkuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2JhcicgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBwYXRocy5ib3R0b20gPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgocG9pbnRzLmxlZnRCb3R0b20sIHBvaW50cy5yaWdodEJvdHRvbSkuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJ0VHlwZSA9PT0gJ2NvbHVtbicgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBwYXRocy5sZWZ0ID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHBvaW50cy5sZWZ0VG9wLCBwb2ludHMubGVmdEJvdHRvbSkuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYm9yZGVyIGxpbmVzO1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBiYXIgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnZhbHVlIHZhbHVlXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCb3JkZXJMaW5lczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3JkZXJMaW5lUGF0aHMgPSB0aGlzLl9tYWtlQm9yZGVyTGluZXNQYXRocyhwYXJhbXMuYm91bmQsIHBhcmFtcy5jaGFydFR5cGUsIHBhcmFtcy52YWx1ZSksXG4gICAgICAgICAgICBsaW5lcyA9IHt9O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2goYm9yZGVyTGluZVBhdGhzLCBmdW5jdGlvbihwYXRoLCBuYW1lKSB7XG4gICAgICAgICAgICBsaW5lc1tuYW1lXSA9IHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUodGhpcy5wYXBlciwgcGF0aCwgcGFyYW1zLmJvcmRlckNvbG9yLCAxKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYmFyIGJvcmRlcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tjb2xvcnM6IHN0cmluZ1tdLCBzaW5nbGVDb2xvcnM6IHN0cmluZ1tdLCBib3JkZXJDb2xvcjogc3RyaW5nfX0gcGFyYW1zLnRoZW1lIGJhciBjaGFydCB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBCb3VuZHMgYm91bmRzXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvcmRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJCYXJCb3JkZXJzOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGJvcmRlckNvbG9yID0gcGFyYW1zLnRoZW1lLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgZ3JvdXBCb3JkZXJzO1xuXG4gICAgICAgIGlmICghYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBCb3JkZXJzID0gdHVpLnV0aWwubWFwKHBhcmFtcy5ncm91cEJvdW5kcywgZnVuY3Rpb24oYm91bmRzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGJvdW5kcywgZnVuY3Rpb24oYm91bmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtcy5ncm91cFZhbHVlc1tncm91cEluZGV4XVtpbmRleF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQm9yZGVyTGluZXMoe1xuICAgICAgICAgICAgICAgICAgICBwYXBlcjogdGhpcy5wYXBlcixcbiAgICAgICAgICAgICAgICAgICAgYm91bmQ6IGJvdW5kLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwQm9yZGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSByZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWN0IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6bnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIHJlY3QgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlUmVjdDogZnVuY3Rpb24ocmVjdCwgYm91bmQpIHtcbiAgICAgICAgcmVjdC5hbmltYXRlKHtcbiAgICAgICAgICAgIHg6IGJvdW5kLmxlZnQsXG4gICAgICAgICAgICB5OiBib3VuZC50b3AsXG4gICAgICAgICAgICB3aWR0aDogYm91bmQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGJvdW5kLmhlaWdodFxuICAgICAgICB9LCBBTklNQVRJT05fVElNRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgYm9yZGVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBsaW5lcyByYXBoYWVsIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgcmVjdCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FuaW1hdGVCb3JkZXJzOiBmdW5jdGlvbihsaW5lcywgYm91bmQsIGNoYXJ0VHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5fbWFrZUJvcmRlckxpbmVzUGF0aHMoYm91bmQsIGNoYXJ0VHlwZSwgdmFsdWUpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2gobGluZXMsIGZ1bmN0aW9uKGxpbmUsIG5hbWUpIHtcbiAgICAgICAgICAgIGxpbmUuYW5pbWF0ZSh7cGF0aDogcGF0aHNbbmFtZV19LCBBTklNQVRJT05fVElNRSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrXG4gICAgICovXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXBCb3JkZXJzID0gdGhpcy5ncm91cEJvcmRlcnMgfHwgW107XG5cbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jYWxsYmFja1RpbWVvdXQpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tUaW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLmZvckVhY2gyZEFycmF5KHRoaXMuZ3JvdXBCYXJzLCBmdW5jdGlvbihiYXIsIGdyb3VwSW5kZXgsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF0gJiYgZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghYmFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5fYW5pbWF0ZVJlY3QoYmFyLnJlY3QsIGJhci5ib3VuZCk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9hbmltYXRlQm9yZGVycyhsaW5lcywgYmFyLmJvdW5kLCB0aGF0LmNoYXJ0VHlwZSwgYmFyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5jYWxsYmFja1RpbWVvdXQ7XG4gICAgICAgICAgICB9LCBBTklNQVRJT05fVElNRSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBkYXRhIHNob3cgaW5mb1xuICAgICAqL1xuICAgIHNob3dBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGJhciA9IHRoaXMuZ3JvdXBCYXJzW2RhdGEuZ3JvdXBJbmRleF1bZGF0YS5pbmRleF0sXG4gICAgICAgICAgICBib3VuZCA9IGJhci5ib3VuZDtcbiAgICAgICAgdGhpcy5vdmVybGF5LmF0dHIoe1xuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHQsXG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuM1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBhbmltYXRpb24uXG4gICAgICovXG4gICAgaGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5hdHRyKHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHJlY3QgYm91bmRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVjdCByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVSZWN0Qm91bmQ6IGZ1bmN0aW9uKHJlY3QsIGJvdW5kKSB7XG4gICAgICAgIHJlY3QuYXR0cih7XG4gICAgICAgICAgICB4OiBib3VuZC5sZWZ0LFxuICAgICAgICAgICAgeTogYm91bmQudG9wLFxuICAgICAgICAgICAgd2lkdGg6IGJvdW5kLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZC5oZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBib3JkZXJzIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IGxpbmVzIHJhcGhhZWwgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVCb3JkZXJzUGF0aDogZnVuY3Rpb24obGluZXMsIGJvdW5kLCBjaGFydFR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMuX21ha2VCb3JkZXJMaW5lc1BhdGhzKGJvdW5kLCBjaGFydFR5cGUsIHZhbHVlKTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGxpbmVzLCBmdW5jdGlvbihsaW5lLCBuYW1lKSB7XG4gICAgICAgICAgICBsaW5lLmF0dHIoe3BhdGg6IHBhdGhzW25hbWVdfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgYmFyIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDpudW1iZXIsIHRvcDpudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBCb3VuZHMgZ3JvdXAgYm91bmRzXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgZ3JvdXBCb3JkZXJzID0gdGhpcy5ncm91cEJvcmRlcnMgfHwgW10sXG4gICAgICAgICAgICBkaW1lbnNpb24gPSBwYXJhbXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBCb3VuZHMgPSBwYXJhbXMuZ3JvdXBCb3VuZHM7XG5cbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IGdyb3VwQm91bmRzO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcblxuICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5mb3JFYWNoMmRBcnJheSh0aGlzLmdyb3VwQmFycywgZnVuY3Rpb24oYmFyLCBncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzLCBib3VuZDtcblxuICAgICAgICAgICAgaWYgKCFiYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzID0gZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdICYmIGdyb3VwQm9yZGVyc1tncm91cEluZGV4XVtpbmRleF07XG4gICAgICAgICAgICBib3VuZCA9IGdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XS5lbmQ7XG4gICAgICAgICAgICBiYXIuYm91bmQgPSBib3VuZDtcbiAgICAgICAgICAgIHRoYXQuX3VwZGF0ZVJlY3RCb3VuZChiYXIucmVjdCwgYm91bmQpO1xuXG4gICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVCb3JkZXJzUGF0aChsaW5lcywgYm91bmQsIHRoYXQuY2hhcnRUeXBlLCBiYXIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGJvcmRlcnMgY29sb3IuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gbGluZXMgcmFwaGFlbCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtib3JkZXJDb2xvcn0gYm9yZGVyQ29sb3IgYm9yZGVyIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hhbmdlQm9yZGVyc0NvbG9yOiBmdW5jdGlvbihsaW5lcywgYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaChsaW5lcywgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtzdHJva2U6IGJvcmRlckNvbG9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgYmFyIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBib3JkZXJDb2xvciBzdHJva2UgY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGFuZ2VCYXJDb2xvcjogZnVuY3Rpb24oaW5kZXhlcywgY29sb3IsIGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgbGluZXM7XG5cbiAgICAgICAgYmFyLnJlY3QuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIGxpbmVzID0gdGhpcy5ncm91cEJvcmRlcnNbaW5kZXhlcy5ncm91cEluZGV4XVtpbmRleGVzLmluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUJvcmRlcnNDb2xvcihsaW5lcywgYm9yZGVyQ29sb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgb2JqQ29sb3IgPSByYXBoYWVsLmNvbG9yKGJhci5jb2xvciksXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMudGhlbWUuc2VsZWN0aW9uQ29sb3IgfHwgcmFwaGFlbFJlbmRlclV0aWwubWFrZUNoYW5nZWRMdW1pbmFuY2VDb2xvcihvYmpDb2xvci5oZXgsIDAuMiksXG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHRoaXMudGhlbWUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBvYmpCb3JkZXJDb2xvcjtcblxuICAgICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgIG9iakJvcmRlckNvbG9yID0gcmFwaGFlbC5jb2xvcihib3JkZXJDb2xvcik7XG4gICAgICAgICAgICBib3JkZXJDb2xvciA9IHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VDaGFuZ2VkTHVtaW5hbmNlQ29sb3Iob2JqQm9yZGVyQ29sb3IuaGV4LCAwLjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlQmFyQ29sb3IoaW5kZXhlcywgY29sb3IsIGJvcmRlckNvbG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3Qgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqL1xuICAgIHVuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmdyb3VwQmFyc1tpbmRleGVzLmdyb3VwSW5kZXhdW2luZGV4ZXMuaW5kZXhdLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3IgPSB0aGlzLnRoZW1lLmJvcmRlckNvbG9yO1xuICAgICAgICB0aGlzLl9jaGFuZ2VCYXJDb2xvcihpbmRleGVzLCBiYXIuY29sb3IsIGJvcmRlckNvbG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdExlZ2VuZDogZnVuY3Rpb24obGVnZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIGdyb3VwQm9yZGVycyA9IHRoaXMuZ3JvdXBCb3JkZXJzIHx8IFtdLFxuICAgICAgICAgICAgbm9uZVNlbGVjdGVkID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICByYXBoYWVsUmVuZGVyVXRpbC5mb3JFYWNoMmRBcnJheSh0aGlzLmdyb3VwQmFycywgZnVuY3Rpb24oYmFyLCBncm91cEluZGV4LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxpbmVzLCBvcGFjaXR5O1xuXG4gICAgICAgICAgICBpZiAoIWJhcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZXMgPSBncm91cEJvcmRlcnNbZ3JvdXBJbmRleF0gJiYgZ3JvdXBCb3JkZXJzW2dyb3VwSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAgIG9wYWNpdHkgPSAobm9uZVNlbGVjdGVkIHx8IGxlZ2VuZEluZGV4ID09PSBpbmRleCkgPyBFTVBIQVNJU19PUEFDSVRZIDogREVfRU1QSEFTSVNfT1BBQ0lUWTtcblxuICAgICAgICAgICAgYmFyLnJlY3QuYXR0cih7J2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHl9KTtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2gobGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5hdHRyKHsnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxCYXJDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsIGxpbmUgY2hhcnQgcmVuZGVyZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSYXBoYWVsTGluZUJhc2UgPSByZXF1aXJlKCcuL3JhcGhhZWxMaW5lVHlwZUJhc2UnKSxcbiAgICByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbCxcbiAgICBFTVBIQVNJU19PUEFDSVRZID0gMSxcbiAgICBERV9FTVBIQVNJU19PUEFDSVRZID0gMC4zO1xuXG52YXIgUmFwaGFlbExpbmVDaGFydCA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFJhcGhhZWxMaW5lQmFzZSwgLyoqIEBsZW5kcyBSYXBoYWVsTGluZUNoYXJ0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmFwaGFlbExpbmVDaGFydHMgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIGxpbmUgY2hhcnQuXG4gICAgICogQGNvbnN0cnVjdHMgUmFwaGFlbExpbmVDaGFydFxuICAgICAqIEBleHRlbmRzIFJhcGhhZWxMaW5lVHlwZUJhc2VcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlbGVjdGVkIGxlZ2VuZCBpbmRleFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBsaW5lIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge3tncm91cFBvc2l0aW9uczogQXJyYXkuPEFycmF5PiwgZGltZW5zaW9uOiBvYmplY3QsIHRoZW1lOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IGRhdGEgcmVuZGVyIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjb250YWluZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IGRhdGEuZGltZW5zaW9uLFxuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSBkYXRhLmdyb3VwUG9zaXRpb25zLFxuICAgICAgICAgICAgdGhlbWUgPSBkYXRhLnRoZW1lLFxuICAgICAgICAgICAgY29sb3JzID0gdGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgb3BhY2l0eSA9IGRhdGEub3B0aW9ucy5oYXNEb3QgPyAxIDogMCxcbiAgICAgICAgICAgIGdyb3VwUGF0aHMgPSBkYXRhLm9wdGlvbnMuc3BsaW5lID8gdGhpcy5fZ2V0U3BsaW5lTGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKSA6IHRoaXMuX2dldExpbmVzUGF0aChncm91cFBvc2l0aW9ucyksXG4gICAgICAgICAgICBib3JkZXJTdHlsZSA9IHRoaXMubWFrZUJvcmRlclN0eWxlKHRoZW1lLmJvcmRlckNvbG9yLCBvcGFjaXR5KSxcbiAgICAgICAgICAgIG91dERvdFN0eWxlID0gdGhpcy5tYWtlT3V0RG90U3R5bGUob3BhY2l0eSwgYm9yZGVyU3R5bGUpLFxuICAgICAgICAgICAgcGFwZXI7XG5cbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIDEsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNwbGluZU9wdGlvbiA9IGRhdGEub3B0aW9ucy5zcGxpbmU7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBMaW5lcyA9IHRoaXMuX3JlbmRlckxpbmVzKHBhcGVyLCBncm91cFBhdGhzLCBjb2xvcnMpO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lID0gdGhpcy5fcmVuZGVyVG9vbHRpcExpbmUocGFwZXIsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLmdyb3VwRG90cyA9IHRoaXMuX3JlbmRlckRvdHMocGFwZXIsIGdyb3VwUG9zaXRpb25zLCBjb2xvcnMsIG9wYWNpdHkpO1xuXG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkRvdCA9IHRoaXMuX21ha2VTZWxlY3Rpb25Eb3QocGFwZXIpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IHRoZW1lLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xvcnMgPSBjb2xvcnM7XG4gICAgICAgIHRoaXMuYm9yZGVyU3R5bGUgPSBib3JkZXJTdHlsZTtcbiAgICAgICAgdGhpcy5vdXREb3RTdHlsZSA9IG91dERvdFN0eWxlO1xuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IGdyb3VwUGF0aHM7XG4gICAgICAgIHRoaXMuZG90T3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBpdm90R3JvdXBEb3RzO1xuXG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGxpbmVzIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxzdHJpbmc+Pn0gcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVzUGF0aDogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICBwb3NpdGlvbnNbMF0ubGVmdCAtPSAxO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFrZUxpbmVzUGF0aChwb3NpdGlvbnMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNwbGluZSBsaW5lcyBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gZ3JvdXBQb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3BsaW5lTGluZXNQYXRoOiBmdW5jdGlvbihncm91cFBvc2l0aW9ucykge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGdyb3VwUG9zaXRpb25zLCB0aGlzLl9tYWtlU3BsaW5lTGluZXNQYXRoLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHN0cmluZz4+fSBncm91cFBhdGhzIHBhdGhzXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29sb3JzIGxpbmUgY29sb3JzXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBzdHJva2VXaWR0aCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gbGluZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJMaW5lczogZnVuY3Rpb24ocGFwZXIsIGdyb3VwUGF0aHMsIGNvbG9ycywgc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbZ3JvdXBJbmRleF0gfHwgJ3RyYW5zcGFyZW50JztcbiAgICAgICAgICAgIHJldHVybiByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJMaW5lKHBhcGVyLCBwYXRoLmpvaW4oJyAnKSwgY29sb3IsIHN0cm9rZVdpZHRoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSBncmFwaCBvZiBsaW5lIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge0FycmF5LjxBcnJheS48e2xlZnQ6bnVtYmVyLCB0b3A6bnVtYmVyfT4+fSBwYXJhbXMuZ3JvdXBQb3NpdGlvbnMgZ3JvdXAgcG9zaXRpb25zXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICBncm91cFBvc2l0aW9ucyA9IHBhcmFtcy5ncm91cFBvc2l0aW9ucztcblxuICAgICAgICB0aGlzLmdyb3VwUG9zaXRpb25zID0gZ3JvdXBQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuZ3JvdXBQYXRocyA9IHRoaXMuc3BsaW5lT3B0aW9uID8gdGhpcy5fZ2V0U3BsaW5lTGluZXNQYXRoKGdyb3VwUG9zaXRpb25zKSA6IHRoaXMuX2dldExpbmVzUGF0aChncm91cFBvc2l0aW9ucyk7XG4gICAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZShkaW1lbnNpb24ud2lkdGgsIGRpbWVuc2lvbi5oZWlnaHQpO1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lLmF0dHIoe3RvcDogZGltZW5zaW9uLmhlaWdodH0pO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwUGF0aHMsIGZ1bmN0aW9uKHBhdGgsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBMaW5lc1tncm91cEluZGV4XS5hdHRyKHtwYXRoOiBwYXRoLmpvaW4oJyAnKX0pO1xuXG4gICAgICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cERvdHNbZ3JvdXBJbmRleF0sIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZURvdChpdGVtLmRvdCwgZ3JvdXBQb3NpdGlvbnNbZ3JvdXBJbmRleF1baW5kZXhdKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxlZ2VuZC5cbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IGxlZ2VuZEluZGV4IGxlZ2VuZCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdExlZ2VuZDogZnVuY3Rpb24obGVnZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgbm9uZVNlbGVjdGVkID0gdHVpLnV0aWwuaXNOdWxsKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBsZWdlbmRJbmRleDtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5ncm91cFBhdGhzLCBmdW5jdGlvbihwYXRoLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IChub25lU2VsZWN0ZWQgfHwgbGVnZW5kSW5kZXggPT09IGdyb3VwSW5kZXgpID8gRU1QSEFTSVNfT1BBQ0lUWSA6IERFX0VNUEhBU0lTX09QQUNJVFk7XG5cbiAgICAgICAgICAgIHRoYXQuZ3JvdXBMaW5lc1tncm91cEluZGV4XS5hdHRyKHsnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5fSk7XG5cbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0ub3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhhdC5kb3RPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG90LmF0dHIoeydmaWxsLW9wYWNpdHknOiBvcGFjaXR5fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxMaW5lQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbExpbmVUeXBlQmFzZSBpcyBiYXNlIGNsYXNzIGZvciBsaW5lIHR5cGUgcmVuZGVyZXIuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIEFOSU1BVElPTl9USU1FID0gNzAwLFxuICAgIERFRkFVTFRfRE9UX1JBRElVUyA9IDMsXG4gICAgSE9WRVJfRE9UX1JBRElVUyA9IDQsXG4gICAgU0VMRUNUSU9OX0RPVF9SQURJVVMgPSA3LFxuICAgIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG5cbnZhciBjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbExpbmVUeXBlQmFzZSBpcyBiYXNlIGZvciBsaW5lIHR5cGUgcmVuZGVyZXIuXG4gKiBAY2xhc3MgUmFwaGFlbExpbmVUeXBlQmFzZVxuICovXG52YXIgUmFwaGFlbExpbmVUeXBlQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgUmFwaGFlbExpbmVUeXBlQmFzZS5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgbGluZXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMaW5lc1BhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICB2YXIgcGF0aCA9IHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gWydMJywgcG9zaXRpb24ubGVmdCwgcG9zaXRpb24udG9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGF0aCA9IGNvbmNhdC5hcHBseShbXSwgcGF0aCk7XG4gICAgICAgIHBhdGhbMF0gPSAnTSc7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbmNob3IuIChodHRwOi8vcmFwaGFlbGpzLmNvbS9hbmFseXRpY3MuanMpXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGZyb21Qb3MgZnJvbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3MgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gbmV4dFBvcyBuZXh0IHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3t4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyfX0gYW5jaG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QW5jaG9yOiBmdW5jdGlvbihmcm9tUG9zLCBwb3MsIG5leHRQb3MpIHtcbiAgICAgICAgdmFyIGwxID0gKHBvcy5sZWZ0IC0gZnJvbVBvcy5sZWZ0KSAvIDIsXG4gICAgICAgICAgICBsMiA9IChuZXh0UG9zLmxlZnQgLSBwb3MubGVmdCkgLyAyLFxuICAgICAgICAgICAgYSA9IE1hdGguYXRhbigocG9zLmxlZnQgLSBmcm9tUG9zLmxlZnQpIC8gTWF0aC5hYnMocG9zLnRvcCAtIGZyb21Qb3MudG9wKSksXG4gICAgICAgICAgICBiID0gTWF0aC5hdGFuKChuZXh0UG9zLmxlZnQgLSBwb3MubGVmdCkgLyBNYXRoLmFicyhwb3MudG9wIC0gbmV4dFBvcy50b3ApKSxcbiAgICAgICAgICAgIGFscGhhLCBkeDEsIGR5MSwgZHgyLCBkeTI7XG5cbiAgICAgICAgYSA9IGZyb21Qb3MudG9wIDwgcG9zLnRvcCA/IE1hdGguUEkgLSBhIDogYTtcbiAgICAgICAgYiA9IG5leHRQb3MudG9wIDwgcG9zLnRvcCA/IE1hdGguUEkgLSBiIDogYjtcbiAgICAgICAgYWxwaGEgPSBNYXRoLlBJIC8gMiAtICgoYSArIGIpICUgKE1hdGguUEkgKiAyKSkgLyAyO1xuICAgICAgICBkeDEgPSBsMSAqIE1hdGguc2luKGFscGhhICsgYSk7XG4gICAgICAgIGR5MSA9IGwxICogTWF0aC5jb3MoYWxwaGEgKyBhKTtcbiAgICAgICAgZHgyID0gbDIgKiBNYXRoLnNpbihhbHBoYSArIGIpO1xuICAgICAgICBkeTIgPSBsMiAqIE1hdGguY29zKGFscGhhICsgYik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBwb3MubGVmdCAtIGR4MSxcbiAgICAgICAgICAgIHkxOiBwb3MudG9wICsgZHkxLFxuICAgICAgICAgICAgeDI6IHBvcy5sZWZ0ICsgZHgyLFxuICAgICAgICAgICAgeTI6IHBvcy50b3AgKyBkeTJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzcGxpbmUgbGluZXMgcGF0aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+fSBwb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmcgfCBudW1iZXI+fSBwYXRoc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTcGxpbmVMaW5lc1BhdGg6IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICB2YXIgZmlyc3RQb3MgPSBwb3NpdGlvbnNbMF0sXG4gICAgICAgICAgICBwb3NpdGlvbnNMZW4gPSBwb3NpdGlvbnMubGVuZ3RoLFxuICAgICAgICAgICAgZnJvbVBvcyA9IGZpcnN0UG9zLFxuICAgICAgICAgICAgbGFzdFBvcyA9IHBvc2l0aW9uc1twb3NpdGlvbnNMZW4gLSAxXSxcbiAgICAgICAgICAgIG1pZGRsZVBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zbGljZSgxKS5zbGljZSgwLCBwb3NpdGlvbnNMZW4gLSAyKSxcbiAgICAgICAgICAgIHBhdGggPSB0dWkudXRpbC5tYXAobWlkZGxlUG9zaXRpb25zLCBmdW5jdGlvbihwb3NpdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBvcyA9IHBvc2l0aW9uc1tpbmRleCArIDJdLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB0aGlzLl9nZXRBbmNob3IoZnJvbVBvcywgcG9zaXRpb24sIG5leHRQb3MpO1xuICAgICAgICAgICAgICAgIGZyb21Qb3MgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FuY2hvci54MSwgYW5jaG9yLnkxLCBwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3AsIGFuY2hvci54MiwgYW5jaG9yLnkyXTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGZpcnN0UG9zLmxlZnQgLT0gMTtcbiAgICAgICAgcGF0aC5wdXNoKFtsYXN0UG9zLmxlZnQsIGxhc3RQb3MudG9wLCBsYXN0UG9zLmxlZnQsIGxhc3RQb3MudG9wXSk7XG4gICAgICAgIHBhdGgudW5zaGlmdChbJ00nLCBmaXJzdFBvcy5sZWZ0LCBmaXJzdFBvcy50b3AsICdDJywgZmlyc3RQb3MubGVmdCwgZmlyc3RQb3MudG9wXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0b29sdGlwIGxpbmUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyVG9vbHRpcExpbmU6IGZ1bmN0aW9uKHBhcGVyLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIGxpbmVQYXRoID0gcmFwaGFlbFJlbmRlclV0aWwubWFrZUxpbmVQYXRoKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAxMCxcbiAgICAgICAgICAgICAgICB0b3A6IGhlaWdodFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IDEwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUocGFwZXIsIGxpbmVQYXRoLCAndHJhbnNwYXJlbnQnLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3JkZXIgc3R5bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJvcmRlckNvbG9yIGJvcmRlciBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7e3N0cm9rZTogc3RyaW5nLCBzdHJva2Utd2lkdGg6IG51bWJlciwgc3RyaWtlLW9wYWNpdHk6IG51bWJlcn19IGJvcmRlciBzdHlsZVxuICAgICAqL1xuICAgIG1ha2VCb3JkZXJTdHlsZTogZnVuY3Rpb24oYm9yZGVyQ29sb3IsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIGJvcmRlclN0eWxlO1xuXG4gICAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgYm9yZGVyU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvcmRlclN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGRvdCBzdHlsZSBmb3IgbW91c2VvdXQgZXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib3JkZXJTdHlsZSBib3JkZXIgc3R5bGVcbiAgICAgKiBAcmV0dXJucyB7e2ZpbGwtb3BhY2l0eTogbnVtYmVyLCBzdHJva2Utb3BhY2l0eTogbnVtYmVyLCByOiBudW1iZXJ9fSBzdHlsZVxuICAgICAqL1xuICAgIG1ha2VPdXREb3RTdHlsZTogZnVuY3Rpb24ob3BhY2l0eSwgYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgdmFyIG91dERvdFN0eWxlID0ge1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IG9wYWNpdHksXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgcjogREVGQVVMVF9ET1RfUkFESVVTXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICB0dWkudXRpbC5leHRlbmQob3V0RG90U3R5bGUsIGJvcmRlclN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXREb3RTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBhZXJcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gZG90IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGRvdCBjb2xvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIGRvdFxuICAgICAqL1xuICAgIHJlbmRlckRvdDogZnVuY3Rpb24ocGFwZXIsIHBvc2l0aW9uLCBjb2xvciwgb3BhY2l0eSkge1xuICAgICAgICB2YXIgZG90ID0gcGFwZXIuY2lyY2xlKHBvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcCwgREVGQVVMVF9ET1RfUkFESVVTKSxcbiAgICAgICAgICAgIGRvdFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcGFjaXR5LFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgZG90LmF0dHIoZG90U3R5bGUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb3Q6IGRvdCxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZG90cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqIEBwYXJhbSB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gZ3JvdXBQb3NpdGlvbnMgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gY29sb3JzIGNvbG9yc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IGRvdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJEb3RzOiBmdW5jdGlvbihwYXBlciwgZ3JvdXBQb3NpdGlvbnMsIGNvbG9ycywgb3BhY2l0eSkge1xuICAgICAgICB2YXIgZG90cyA9IHR1aS51dGlsLm1hcChncm91cFBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90ID0gdGhpcy5yZW5kZXJEb3QocGFwZXIsIHBvc2l0aW9uLCBjb2xvciwgb3BhY2l0eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvdDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gZG90cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGNlbnRlciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBmcm9tUG9zIGZyb20gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gdG9Qb3MgdG8gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENlbnRlcjogZnVuY3Rpb24oZnJvbVBvcywgdG9Qb3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IChmcm9tUG9zLmxlZnQgKyB0b1Bvcy5sZWZ0KSAvIDIsXG4gICAgICAgICAgICB0b3A6IChmcm9tUG9zLnRvcCArIHRvUG9zLnRvcCkgLyAyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkb3QgcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93RG90OiBmdW5jdGlvbihkb3QpIHtcbiAgICAgICAgZG90LmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLjMsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgIHI6IEhPVkVSX0RPVF9SQURJVVNcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBsaW5lIHN0cm9rZSB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbGluZSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VXaWR0aCBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVMaW5lU3Ryb2tlV2lkdGg6IGZ1bmN0aW9uKGxpbmUsIHN0cm9rZVdpZHRoKSB7XG4gICAgICAgIGxpbmUuYXR0cih7XG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogc3Ryb2tlV2lkdGhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6bnVtYmVyfX0gZGF0YSBzaG93IGluZm9cbiAgICAgKi9cbiAgICBzaG93QW5pbWF0aW9uOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGRhdGEuZ3JvdXBJbmRleCwgLy8gTGluZSBjaGFydCBoYXMgcGl2b3QgdmFsdWVzLlxuICAgICAgICAgICAgZ3JvdXBJbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgICBsaW5lID0gdGhpcy5ncm91cExpbmVzID8gdGhpcy5ncm91cExpbmVzW2dyb3VwSW5kZXhdIDogdGhpcy5ncm91cEFyZWFzW2dyb3VwSW5kZXhdLmxpbmUsXG4gICAgICAgICAgICBpdGVtID0gdGhpcy5ncm91cERvdHNbZ3JvdXBJbmRleF1baW5kZXhdO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVTdHJva2VXaWR0aChsaW5lLCAzKTtcbiAgICAgICAgdGhpcy5fc2hvd0RvdChpdGVtLmRvdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBwaXZvdCBncm91cCBkb3RzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXk+fSBkb3RzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UGl2b3RHcm91cERvdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucGl2b3RHcm91cERvdHMpIHtcbiAgICAgICAgICAgIHRoaXMucGl2b3RHcm91cERvdHMgPSB0dWkudXRpbC5waXZvdCh0aGlzLmdyb3VwRG90cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5waXZvdEdyb3VwRG90cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBncm91cCBkb3RzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3dHcm91cERvdHM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBncm91cERvdHMgPSB0aGlzLl9nZXRQaXZvdEdyb3VwRG90cygpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShncm91cERvdHNbaW5kZXhdLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93RG90KGl0ZW0uZG90KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgbGluZSBmb3IgZ3JvdXAgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCBib3VuZFxuICAgICAqL1xuICAgIHNob3dHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICB2YXIgbGluZVBhdGggPSByYXBoYWVsUmVuZGVyVXRpbC5tYWtlTGluZVBhdGgoe1xuICAgICAgICAgICAgbGVmdDogYm91bmQucG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIHRvcDogYm91bmQucG9zaXRpb24udG9wICsgYm91bmQuZGltZW5zaW9uLmhlaWdodFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBsZWZ0OiBib3VuZC5wb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBib3VuZC5wb3NpdGlvbi50b3BcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b29sdGlwTGluZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IGxpbmVQYXRoLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzk5OScsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IGdyb3VwIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBzaG93R3JvdXBBbmltYXRpb246IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3Nob3dHcm91cERvdHMoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGRvdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90IHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBvcGFjaXR5IG9wYWNpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oaWRlRG90OiBmdW5jdGlvbihkb3QsIG9wYWNpdHkpIHtcbiAgICAgICAgdmFyIG91dERvdFN0eWxlID0gdGhpcy5vdXREb3RTdHlsZTtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICBvdXREb3RTdHlsZSA9IHR1aS51dGlsLmV4dGVuZCh7fSwgdGhpcy5vdXREb3RTdHlsZSwge1xuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiBvcGFjaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvdC5hdHRyKG91dERvdFN0eWxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBkYXRhIGhpZGUgaW5mb1xuICAgICAqL1xuICAgIGhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0YS5ncm91cEluZGV4LCAvLyBMaW5lIGNoYXJ0IGhhcyBwaXZvdCB2YWx1ZXMuXG4gICAgICAgICAgICBncm91cEluZGV4ID0gZGF0YS5pbmRleCxcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLmdyb3VwTGluZXMgPyB0aGlzLmdyb3VwTGluZXNbZ3JvdXBJbmRleF0gOiB0aGlzLmdyb3VwQXJlYXNbZ3JvdXBJbmRleF0ubGluZSxcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tncm91cEluZGV4XVtpbmRleF0sXG4gICAgICAgICAgICBvcGFjaXR5ID0gdGhpcy5kb3RPcGFjaXR5O1xuXG4gICAgICAgIGlmIChvcGFjaXR5ICYmICF0dWkudXRpbC5pc051bGwodGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4KSAmJiB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggIT09IGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIG9wYWNpdHkgPSBERV9FTVBIQVNJU19PUEFDSVRZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxpbmVTdHJva2VXaWR0aChsaW5lLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9oaWRlRG90KGl0ZW0uZG90LCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGdyb3VwIGRvdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGlkZUdyb3VwRG90czogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGRvdHMgPSB0aGlzLl9nZXRQaXZvdEdyb3VwRG90cygpLFxuICAgICAgICAgICAgaGFzU2VsZWN0ZWRJbmRleCA9ICF0dWkudXRpbC5pc051bGwodGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4KSxcbiAgICAgICAgICAgIGJhc2VPcGFjaXR5ID0gdGhpcy5kb3RPcGFjaXR5O1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShkb3RzW2luZGV4XSwgZnVuY3Rpb24oaXRlbSwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBiYXNlT3BhY2l0eTtcblxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgJiYgaGFzU2VsZWN0ZWRJbmRleCAmJiB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggIT09IGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gREVfRU1QSEFTSVNfT1BBQ0lUWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faGlkZURvdChpdGVtLmRvdCwgb3BhY2l0eSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGxpbmUgZm9yIGdyb3VwIHRvb2x0aXAuXG4gICAgICovXG4gICAgaGlkZUdyb3VwVG9vbHRpcExpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBMaW5lLmF0dHIoe1xuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSBncm91cCBhbmltYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgaGlkZUdyb3VwQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLl9oaWRlR3JvdXBEb3RzKGluZGV4KTtcbiAgICB9LFxuXG4gICAgX21vdmVEb3Q6IGZ1bmN0aW9uKGRvdCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRvdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIGN4OiBwb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3BcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuZG90T3BhY2l0eSkge1xuICAgICAgICAgICAgZG90QXR0cnMgPSB0dWkudXRpbC5leHRlbmQoeydmaWxsLW9wYWNpdHknOiB0aGlzLmRvdE9wYWNpdHl9LCBkb3RBdHRycywgdGhpcy5ib3JkZXJTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3QuYXR0cihkb3RBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25GaW5pc2ggY2FsbGJhY2tcbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbihvbkZpbmlzaCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBzZXJpZXNXaWR0aCA9IHRoaXMuZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgc2VyaWVzSGVpZ2h0ID0gdGhpcy5kaW1lbnNpb24uaGVpZ2h0O1xuXG4gICAgICAgIHR1aS5jaGFydC5yZW5kZXJVdGlsLmNhbmNlbEFuaW1hdGlvbih0aGlzLmFuaW1hdGlvbik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSB0dWkuY2hhcnQucmVuZGVyVXRpbC5zdGFydEFuaW1hdGlvbihBTklNQVRJT05fVElNRSwgZnVuY3Rpb24ocmF0aW8pIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IE1hdGgubWluKHNlcmllc1dpZHRoICogcmF0aW8sIHNlcmllc1dpZHRoKTtcblxuICAgICAgICAgICAgdGhhdC5wYXBlci5zZXRTaXplKHdpZHRoLCBzZXJpZXNIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvbkZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZWxlY3Rpb24gZG90LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHJldHVybnMge29iamVjdH0gc2VsZWN0aW9uIGRvdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWxlY3Rpb25Eb3Q6IGZ1bmN0aW9uKHBhcGVyKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Eb3QgPSBwYXBlci5jaXJjbGUoMCwgMCwgU0VMRUNUSU9OX0RPVF9SQURJVVMpO1xuXG4gICAgICAgIHNlbGVjdGlvbkRvdC5hdHRyKHtcbiAgICAgICAgICAgICdmaWxsJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAwLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25Eb3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5ncm91cERvdHNbaW5kZXhlcy5pbmRleF1baW5kZXhlcy5ncm91cEluZGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5ncm91cFBvc2l0aW9uc1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICBjeDogcG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGN5OiBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5zZWxlY3Rpb25Db2xvciB8fCBpdGVtLmNvbG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICovXG4gICAgdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdyb3VwRG90c1tpbmRleGVzLmluZGV4XVtpbmRleGVzLmdyb3VwSW5kZXhdO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Eb3QuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsTGluZVR5cGVCYXNlO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJhcGhhZWxQaWVDaGFydHMgaXMgZ3JhcGggcmVuZGVyZXIgZm9yIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0gcmVxdWlyZSgnLi9yYXBoYWVsUmVuZGVyVXRpbCcpO1xuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgU1RST0tFX0NPTE9SID0gJ2dyYXknO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbE1hcENoYXJ0cyBpcyBncmFwaCByZW5kZXJlciBmb3IgbWFwIGNoYXJ0LlxuICogQGNsYXNzIFJhcGhhZWxNYXBDaGFydFxuICovXG52YXIgUmFwaGFlbE1hcENoYXJ0ID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsTWFwQ2hhcnQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZnVuY3Rpb24gb2YgbWFwIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRhdGEuZGltZW5zaW9uIHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPHtjb2RlOiBzdHJpbmcsIHBhdGg6IHN0cmluZ30+fSBkYXRhLm1hcCBtYXBEYXRhXG4gICAgICogICAgICBAcGFyYW0ge01hcENoYXJ0Q29sb3JNb2RlbH0gZGF0YS5jb2xvck1vZGVsIGNvbG9yIG1vZGVsXG4gICAgICogQHJldHVybnMge29iamVjdH0gcGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBkYXRhLmRpbWVuc2lvbixcbiAgICAgICAgICAgIG1hcERpbWVuc2lvbiA9IGRhdGEubWFwTW9kZWwuZ2V0TWFwRGltZW5zaW9uKCksXG4gICAgICAgICAgICBwYXBlcjtcblxuICAgICAgICB0aGlzLnBhcGVyID0gcGFwZXIgPSByYXBoYWVsKGNvbnRhaW5lciwgZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZWN0b3JzID0gdGhpcy5fcmVuZGVyTWFwKGRhdGEpO1xuICAgICAgICB0aGlzLm92ZXJDb2xvciA9IGRhdGEudGhlbWUub3ZlckNvbG9yO1xuXG4gICAgICAgIHBhcGVyLnNldFZpZXdCb3goMCwgMCwgbWFwRGltZW5zaW9uLndpZHRoLCBtYXBEaW1lbnNpb24uaGVpZ2h0LCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbWFwIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGF0YS5kaW1lbnNpb24gc2VyaWVzIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48e2NvZGU6IHN0cmluZywgcGF0aDogc3RyaW5nfT59IGRhdGEubWFwIG1hcERhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7TWFwQ2hhcnRDb2xvck1vZGVsfSBkYXRhLmNvbG9yTW9kZWwgY29sb3IgbW9kZWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHtzZWN0b3I6IG9iamVjdCwgY29sb3I6IHN0cmluZywgZGF0YTogb2JqZWN0fT59IHJlbmRlcmVkIG1hcCBpbmZvcm1hdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck1hcDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29sb3JNb2RlbCA9IGRhdGEuY29sb3JNb2RlbDtcblxuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKGRhdGEubWFwTW9kZWwuZ2V0TWFwRGF0YSgpLCBmdW5jdGlvbihkYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwZXJjZW50VmFsdWUgPSBkYXR1bS5wZXJjZW50VmFsdWUgfHwgMCxcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yTW9kZWwuZ2V0Q29sb3IocGVyY2VudFZhbHVlKSxcbiAgICAgICAgICAgICAgICBzZWN0b3IgPSByYXBoYWVsUmVuZGVyVXRpbC5yZW5kZXJBcmVhKHRoaXMucGFwZXIsIGRhdHVtLnBhdGgsIGNvbG9yLCAxLCBTVFJPS0VfQ09MT1IsIDEpO1xuXG4gICAgICAgICAgICBzZWN0b3IuZGF0YSgnaW5kZXgnLCBpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VjdG9yOiBzZWN0b3IsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRWYWx1ZTogZGF0dW0ucGVyY2VudFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBzZWN0b3IgaW5kZXguXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMgez9udW1iZXJ9IGZvdW5kIGluZGV4XG4gICAgICovXG4gICAgZmluZFNlY3RvckluZGV4OiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgZm91bmRJbmRleCA9IChzZWN0b3IgJiYgIXR1aS51dGlsLmlzVW5kZWZpbmVkKHNlY3Rvci5kYXRhKCdpbmRleCcpKSkgPyBzZWN0b3IuZGF0YSgnaW5kZXgnKSA6IG51bGwsXG4gICAgICAgICAgICBkYXRhID0gZm91bmRJbmRleCAmJiB0aGlzLnNlY3RvcnNbZm91bmRJbmRleF07XG5cbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgIXR1aS51dGlsLmlzVW5kZWZpbmVkKGRhdGEucGVyY2VudFZhbHVlKSA/IGZvdW5kSW5kZXggOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY29sb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICovXG4gICAgY2hhbmdlQ29sb3I6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnNlY3RvcnNbaW5kZXhdO1xuXG4gICAgICAgIHNlY3Rvci5zZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICBmaWxsOiB0aGlzLm92ZXJDb2xvclxuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGNvbG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIHJlc3RvcmVDb2xvcjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlY3RvciA9IHRoaXMuc2VjdG9yc1tpbmRleF07XG5cbiAgICAgICAgc2VjdG9yLnNlY3Rvci5hbmltYXRlKHtcbiAgICAgICAgICAgIGZpbGw6IHNlY3Rvci5jb2xvclxuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2l6ZVxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqL1xuICAgIHNldFNpemU6IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXBoYWVsTWFwQ2hhcnQ7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmFwaGFlbE1hcExlZ2VuZCBpcyBncmFwaCByZW5kZXJlciBmb3IgbWFwIGNoYXJ0IGxlZ2VuZC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgcmFwaGFlbCA9IHdpbmRvdy5SYXBoYWVsO1xuXG52YXIgUEFERElORyA9IDEwO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgUmFwaGFlbE1hcExlZ2VuZCBpcyBncmFwaCByZW5kZXJlciBmb3IgbWFwIGNoYXJ0IGxlZ2VuZC5cbiAqIEBjbGFzcyBSYXBoYWVsTWFwTGVnZW5kXG4gKi9cbnZhciBSYXBoYWVsTWFwTGVnZW5kID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBSYXBoYWVsTWFwTGVnZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGZ1bmN0aW9uIG9mIG1hcCBjaGFydCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGxlZ2VuZCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge01hcENoYXJ0Q29sb3JNb2RlbH0gY29sb3JNb2RlbCBtYXAgY2hhcnQgY29sb3IgbW9kZWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSG9yaXpvbnRhbCB3aGV0aGVyIGhvcml6b250YWwgbGVnZW5kIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGltZW5zaW9uLCBjb2xvck1vZGVsLCBpc0hvcml6b250YWwpIHtcbiAgICAgICAgdmFyIHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyR3JhZGllbnRCYXIocGFwZXIsIGRpbWVuc2lvbiwgY29sb3JNb2RlbCwgaXNIb3Jpem9udGFsKTtcbiAgICAgICAgdGhpcy53ZWRnZSA9IHRoaXMuX3JlbmRlcldlZGdlKHBhcGVyKTtcblxuICAgICAgICByZXR1cm4gcGFwZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBncmFkaWVudCBiYXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gbGVnZW5kIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7TWFwQ2hhcnRDb2xvck1vZGVsfSBjb2xvck1vZGVsIG1hcCBjaGFydCBjb2xvciBtb2RlbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIb3Jpem9udGFsIHdoZXRoZXIgaG9yaXpvbnRhbCBsZWdlbmQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhZGllbnRCYXI6IGZ1bmN0aW9uKHBhcGVyLCBkaW1lbnNpb24sIGNvbG9yTW9kZWwsIGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgcmVjdFdpZHRoID0gZGltZW5zaW9uLndpZHRoIC0gUEFERElORyxcbiAgICAgICAgICAgIHJlY3RIZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdCA9IDAsXG4gICAgICAgICAgICBkZWdyZWU7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmVjdEhlaWdodCAtPSBQQURESU5HO1xuICAgICAgICAgICAgbGVmdCA9IFBBRERJTkcgLyAyO1xuICAgICAgICAgICAgZGVncmVlID0gMzYwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VIb3Jpem9udGFsV2VkZ2VQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVncmVlID0gMjcwO1xuICAgICAgICAgICAgdGhpcy5fbWFrZVdlZGdoUGF0aCA9IHRoaXMuX21ha2VWZXJ0aWNhbFdlZGdlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcGVyLnJlY3QobGVmdCwgMCwgcmVjdFdpZHRoLCByZWN0SGVpZ2h0KS5hdHRyKHtcbiAgICAgICAgICAgIGZpbGw6IGRlZ3JlZSArICctJyArIGNvbG9yTW9kZWwuc3RhcnQgKyAnLScgKyBjb2xvck1vZGVsLmVuZCxcbiAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgd2VkZ2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgb2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJXZWRnZTogZnVuY3Rpb24ocGFwZXIpIHtcbiAgICAgICAgdmFyIHdlZGdlID0gcGFwZXIucGF0aCh0aGlzLnZlcnRpY2FsQmFzZVBhdGgpLmF0dHIoe1xuICAgICAgICAgICAgJ2ZpbGwnOiAnZ3JheScsXG4gICAgICAgICAgICBzdHJva2U6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHdlZGdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBiYXNlIHBhdGhcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdmVydGljYWxCYXNlUGF0aDogWydNJywgMTYsIDYsICdMJywgMjQsIDMsICdMJywgMjQsIDldLFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB2ZXJ0aWNhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgdG9wXG4gICAgICogQHJldHVybnMge0FycmF5fSBwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVZlcnRpY2FsV2VkZ2VQYXRoOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnZlcnRpY2FsQmFzZVBhdGg7XG5cbiAgICAgICAgcGF0aFsyXSA9IHRvcDtcbiAgICAgICAgcGF0aFs1XSA9IHRvcCAtIDM7XG4gICAgICAgIHBhdGhbOF0gPSB0b3AgKyAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJhc2UgcGF0aFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBob3Jpem9udGFsQmFzZVBhdGg6IFsnTScsIDUsIDE2LCAnTCcsIDgsIDI0LCAnTCcsIDIsIDI0XSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCB3ZWRnZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IGxlZnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFdlZGdlUGF0aDogZnVuY3Rpb24obGVmdCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuaG9yaXpvbnRhbEJhc2VQYXRoO1xuXG4gICAgICAgIGxlZnQgKz0gUEFERElORyAvIDI7XG5cbiAgICAgICAgcGF0aFsxXSA9IGxlZnQ7XG4gICAgICAgIHBhdGhbNF0gPSBsZWZ0ICsgMztcbiAgICAgICAgcGF0aFs3XSA9IGxlZnQgLSAzO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHdlZGdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblZhbHVlIHRvcFxuICAgICAqL1xuICAgIHNob3dXZWRnZTogZnVuY3Rpb24ocG9zaXRpb25WYWx1ZSkge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX21ha2VXZWRnaFBhdGgocG9zaXRpb25WYWx1ZSk7XG5cbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHdlZGdlXG4gICAgICovXG4gICAgaGlkZVdlZGdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy53ZWRnZS5hdHRyKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFwaGFlbE1hcExlZ2VuZDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByYXBoYWVsUmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4vcmFwaGFlbFJlbmRlclV0aWwnKTtcblxudmFyIHJhcGhhZWwgPSB3aW5kb3cuUmFwaGFlbCxcbiAgICBBTkdMRV8xODAgPSAxODAsXG4gICAgUkFEID0gTWF0aC5QSSAvIEFOR0xFXzE4MCxcbiAgICBBTklNQVRJT05fVElNRSA9IDUwMCxcbiAgICBMT0FESU5HX0FOSU1BVElPTl9USU1FID0gNzAwLFxuICAgIEVNUEhBU0lTX09QQUNJVFkgPSAxLFxuICAgIERFX0VNUEhBU0lTX09QQUNJVFkgPSAwLjM7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBSYXBoYWVsUGllQ2hhcnRzIGlzIGdyYXBoIHJlbmRlcmVyIGZvciBwaWUgY2hhcnQuXG4gKiBAY2xhc3MgUmFwaGFlbFBpZUNoYXJ0XG4gKi9cbnZhciBSYXBoYWVsUGllQ2hhcnQgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIFJhcGhhZWxQaWVDaGFydC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBmdW5jdGlvbiBvZiBwaWUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7e3NlY3RvckRhdGE6IEFycmF5LjxvYmplY3Q+LCBjaXJjbGVCb3VuZDoge2N4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcn0sIGRpbWVuc2lvbjogb2JqZWN0LCB0aGVtZTogb2JqZWN0LCBvcHRpb25zOiBvYmplY3R9fSBkYXRhIHJlbmRlciBkYXRhXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNhbGxiYWNrcyBjYWxsYmFja3NcbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrcy5mdW5jU2hvd1Rvb2x0aXAgc2hvdyB0b29sdGlwIGZ1bmN0aW9uXG4gICAgICogICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja3MuZnVuY0hpZGVUb29sdGlwIGhpZGUgdG9vbHRpcCBmdW5jdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tzLmZ1bmNTZWxlY3RTZXJpZXMgc2VsZWN0IHNlcmllcyBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBkYXRhLmRpbWVuc2lvbixcbiAgICAgICAgICAgIHBhcGVyO1xuXG4gICAgICAgIC8vUmFwaGFlbC5fb2lkID0gMDtcbiAgICAgICAgdGhpcy5wYXBlciA9IHBhcGVyID0gcmFwaGFlbChjb250YWluZXIsIGRpbWVuc2lvbi53aWR0aCwgZGltZW5zaW9uLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFwYXBlci5jdXN0b21BdHRyaWJ1dGVzLnNlY3Rvcikge1xuICAgICAgICAgICAgcGFwZXIuY3VzdG9tQXR0cmlidXRlcy5zZWN0b3IgPSB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VTZWN0b3JQYXRoLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db2xvciA9IGRhdGEudGhlbWUuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIHRoaXMuY2lyY2xlQm91bmQgPSBkYXRhLmNpcmNsZUJvdW5kO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlclBpZShwYXBlciwgZGF0YSk7XG4gICAgICAgIHJldHVybiBwYXBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgcGFwZXIuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhcGVyLmNsZWFyKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYWtlIHNlY3RvciBwYXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCBjZW50ZXIgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeSBjZW50ZXIgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIHN0YXJ0IGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIGVuZCBhbmdlbFxuICAgICAqIEByZXR1cm5zIHt7cGF0aDogQXJyYXl9fSBzZWN0b3IgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZWN0b3JQYXRoOiBmdW5jdGlvbihjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG4gICAgICAgIHZhciB4MSA9IGN4ICsgciAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKiBSQUQpLCAvLyDsm5Ag7Zi47J2YIOyLnOyekSB4IOyijO2RnFxuICAgICAgICAgICAgeTEgPSBjeSAtIHIgKiBNYXRoLmNvcyhzdGFydEFuZ2xlICogUkFEKSwgLy8g7JuQIO2YuOydmCDsi5zsnpEgeSDsooztkZxcbiAgICAgICAgICAgIHgyID0gY3ggKyByICogTWF0aC5zaW4oZW5kQW5nbGUgKiBSQUQpLCAvLyDsm5Ag7Zi47J2YIOyiheujjCB4IOyijO2RnFxuICAgICAgICAgICAgeTIgPSBjeSAtIHIgKiBNYXRoLmNvcyhlbmRBbmdsZSAqIFJBRCksIC8vIOybkCDtmLjsnZgg7KKF66OMIHkg7KKM7ZGcXG4gICAgICAgICAgICBsYXJnZUFyY0ZsYWcgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBBTkdMRV8xODAgPyAxIDogMCxcbiAgICAgICAgICAgIHBhdGggPSBbJ00nLCBjeCwgY3ksXG4gICAgICAgICAgICAgICAgJ0wnLCB4MSwgeTEsXG4gICAgICAgICAgICAgICAgJ0EnLCByLCByLCAwLCBsYXJnZUFyY0ZsYWcsIDEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICAnWidcbiAgICAgICAgICAgIF07XG4gICAgICAgIC8vIHBhdGjsl5Ag64yA7ZWcIOyekOyEuO2VnCDshKTrqoXsnYAg7JWE656YIOunge2BrOulvCDssLjqs6BcbiAgICAgICAgLy8gaHR0cDovL3d3dy53M3NjaG9vbHMuY29tL3N2Zy9zdmdfcGF0aC5hc3BcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kXG4gICAgICAgIHJldHVybiB7cGF0aDogcGF0aH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMucGFwZXIgcmFwaGFlbCBwYXBlclxuICAgICAqICAgICAgQHBhcmFtIHt7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjpudW1iZXJ9fSBwYXJhbXMuY2lyY2xlQm91bmQgY2lyY2xlIGJvdW5kc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydEFuZ2xlIHN0YXJ0IGFuZ2xlXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZEFuZ2xlIGVuZCBhbmdsZVxuICAgICAqICAgICAgQHBhcmFtIHt7ZmlsbDogc3RyaW5nLCBzdHJva2U6IHN0cmluZywgc3RyaWtlLXdpZHRoOiBzdHJpbmd9fSBwYXJhbXMuYXR0cnMgYXR0cnNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSByYXBoYWVsIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlY3RvcjogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgY2lyY2xlQm91bmQgPSBwYXJhbXMuY2lyY2xlQm91bmQsXG4gICAgICAgICAgICBhbmdsZXMgPSBwYXJhbXMuYW5nbGVzO1xuXG4gICAgICAgIHJldHVybiBwYXJhbXMucGFwZXIucGF0aCgpLmF0dHIoe1xuICAgICAgICAgICAgc2VjdG9yOiBbY2lyY2xlQm91bmQuY3gsIGNpcmNsZUJvdW5kLmN5LCBjaXJjbGVCb3VuZC5yLCBhbmdsZXMuc3RhcnRBbmdsZSwgYW5nbGVzLmVuZEFuZ2xlXVxuICAgICAgICB9KS5hdHRyKHBhcmFtcy5hdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBwaWUgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHJhcGhhZWwgcGFwZXJcbiAgICAgKiBAcGFyYW0ge3tzZWN0b3JEYXRhOiBBcnJheS48b2JqZWN0PiwgY2lyY2xlQm91bmQ6IHtjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9LCBkaW1lbnNpb246IG9iamVjdCwgdGhlbWU6IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gZGF0YSByZW5kZXIgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclBpZTogZnVuY3Rpb24ocGFwZXIsIGRhdGEpIHtcbiAgICAgICAgdmFyIGNpcmNsZUJvdW5kID0gZGF0YS5jaXJjbGVCb3VuZCxcbiAgICAgICAgICAgIGNvbG9ycyA9IGRhdGEudGhlbWUuY29sb3JzLFxuICAgICAgICAgICAgY2hhcnRCYWNrZ3JvdW5kID0gZGF0YS5jaGFydEJhY2tncm91bmQsXG4gICAgICAgICAgICBzZWN0b3JzID0gW107XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KGRhdGEuc2VjdG9yRGF0YSwgZnVuY3Rpb24oc2VjdG9yRGF0dW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGVyY2VudFZhbHVlID0gc2VjdG9yRGF0dW0ucGVyY2VudFZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBzZWN0b3IgPSB0aGlzLl9yZW5kZXJTZWN0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBwYXBlcjogcGFwZXIsXG4gICAgICAgICAgICAgICAgICAgIGNpcmNsZUJvdW5kOiBjaXJjbGVCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgYW5nbGVzOiBzZWN0b3JEYXR1bS5hbmdsZXMuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VjdG9yLmRhdGEoJ2luZGV4JywgaW5kZXgpO1xuICAgICAgICAgICAgc2VjdG9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IHNlY3RvcixcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgYW5nbGVzOiBzZWN0b3JEYXR1bS5hbmdsZXMuZW5kLFxuICAgICAgICAgICAgICAgIHBlcmNlbnRWYWx1ZTogcGVyY2VudFZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zZWN0b3JzID0gc2VjdG9ycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxlZ2VuZCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvblxuICAgICAqL1xuICAgIHJlbmRlckxlZ2VuZExpbmVzOiBmdW5jdGlvbihvdXRlclBvc2l0aW9ucykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBwYXRocztcblxuICAgICAgICBpZiAodGhpcy5sZWdlbmRMaW5lcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSB0aGlzLl9tYWtlTGluZVBhdGhzKG91dGVyUG9zaXRpb25zKTtcbiAgICAgICAgdGhpcy5sZWdlbmRMaW5lcyA9IHR1aS51dGlsLm1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJhcGhhZWxSZW5kZXJVdGlsLnJlbmRlckxpbmUodGhhdC5wYXBlciwgcGF0aCwgJ3RyYW5zcGFyZW50JywgMSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxpbmUgcGF0aHMuXG4gICAgICogQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gb3V0ZXJQb3NpdGlvbnMgb3V0ZXIgcG9zaXRpb25zXG4gICAgICogQHJldHVybnMge0FycmF5fSBsaW5lIHBhdGhzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMaW5lUGF0aHM6IGZ1bmN0aW9uKG91dGVyUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBwYXRocyA9IHR1aS51dGlsLm1hcChvdXRlclBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb3NpdGlvbnMuc3RhcnQsIHBvc2l0aW9ucy5taWRkbGUpLFxuICAgICAgICAgICAgICAgIHJhcGhhZWxSZW5kZXJVdGlsLm1ha2VMaW5lUGF0aChwb3NpdGlvbnMubWlkZGxlLCBwb3NpdGlvbnMuZW5kKSxcbiAgICAgICAgICAgICAgICAnWidcbiAgICAgICAgICAgIF0uam9pbignJyk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kIHNlbGVjdG9yIHJhZGl1cy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VjdG9yIHBpZSBzZWN0b3JcbiAgICAgKi9cbiAgICBfZXhwYW5kU2VjdG9yOiBmdW5jdGlvbihzZWN0b3IpIHtcbiAgICAgICAgdmFyIGN4ID0gdGhpcy5jaXJjbGVCb3VuZC5jeCxcbiAgICAgICAgICAgIGN5ID0gdGhpcy5jaXJjbGVCb3VuZC5jeTtcblxuICAgICAgICBzZWN0b3IuYW5pbWF0ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICdzMS4xIDEuMSAnICsgY3ggKyAnICcgKyBjeVxuICAgICAgICB9LCBBTklNQVRJT05fVElNRSwgJ2VsYXN0aWMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBzZWxlY3RvciByYWRpdXMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlY3RvciBwaWUgc2VjdG9yXG4gICAgICovXG4gICAgX3Jlc3RvcmVTZWN0b3I6IGZ1bmN0aW9uKHNlY3Rvcikge1xuICAgICAgICBzZWN0b3IuYW5pbWF0ZSh7dHJhbnNmb3JtOiAnJ30sIEFOSU1BVElPTl9USU1FLCAnZWxhc3RpYycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhbmltYXRlIGV4cGFuZGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggc2VjdG9yIGluZGV4XG4gICAgICovXG4gICAgX2FuaW1hdGVFeHBhbmRpbmc6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnNlY3RvcnNbaW5kZXhdLnNlY3RvcjtcblxuICAgICAgICBpZiAodGhpcy5wcmV2TW92ZWRTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVSZXN0b3JpbmcodGhpcy5wcmV2TW92ZWRTZWN0b3IuZGF0YSgnaW5kZXgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9leHBhbmRTZWN0b3Ioc2VjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZSByZXN0b3JpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHNlY3RvciBpbmRleFxuICAgICAqL1xuICAgIF9hbmltYXRlUmVzdG9yaW5nOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5zZWN0b3JzW2luZGV4XS5zZWN0b3I7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVTZWN0b3Ioc2VjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFja1xuICAgICAqL1xuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkZWxheVRpbWUgPSAwLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQgPSB0aGlzLmNpcmNsZUJvdW5kO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBhbmdsZXMgPSBpdGVtLmFuZ2xlcyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25UaW1lLCBhbmltO1xuXG4gICAgICAgICAgICBpZiAoYW5nbGVzLnN0YXJ0QW5nbGUgPT09IDAgJiYgYW5nbGVzLmVuZEFuZ2xlID09PSAzNjApIHtcbiAgICAgICAgICAgICAgICBhbmdsZXMuZW5kQW5nbGUgPSAzNjAgLSAwLjAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmltYXRpb25UaW1lID0gTE9BRElOR19BTklNQVRJT05fVElNRSAqIGl0ZW0ucGVyY2VudFZhbHVlO1xuICAgICAgICAgICAgYW5pbSA9IHJhcGhhZWwuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgICAgICBzZWN0b3I6IFtjaXJjbGVCb3VuZC5jeCwgY2lyY2xlQm91bmQuY3ksIGNpcmNsZUJvdW5kLnIsIGFuZ2xlcy5zdGFydEFuZ2xlLCBhbmdsZXMuZW5kQW5nbGVdXG4gICAgICAgICAgICB9LCBhbmltYXRpb25UaW1lKTtcblxuICAgICAgICAgICAgaXRlbS5zZWN0b3IuYW5pbWF0ZShhbmltLmRlbGF5KGRlbGF5VGltZSkpO1xuICAgICAgICAgICAgZGVsYXlUaW1lICs9IGFuaW1hdGlvblRpbWU7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgZGVsYXlUaW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGxlZ2VuZCBsaW5lcy5cbiAgICAgKi9cbiAgICBhbmltYXRlTGVnZW5kTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmxlZ2VuZExpbmVzLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBsaW5lLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgZ3JhcGggb2YgcGllIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3tjeDpudW1iZXIsIGN5Om51bWJlciwgcjogbnVtYmVyfX0gcGFyYW1zLmNpcmNsZUJvdW5kIGNpcmNsZSBib3VuZFxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBwYXJhbXMuZGltZW5zaW9uLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQgPSBwYXJhbXMuY2lyY2xlQm91bmQ7XG5cbiAgICAgICAgdGhpcy5jaXJjbGVCb3VuZCA9IGNpcmNsZUJvdW5kO1xuICAgICAgICB0aGlzLnBhcGVyLnNldFNpemUoZGltZW5zaW9uLndpZHRoLCBkaW1lbnNpb24uaGVpZ2h0KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVyQm91bmQ7XG5cbiAgICAgICAgdHVpLnV0aWwuZm9yRWFjaEFycmF5KHRoaXMuc2VjdG9ycywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlcyA9IGl0ZW0uYW5nbGVzO1xuICAgICAgICAgICAgaXRlbS5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICAgICAgc2VjdG9yOiBbY2lyY2xlQm91bmQuY3gsIGNpcmNsZUJvdW5kLmN5LCBjaXJjbGVCb3VuZC5yLCBhbmdsZXMuc3RhcnRBbmdsZSwgYW5nbGVzLmVuZEFuZ2xlXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGxlZ2VuZCBsaW5lcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBvdXRlclBvc2l0aW9ucyBvdXRlciBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBtb3ZlTGVnZW5kTGluZXM6IGZ1bmN0aW9uKG91dGVyUG9zaXRpb25zKSB7XG4gICAgICAgIHZhciBwYXRocztcblxuICAgICAgICBpZiAoIXRoaXMubGVnZW5kTGluZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGhzID0gdGhpcy5fbWFrZUxpbmVQYXRocyhvdXRlclBvc2l0aW9ucyk7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLmxlZ2VuZExpbmVzLCBmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuICAgICAgICAgICAgbGluZS5hdHRyKHtwYXRoOiBwYXRoc1tpbmRleF19KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIGNsaWNrU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApO1xuXG4gICAgICAgIGlmIChzZWN0b3IgJiYgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2VsZWN0U2VyaWVzKHRoaXMucHJldlNlbGVjdGVkU2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJldlNlbGVjdGVkU2VjdG9yID09PSBzZWN0b3IpIHtcbiAgICAgICAgICAgIHNlY3RvciA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3I7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RTZXJpZXMoc2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0ZWRTZWN0b3IgPSBzZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGNvbnRhaW5lciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBjb250YWluZXIgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDb250YWluZXJCb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckJvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoYW5nZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmVzdWx0IGJvb2xlYW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRQb3NpdGlvbjogZnVuY3Rpb24ocHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gIXByZXZQb3NpdGlvbiB8fCBwcmV2UG9zaXRpb24ubGVmdCAhPT0gcG9zaXRpb24ubGVmdCB8fCBwcmV2UG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi50b3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgbW91c2Ugb24gc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG1vdmVNb3VzZU9uU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgc2VjdG9yID0gdGhpcy5wYXBlci5nZXRFbGVtZW50QnlQb2ludChwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3ApLFxuICAgICAgICAgICAgY29udGFpbmVyQm91bmQsIGFyZ3MsIGNoYW5nZWRTZWN0b3I7XG5cbiAgICAgICAgaWYgKHNlY3RvciAmJiB0aGlzLnNlY3RvcnNbc2VjdG9yLmRhdGEoJ2luZGV4JyldKSB7XG4gICAgICAgICAgICBjb250YWluZXJCb3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCk7XG4gICAgICAgICAgICBjaGFuZ2VkU2VjdG9yID0gdGhpcy5wcmV2TW92ZWRTZWN0b3IgIT09IHNlY3RvcjtcbiAgICAgICAgICAgIGFyZ3MgPSBbe30sIDAsIHNlY3Rvci5kYXRhKCdpbmRleCcpLCB7XG4gICAgICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGNvbnRhaW5lckJvdW5kLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBjb250YWluZXJCb3VuZC50b3BcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZFNlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVFeHBhbmRpbmcoc2VjdG9yLmRhdGEoJ2luZGV4JykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkUG9zaXRpb24odGhpcy5wcmV2UG9zaXRpb24sIHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZ1bmNTaG93VG9vbHRpcC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZNb3ZlZFNlY3RvciA9IHNlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZNb3ZlZFNlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVJlc3RvcmluZyh0aGlzLnByZXZNb3ZlZFNlY3Rvci5kYXRhKCdpbmRleCcpKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZ1bmNIaWRlVG9vbHRpcCgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2TW92ZWRTZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuc2VjdG9yc1tpbmRleF0sXG4gICAgICAgICAgICBvYmpDb2xvciA9IHJhcGhhZWwuY29sb3IoaXRlbS5jb2xvciksXG4gICAgICAgICAgICBjb2xvciA9IHRoaXMuc2VsZWN0aW9uQ29sb3IgfHwgcmFwaGFlbFJlbmRlclV0aWwubWFrZUNoYW5nZWRMdW1pbmFuY2VDb2xvcihvYmpDb2xvci5oZXgsIDAuMik7XG5cbiAgICAgICAgaXRlbS5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBjb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5lbGVjdCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5zZWxlY3RTZXJpZXM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBzZWN0b3IgPSB0aGlzLnNlY3RvcnNbaW5kZXhdO1xuXG4gICAgICAgIHNlY3Rvci5zZWN0b3IuYXR0cih7XG4gICAgICAgICAgICBmaWxsOiBzZWN0b3IuY29sb3JcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBzZWxlY3RMZWdlbmQ6IGZ1bmN0aW9uKGxlZ2VuZEluZGV4KSB7XG4gICAgICAgIHZhciBpc051bGwgPSB0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheSh0aGlzLnNlY3RvcnMsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eTtcblxuICAgICAgICAgICAgb3BhY2l0eSA9IChpc051bGwgfHwgbGVnZW5kSW5kZXggPT09IGluZGV4KSA/IEVNUEhBU0lTX09QQUNJVFkgOiBERV9FTVBIQVNJU19PUEFDSVRZO1xuXG4gICAgICAgICAgICBpdGVtLnNlY3Rvci5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5Jzogb3BhY2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhcGhhZWxQaWVDaGFydDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBVdGlsIGZvciByYXBoYWVsIHJlbmRlcmluZy5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsIGZvciByYXBoYWVsIHJlbmRlcmluZy5cbiAqIEBtb2R1bGUgcmFwaGFlbFJlbmRlclV0aWxcbiAqL1xudmFyIHJhcGhhZWxSZW5kZXJVdGlsID0ge1xuICAgIC8qKlxuICAgICAqIE1ha2UgbGluZSBwYXRoLlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6cmFwaGFlbFJlbmRlclV0aWxcbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gZnJvbVBvcyBmcm9tIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHRvUG9zIHRvIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGF0aFxuICAgICAqL1xuICAgIG1ha2VMaW5lUGF0aDogZnVuY3Rpb24oZnJvbVBvcywgdG9Qb3MsIHdpZHRoKSB7XG4gICAgICAgIHZhciBmcm9tUG9pbnQgPSBbZnJvbVBvcy5sZWZ0LCBmcm9tUG9zLnRvcF0sXG4gICAgICAgICAgICB0b1BvaW50ID0gW3RvUG9zLmxlZnQsIHRvUG9zLnRvcF07XG5cbiAgICAgICAgd2lkdGggPSB3aWR0aCB8fCAxO1xuXG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShmcm9tUG9pbnQsIGZ1bmN0aW9uKGZyb20sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG9Qb2ludFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBmcm9tUG9pbnRbaW5kZXhdID0gdG9Qb2ludFtpbmRleF0gPSBNYXRoLnJvdW5kKGZyb20pIC0gKHdpZHRoICUgMiAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsnTSddLmNvbmNhdChmcm9tUG9pbnQpLmNvbmNhdCgnTCcpLmNvbmNhdCh0b1BvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGxpbmUuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpyYXBoYWVsUmVuZGVyVXRpbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXBlciByYXBoYWVsIHBhcGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggbGluZSBwYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGxpbmUgY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3Ryb2tlV2lkdGggc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybnMge29iamVjdH0gcmFwaGFlbCBsaW5lXG4gICAgICovXG4gICAgcmVuZGVyTGluZTogZnVuY3Rpb24ocGFwZXIsIHBhdGgsIGNvbG9yLCBzdHJva2VXaWR0aCkge1xuICAgICAgICB2YXIgbGluZSA9IHBhcGVyLnBhdGgoW3BhdGhdKSxcbiAgICAgICAgICAgIHN0cm9rZVN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogY29sb3IsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHN0cm9rZVdpZHRoIHx8IDJcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICBzdHJva2VTdHlsZS5zdHJva2UgPSAnI2ZmZic7XG4gICAgICAgICAgICBzdHJva2VTdHlsZVsnc3Ryb2tlLW9wYWNpdHknXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGluZS5hdHRyKHN0cm9rZVN0eWxlKTtcblxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGFyZWEgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcGVyIHBhcGVyXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IHN0cmluZ319IHBhdGggcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBvcGFjaXR5IGZpbGwgb3BhY2l0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VDb2xvciBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IHN0cm9rZU9wYWNpdHkgc3Ryb2tlIG9wYWNpdHlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHJhcGhhZWwgb2JqZWN0XG4gICAgICovXG4gICAgcmVuZGVyQXJlYTogZnVuY3Rpb24ocGFwZXIsIHBhdGgsIGNvbG9yLCBvcGFjaXR5LCBzdHJva2VDb2xvciwgc3Ryb2tlT3BhY2l0eSkge1xuICAgICAgICB2YXIgYXJlYSA9IHBhcGVyLnBhdGgocGF0aCksXG4gICAgICAgICAgICBmaWxsU3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgICAgICdzdHJva2Utb3BhY2l0eSc6IHN0cm9rZU9wYWNpdHkgfHwgMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBhcmVhLmF0dHIoZmlsbFN0eWxlKTtcblxuICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGl0ZW1zIG9mIGxpbmUgdHlwZSBjaGFydC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGdyb3VwSXRlbXMgZ3JvdXAgaXRlbXNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVySXRlbSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZvckVhY2gyZEFycmF5OiBmdW5jdGlvbihncm91cEl0ZW1zLCBmdW5jUmVuZGVySXRlbSkge1xuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkoZ3JvdXBJdGVtcywgZnVuY3Rpb24oaXRlbXMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShpdGVtcywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBmdW5jUmVuZGVySXRlbShpdGVtLCBncm91cEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgY2hhbmdlZCBsdW1pbmFuY2UgY29sb3IuXG4gICAgICogaHR0cDovL3d3dy5zaXRlcG9pbnQuY29tL2phdmFzY3JpcHQtZ2VuZXJhdGUtbGlnaHRlci1kYXJrZXItY29sb3IvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhleCBoYXggY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbHVtIGx1bWluYW5jZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNoYW5nZWQgY29sb3JcbiAgICAgKi9cbiAgICBtYWtlQ2hhbmdlZEx1bWluYW5jZUNvbG9yOiBmdW5jdGlvbiAoaGV4LCBsdW0pIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgaGV4IHN0cmluZ1xuICAgICAgICBoZXggPSBTdHJpbmcoaGV4KS5yZXBsYWNlKC9bXjAtOWEtZl0vZ2ksICcnKTtcblxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIGhleCA9IGhleFswXSArIGhleFswXSArIGhleFsxXSArIGhleFsxXSArIGhleFsyXSArIGhleFsyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGx1bSA9IGx1bSB8fCAwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gZGVjaW1hbCBhbmQgY2hhbmdlIGx1bWlub3NpdHlcbiAgICAgICAgcmV0dXJuICcjJyArIHR1aS51dGlsLm1hcCh0dWkudXRpbC5yYW5nZSgzKSwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpbmRleCAqIDIsIDIpLCAxNik7XG4gICAgICAgICAgICBjID0gTWF0aC5yb3VuZChNYXRoLm1pbihNYXRoLm1heCgwLCBjICsgKGMgKiBsdW0pKSwgMjU1KSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuICgnMDAnICsgYykuc3Vic3RyKGMubGVuZ3RoKTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSByYXBoYWVsUmVuZGVyVXRpbDtcbiIsImlmICghd2luZG93LkpTT04pIHtcbiAgICB3aW5kb3cuSlNPTiA9IHtcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHNKU09OKSB7IHJldHVybiBldmFsKCcoJyArIHNKU09OICsgJyknKTsgfSxcbiAgICAgICAgc3RyaW5naWZ5OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbChhKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsgfTtcbiAgICAgICAgICAgIHZhciBlc2NNYXAgPSB7J1wiJzogJ1xcXFxcIicsICdcXFxcJzogJ1xcXFxcXFxcJywgJ1xcYic6ICdcXFxcYicsICdcXGYnOiAnXFxcXGYnLCAnXFxuJzogJ1xcXFxuJywgJ1xccic6ICdcXFxccicsICdcXHQnOiAnXFxcXHQnfTtcbiAgICAgICAgICAgIHZhciBlc2NGdW5jID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGVzY01hcFttXSB8fCAnXFxcXHUnICsgKG0uY2hhckNvZGVBdCgwKSArIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7IH07XG4gICAgICAgICAgICB2YXIgZXNjUkUgPSAvW1xcXFxcIlxcdTAwMDAtXFx1MDAxRlxcdTIwMjhcXHUyMDI5XS9nO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogJ251bGwnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KHZhbHVlLnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9ICdbJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IChpID8gJywgJyA6ICcnKSArIHN0cmluZ2lmeSh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goc3RyaW5naWZ5KGspICsgJzogJyArIHN0cmluZ2lmeSh2YWx1ZVtrXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd7JyArIHRtcC5qb2luKCcsICcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnXCInICsgdmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKGVzY1JFLCBlc2NGdW5jKSArICdcIic7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpXG4gICAgfTtcbn1cblxuLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcblxuLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci4gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuXG4vLyBNSVQgbGljZW5zZVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuL2NvbnN0JyksXG4gICAgY2hhcnRGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvY2hhcnRGYWN0b3J5JyksXG4gICAgQmFyQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9iYXJDaGFydCcpLFxuICAgIENvbHVtbkNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvY29sdW1uQ2hhcnQnKSxcbiAgICBMaW5lQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9saW5lQ2hhcnQnKSxcbiAgICBBcmVhQ2hhcnQgPSByZXF1aXJlKCcuL2NoYXJ0cy9hcmVhQ2hhcnQnKSxcbiAgICBDb21ib0NoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvY29tYm9DaGFydCcpLFxuICAgIFBpZUNoYXJ0ID0gcmVxdWlyZSgnLi9jaGFydHMvcGllQ2hhcnQnKSxcbiAgICBNYXBDaGFydCA9IHJlcXVpcmUoJy4vY2hhcnRzL21hcENoYXJ0Jyk7XG5cbmNoYXJ0RmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkNIQVJUX1RZUEVfQkFSLCBCYXJDaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX0NPTFVNTiwgQ29sdW1uQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9MSU5FLCBMaW5lQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9BUkVBLCBBcmVhQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9DT01CTywgQ29tYm9DaGFydCk7XG5jaGFydEZhY3RvcnkucmVnaXN0ZXIoY2hhcnRDb25zdC5DSEFSVF9UWVBFX1BJRSwgUGllQ2hhcnQpO1xuY2hhcnRGYWN0b3J5LnJlZ2lzdGVyKGNoYXJ0Q29uc3QuQ0hBUlRfVFlQRV9NQVAsIE1hcENoYXJ0KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuL2NvbnN0JyksXG4gICAgdGhlbWVGYWN0b3J5ID0gcmVxdWlyZSgnLi9mYWN0b3JpZXMvdGhlbWVGYWN0b3J5JyksXG4gICAgZGVmYXVsdFRoZW1lID0gcmVxdWlyZSgnLi90aGVtZXMvZGVmYXVsdFRoZW1lJyk7XG5cbnRoZW1lRmFjdG9yeS5yZWdpc3RlcihjaGFydENvbnN0LkRFRkFVTFRfVEhFTUVfTkFNRSwgZGVmYXVsdFRoZW1lKTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBBcmVhIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIExpbmVUeXBlU2VyaWVzQmFzZSA9IHJlcXVpcmUoJy4vbGluZVR5cGVTZXJpZXNCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0Jyk7XG5cbnZhciBBcmVhQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgQXJlYUNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQXJlYSBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIEFyZWFDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBtaXhlcyBMaW5lVHlwZVNlcmllc0Jhc2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBvc2l0aW9uIHRvcCBvZiB6ZXJvIHBvaW50LlxuICAgICAqIEBwYXJhbSB7e2hlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHRvcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvblRvcE9mWmVyb1BvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGxpbWl0ID0gdGhpcy5kYXRhLmxpbWl0LFxuICAgICAgICAgICAgbGltaXREaXN0YW5jZSA9IHRoaXMuX2dldExpbWl0RGlzdGFuY2VGcm9tWmVyb1BvaW50KGRpbWVuc2lvbi5oZWlnaHQsIGxpbWl0KSxcbiAgICAgICAgICAgIHRvcCA9IGxpbWl0RGlzdGFuY2UudG9NYXg7XG5cbiAgICAgICAgaWYgKGxpbWl0Lm1pbiA+PSAwICYmICF0b3ApIHtcbiAgICAgICAgICAgIHRvcCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9wICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3RhY2tlZCBwb3NpdGlvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBncm91cCBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gc3RhY2tlZCBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZFBvc2l0aW9uczogZnVuY3Rpb24oZ3JvdXBQb3NpdGlvbnMpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKS5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgIGZpcnN0U3RhcnRUb3AgPSB0aGlzLl9tYWtlUG9zaXRpb25Ub3BPZlplcm9Qb2ludCgpLFxuICAgICAgICAgICAgcHJldlBvc2l0aW9uVG9wcyA9IFtdO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VG9wID0gcHJldlBvc2l0aW9uVG9wc1tpbmRleF0gfHwgZmlyc3RTdGFydFRvcCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tlZEhlaWdodCA9IGhlaWdodCAtIHBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gcHJldlRvcCAtIHN0YWNrZWRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5zdGFydFRvcCA9IHByZXZUb3A7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24udG9wID0gdG9wO1xuXG4gICAgICAgICAgICAgICAgcHJldlBvc2l0aW9uVG9wc1tpbmRleF0gPSB0b3A7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG5vcm1hbCBwb3NpdGlvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT4+fSBncm91cFBvc2l0aW9ucyBncm91cCBwb3NpdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5Ljx7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn0+Pn0gc3RhY2tlZCBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsUG9zaXRpb25zOiBmdW5jdGlvbihncm91cFBvc2l0aW9ucykge1xuICAgICAgICB2YXIgc3RhcnRUb3AgPSB0aGlzLl9tYWtlUG9zaXRpb25Ub3BPZlplcm9Qb2ludCgpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAoZ3JvdXBQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uc3RhcnRUb3AgPSBzdGFydFRvcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBzdGFydFRvcDogbnVtYmVyfT4+fSBzdGFja2VkIHBvc2l0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvbnMgPSB0aGlzLl9tYWtlQmFzaWNQb3NpdGlvbnMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrZWQpIHtcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25zID0gdGhpcy5fbWFrZVN0YWNrZWRQb3NpdGlvbnMoZ3JvdXBQb3NpdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnMgPSB0aGlzLl9tYWtlTm9ybWFsUG9zaXRpb25zKGdyb3VwUG9zaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cFBvc2l0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIHplcm9Ub3AgPSB0aGlzLl9nZXRMaW1pdERpc3RhbmNlRnJvbVplcm9Qb2ludChkaW1lbnNpb24uaGVpZ2h0LCB0aGlzLmRhdGEubGltaXQpLnRvTWF4O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cFBvc2l0aW9uczogdGhpcy5fbWFrZVBvc2l0aW9ucygpLFxuICAgICAgICAgICAgemVyb1RvcDogemVyb1RvcCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbkxpbmVUeXBlU2VyaWVzQmFzZS5taXhpbihBcmVhQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFyZWFDaGFydFNlcmllcztcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBCYXIgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgQmFyVHlwZVNlcmllc0Jhc2UgPSByZXF1aXJlKCcuL2JhclR5cGVTZXJpZXNCYXNlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgY2FsY3VsYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2FsY3VsYXRvcicpO1xuXG52YXIgQmFyQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgQmFyQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBCYXIgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBCYXJDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmQgb2YgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7dG9wOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJhc2VCb3VuZCBiYXNlIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0TGVmdCBzdGFydCBsZWZ0XG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZExlZnQgZW5kIGxlZnRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kV2lkdGggZW5kIHdpZHRoXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gY29sdW1uIGNoYXJ0IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhckNoYXJ0Qm91bmQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgbGVmdDogcGFyYW1zLnN0YXJ0TGVmdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfSwgcGFyYW1zLmJhc2VCb3VuZCksXG4gICAgICAgICAgICBlbmQ6IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgbGVmdDogcGFyYW1zLmVuZExlZnQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmFtcy5lbmRXaWR0aFxuICAgICAgICAgICAgfSwgcGFyYW1zLmJhc2VCb3VuZClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBub3JtYWwgYmFyIGNoYXJ0IGJvdW5kLlxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZ3JvdXBWYWx1ZXM6IEFycmF5LjxBcnJheS48bnVtYmVyPj4sXG4gICAgICogICAgICBncm91cFNpemU6IG51bWJlciwgYmFyU2l6ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIsXG4gICAgICogICAgICBkaXN0YW5jZVRvTWluOiBudW1iZXIsIGlzTWludXM6IGJvb2xlYW5cbiAgICAgKiB9fSBiYXNlSW5mbyBiYXNlIGluZm9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1RvcCBwYWRkaW5nIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBzdGFydDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGVuZDoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfVxuICAgICAqIH19IGNvbHVtbiBjaGFydCBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxCYXJDaGFydEJvdW5kOiBmdW5jdGlvbihiYXNlSW5mbywgdmFsdWUsIHBhZGRpbmdUb3AsIGluZGV4KSB7XG4gICAgICAgIHZhciBzdGFydExlZnQsIGVuZFdpZHRoLCBib3VuZCwgYmFzZUJvdW5kO1xuXG4gICAgICAgIHN0YXJ0TGVmdCA9IGJhc2VJbmZvLmRpc3RhbmNlLnRvTWluICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgIGVuZFdpZHRoID0gTWF0aC5hYnModmFsdWUgKiBiYXNlSW5mby5kaW1lbnNpb24ud2lkdGgpO1xuICAgICAgICBiYXNlQm91bmQgPSB7XG4gICAgICAgICAgICB0b3A6IHBhZGRpbmdUb3AgKyAoKGJhc2VJbmZvLnN0ZXApICogaW5kZXgpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICBoZWlnaHQ6IGJhc2VJbmZvLmJhclNpemVcbiAgICAgICAgfTtcbiAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlQmFyQ2hhcnRCb3VuZCh7XG4gICAgICAgICAgICBiYXNlQm91bmQ6IGJhc2VCb3VuZCxcbiAgICAgICAgICAgIHN0YXJ0TGVmdDogc3RhcnRMZWZ0LFxuICAgICAgICAgICAgZW5kTGVmdDogc3RhcnRMZWZ0ICsgKHZhbHVlIDwgMCA/IC1lbmRXaWR0aCA6IDApLFxuICAgICAgICAgICAgZW5kV2lkdGg6IGVuZFdpZHRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgb2Ygbm9ybWFsIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGJhciBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU5vcm1hbEJhckNoYXJ0Qm91bmRzOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIGJhc2VJbmZvID0gdGhpcy5fbWFrZUJhc2VJbmZvRm9yTm9ybWFsQ2hhcnRCb3VuZHMoZGltZW5zaW9uLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLl9tYWtlTm9ybWFsQm91bmRzKGJhc2VJbmZvLCB0dWkudXRpbC5iaW5kKHRoaXMuX21ha2VOb3JtYWxCYXJDaGFydEJvdW5kLCB0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZHMgb2Ygc3RhY2tlZCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBiYXIgY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkQmFyQ2hhcnRCb3VuZHM6IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICBiYXNlSW5mbyA9IHRoaXMuX21ha2VCYXNlSW5mb0ZvclN0YWNrZWRDaGFydEJvdW5kcyhkaW1lbnNpb24sICd3aWR0aCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlU3RhY2tlZEJvdW5kcyhkaW1lbnNpb24sIGJhc2VJbmZvLCBmdW5jdGlvbihiYXNlQm91bmQsIGVuZFNpemUsIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5fbWFrZUJhckNoYXJ0Qm91bmQoe1xuICAgICAgICAgICAgICAgIGJhc2VCb3VuZDogYmFzZUJvdW5kLFxuICAgICAgICAgICAgICAgIHN0YXJ0TGVmdDogYmFzZUluZm8uZGlzdGFuY2UudG9NaW4gKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICBlbmRMZWZ0OiBiYXNlSW5mby5kaXN0YW5jZS50b01pbiArIGVuZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGVuZFdpZHRoOiBlbmRTaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIG9mIGJhciBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGJhciBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBib3VuZHM7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tlZE9wdGlvbih0aGlzLm9wdGlvbnMuc3RhY2tlZCkpIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX21ha2VTdGFja2VkQmFyQ2hhcnRCb3VuZHMoZGltZW5zaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX21ha2VOb3JtYWxCYXJDaGFydEJvdW5kcyhkaW1lbnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtvYmVqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWx1ZSB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6bnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICovXG4gICAgbWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChwYXJhbXMuZm9ybWF0dGVkVmFsdWUsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdCxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCArIChib3VuZC5oZWlnaHQgLSBwYXJhbXMubGFiZWxIZWlnaHQgKyBjaGFydENvbnN0LlRFWFRfUEFERElORykgLyAyO1xuXG4gICAgICAgIGlmIChwYXJhbXMudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgbGVmdCArPSBib3VuZC53aWR0aCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0IC09IGxhYmVsV2lkdGggKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc3VtIGxhYmVsIHRvcCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgYm91bmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn0gdG9wIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlU3VtTGFiZWxUb3BQb3NpdGlvbjogZnVuY3Rpb24oYm91bmQsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBib3VuZC50b3AgKyAoKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGx1cyBzdW0gbGFiZWwgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgc3VtIGxhYmVsIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGx1c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0dGVkU3VtLFxuICAgICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgc3VtID0gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyk7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdW0gPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpKTtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGggKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlU3VtTGFiZWxUb3BQb3NpdGlvbihib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBtaW51cyBzdW0gbGFiZWwgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgbWludXMgbGFiZWwgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0dGVkU3VtLCBsYWJlbFdpZHRoLFxuICAgICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgc3VtID0gY2FsY3VsYXRvci5zdW1NaW51c1ZhbHVlcyh2YWx1ZXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpdmVyZ2luZykge1xuICAgICAgICAgICAgICAgIHN1bSA9IE1hdGguYWJzKHN1bSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdHRlZFN1bSA9IHJlbmRlclV0aWwuZm9ybWF0VmFsdWUoc3VtLCB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0RnVuY3Rpb25zKCkpO1xuICAgICAgICAgICAgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGZvcm1hdHRlZFN1bSwgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgICAgICBodG1sID0gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogYm91bmQubGVmdCAtIGxhYmVsV2lkdGggLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HLFxuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5fY2FsY3VsYXRlU3VtTGFiZWxUb3BQb3NpdGlvbihib3VuZCwgbGFiZWxIZWlnaHQpXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4oQmFyQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhckNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbHVtbiBjaGFydCBzZXJpZXMgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgQmFyVHlwZVNlcmllc0Jhc2UgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEJhclR5cGVTZXJpZXNCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBhZGQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncm91cEJvdW5kcyA9IHRoaXMuX21ha2VCb3VuZHModGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBCb3VuZHM6IHRoaXMuZ3JvdXBCb3VuZHMsXG4gICAgICAgICAgICBncm91cFZhbHVlczogdGhpcy5fZ2V0UGVyY2VudFZhbHVlcygpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFyIGd1dHRlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGl0ZW1Db3VudCBncm91cCBpdGVtIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn0gYmFyIGd1dHRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXJHdXR0ZXI6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgaXRlbUNvdW50KSB7XG4gICAgICAgIHZhciBiYXNlU2l6ZSA9IGdyb3VwU2l6ZSAvIChpdGVtQ291bnQgKyAxKSAvIDIsXG4gICAgICAgICAgICBndXR0ZXI7XG5cbiAgICAgICAgaWYgKGJhc2VTaXplIDw9IDIpIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZVNpemUgPD0gNikge1xuICAgICAgICAgICAgZ3V0dGVyID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGd1dHRlciA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGd1dHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBiYXIgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ3JvdXBTaXplIGJhciBncm91cCBzaXplXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhckd1dHRlciBiYXIgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgZ3JvdXAgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGJhciBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhclNpemU6IGZ1bmN0aW9uKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIChncm91cFNpemUgLSAoYmFyR3V0dGVyICogKGl0ZW1Db3VudCAtIDEpKSkgLyAoaXRlbUNvdW50ICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugb3B0aW9uIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG9wdGlvbkJhcldpZHRoIGJhcldpZHRoIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IG9wdGlvbiBzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU9wdGlvblNpemU6IGZ1bmN0aW9uKGJhclNpemUsIG9wdGlvbkJhcldpZHRoKSB7XG4gICAgICAgIHZhciBvcHRpb25zU2l6ZSA9IDA7XG4gICAgICAgIGlmIChvcHRpb25CYXJXaWR0aCkge1xuICAgICAgICAgICAgb3B0aW9uc1NpemUgPSB0dWkudXRpbC5taW4oW2JhclNpemUsIG9wdGlvbkJhcldpZHRoXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNTaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGFkZGl0aW9uIHBhZGRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhclNpemUgYmFyIHNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9uU2l6ZSBvcHRpb24gc2l6ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVtQ291bnQgaXRlbSBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFkZGl0aW9uIHBhZGRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlQWRkaXRpb25QYWRkaW5nOiBmdW5jdGlvbihiYXJTaXplLCBvcHRpb25TaXplLCBpdGVtQ291bnQpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSAwO1xuXG4gICAgICAgIGlmIChvcHRpb25TaXplICYmIG9wdGlvblNpemUgPCBiYXJTaXplKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gKGJhclNpemUgLSBvcHRpb25TaXplKSAqIGl0ZW1Db3VudCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGJhclNpemUgLyAyKSArIHBhZGRpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYmFzZSBpbmZvIGZvciBub3JtYWwgY2hhcnQgYm91bmRzLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIHNlcmllcyBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2l6ZVR5cGUgc2l6ZSB0eXBlICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFub3RoZXJTaXplVHlwZSBhbm90aGVyIHNpemUgdHlwZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBncm91cFZhbHVlczogQXJyYXkuPEFycmF5LjxudW1iZXI+PixcbiAgICAgKiAgICAgIGdyb3VwU2l6ZTogbnVtYmVyLCBiYXJTaXplOiBudW1iZXIsIHN0ZXA6IG51bWJlcixcbiAgICAgKiAgICAgIGRpc3RhbmNlVG9NaW46IG51bWJlciwgaXNNaW51czogYm9vbGVhblxuICAgICAqIH19IGJhc2UgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlSW5mb0Zvck5vcm1hbENoYXJ0Qm91bmRzOiBmdW5jdGlvbihkaW1lbnNpb24sIHNpemVUeXBlLCBhbm90aGVyU2l6ZVR5cGUpIHtcbiAgICAgICAgdmFyIGdyb3VwVmFsdWVzID0gdGhpcy5fZ2V0UGVyY2VudFZhbHVlcygpLFxuICAgICAgICAgICAgZ3JvdXBTaXplID0gZGltZW5zaW9uW2Fub3RoZXJTaXplVHlwZV0gLyBncm91cFZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgICBpdGVtQ291bnQgPSBncm91cFZhbHVlc1swXSAmJiBncm91cFZhbHVlc1swXS5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgIGJhckd1dHRlciA9IHRoaXMuX21ha2VCYXJHdXR0ZXIoZ3JvdXBTaXplLCBpdGVtQ291bnQpLFxuICAgICAgICAgICAgYmFyU2l6ZSA9IHRoaXMuX21ha2VCYXJTaXplKGdyb3VwU2l6ZSwgYmFyR3V0dGVyLCBpdGVtQ291bnQpLFxuICAgICAgICAgICAgb3B0aW9uU2l6ZSA9IHRoaXMuX21ha2VPcHRpb25TaXplKGJhclNpemUsIHRoaXMub3B0aW9ucy5iYXJXaWR0aCksXG4gICAgICAgICAgICBhZGRpdGlvblBhZGRpbmcgPSB0aGlzLl9tYWtlQWRkaXRpb25QYWRkaW5nKGJhclNpemUsIG9wdGlvblNpemUsIGl0ZW1Db3VudCksXG4gICAgICAgICAgICBsaW1pdERpc3RhbmNlID0gdGhpcy5fZ2V0TGltaXREaXN0YW5jZUZyb21aZXJvUG9pbnQoZGltZW5zaW9uW3NpemVUeXBlXSwgdGhpcy5kYXRhLmxpbWl0KTtcblxuICAgICAgICBiYXJTaXplID0gb3B0aW9uU2l6ZSB8fCBiYXJTaXplO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IGRpbWVuc2lvbixcbiAgICAgICAgICAgIGdyb3VwU2l6ZTogZ3JvdXBTaXplLFxuICAgICAgICAgICAgYmFyU2l6ZTogYmFyU2l6ZSxcbiAgICAgICAgICAgIGFkZGl0aW9uUGFkZGluZzogYWRkaXRpb25QYWRkaW5nLFxuICAgICAgICAgICAgc3RlcDogYmFyU2l6ZSArIGJhckd1dHRlcixcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsaW1pdERpc3RhbmNlLFxuICAgICAgICAgICAgaXNNaW51czogdGhpcy5kYXRhLmxpbWl0Lm1pbiA8IDAgJiYgdGhpcy5kYXRhLmxpbWl0Lm1heCA8PSAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugbm9ybWFsIGJvdW5kcy5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIGdyb3VwVmFsdWVzOiBBcnJheS48QXJyYXkuPG51bWJlcj4+LFxuICAgICAqICAgICAgZ3JvdXBTaXplOiBudW1iZXIsIGJhclNpemU6IG51bWJlciwgc3RlcDogbnVtYmVyLFxuICAgICAqICAgICAgZGlzdGFuY2VUb01pbjogbnVtYmVyLCBpc01pbnVzOiBib29sZWFuXG4gICAgICogfX0gYmFzZUluZm8gYmFzZSBpbmZvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgaXRlcmF0ZWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxCb3VuZHM6IGZ1bmN0aW9uKGJhc2VJbmZvLCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuX2dldFBlcmNlbnRWYWx1ZXMoKSwgZnVuY3Rpb24odmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IChiYXNlSW5mby5ncm91cFNpemUgKiBncm91cEluZGV4KSArIGJhc2VJbmZvLmFkZGl0aW9uUGFkZGluZztcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGJhc2VJbmZvLCB2YWx1ZSwgcGFkZGluZywgaW5kZXgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJhc2UgaW5mbyBmb3Igc3RhY2tlZCBjaGFydCBib3VuZHMuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpemVUeXBlIHNpemUgdHlwZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEByZXR1cm5zIHt7Z3JvdXBTaXplOiAobnVtYmVyKSwgYmFzZUJvdW5kOiBvYmplY3QsIGFkZGl0aW9uUGFkZGluZzogbnVtYmVyLCBkaW1lbnNpb25TaXplOiBudW1iZXIsIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBiYXNlRW5kUG9zaXRpb246IG51bWJlcn19IGJhc2UgaW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VCYXNlSW5mb0ZvclN0YWNrZWRDaGFydEJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uLCBzaXplVHlwZSkge1xuICAgICAgICB2YXIgbGltaXREaXN0YW5jZSA9IHRoaXMuX2dldExpbWl0RGlzdGFuY2VGcm9tWmVyb1BvaW50KGRpbWVuc2lvbltzaXplVHlwZV0sIHRoaXMuZGF0YS5saW1pdCksXG4gICAgICAgICAgICBiYXNlQm91bmQgPSB7fSxcbiAgICAgICAgICAgIGdyb3VwU2l6ZSwgYmFyV2lkdGgsIG9wdGlvbldpZHRoLCBhZGRpdGlvblBhZGRpbmcsXG4gICAgICAgICAgICBhbm90aGVyU2l6ZVR5cGUsIHBvc2l0aW9uVG9wLCBiYXNlRW5kUG9zaXRpb247XG5cbiAgICAgICAgaWYgKHNpemVUeXBlID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgYW5vdGhlclNpemVUeXBlID0gJ3dpZHRoJztcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID0gJ2xlZnQnO1xuICAgICAgICAgICAgYmFzZUVuZFBvc2l0aW9uID0gLWNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5vdGhlclNpemVUeXBlID0gJ2hlaWdodCc7XG4gICAgICAgICAgICBwb3NpdGlvblRvcCA9ICd0b3AnO1xuICAgICAgICAgICAgYmFzZUVuZFBvc2l0aW9uID0gY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkU7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cFNpemUgPSAoZGltZW5zaW9uW2Fub3RoZXJTaXplVHlwZV0gLyB0aGlzLl9nZXRQZXJjZW50VmFsdWVzKCkubGVuZ3RoKTtcbiAgICAgICAgYmFyV2lkdGggPSBncm91cFNpemUgLyAyO1xuICAgICAgICBvcHRpb25XaWR0aCA9IHRoaXMuX21ha2VPcHRpb25TaXplKGJhcldpZHRoLCB0aGlzLm9wdGlvbnMuYmFyV2lkdGgpO1xuICAgICAgICBhZGRpdGlvblBhZGRpbmcgPSB0aGlzLl9tYWtlQWRkaXRpb25QYWRkaW5nKGJhcldpZHRoLCBvcHRpb25XaWR0aCwgMSk7XG4gICAgICAgIGJhc2VCb3VuZFthbm90aGVyU2l6ZVR5cGVdID0gb3B0aW9uV2lkdGggfHwgYmFyV2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyb3VwU2l6ZTogZ3JvdXBTaXplLFxuICAgICAgICAgICAgYmFzZUJvdW5kOiBiYXNlQm91bmQsXG4gICAgICAgICAgICBhZGRpdGlvblBhZGRpbmc6IGFkZGl0aW9uUGFkZGluZyArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgZGltZW5zaW9uU2l6ZTogZGltZW5zaW9uW3NpemVUeXBlXSxcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogcG9zaXRpb25Ub3AsXG4gICAgICAgICAgICBiYXNlRW5kUG9zaXRpb246IGJhc2VFbmRQb3NpdGlvbixcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsaW1pdERpc3RhbmNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIG9mIHN0YWNrZWQgY29sdW1uIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBkaW1lbnNpb24gY29sdW1uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e2dyb3VwU2l6ZTogKG51bWJlciksIGJhc2VCb3VuZDogb2JqZWN0LCBhZGRpdGlvblBhZGRpbmc6IG51bWJlciwgZGltZW5zaW9uU2l6ZTogbnVtYmVyLCBwb3NpdGlvblR5cGU6IHN0cmluZywgYmFzZUVuZFBvc2l0aW9uOiBudW1iZXJ9fSBiYXNlSW5mbyBiYXNlIGluZm9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYWtlQm91bmRGdW5jIG1ha2UgYm91bmQgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN0YWNrZWRCb3VuZHM6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgYmFzZUluZm8sIG1ha2VCb3VuZEZ1bmMpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHR1aS51dGlsLm1hcCh0aGlzLl9nZXRQZXJjZW50VmFsdWVzKCksIGZ1bmN0aW9uKHZhbHVlcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSAoYmFzZUluZm8uZ3JvdXBTaXplICogZ3JvdXBJbmRleCkgKyBiYXNlSW5mby5hZGRpdGlvblBhZGRpbmcsXG4gICAgICAgICAgICAgICAgZW5kUGx1c1Bvc2l0aW9uID0gYmFzZUluZm8uYmFzZUVuZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGVuZE1pbnVzUG9zaXRpb24gPSBiYXNlSW5mby5iYXNlRW5kUG9zaXRpb247XG5cbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmRTaXplID0gTWF0aC5hYnModmFsdWUgKiBiYXNlSW5mby5kaW1lbnNpb25TaXplKTtcbiAgICAgICAgICAgICAgICBiYXNlSW5mby5iYXNlQm91bmRbYmFzZUluZm8ucG9zaXRpb25UeXBlXSA9IHBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZCA9IG1ha2VCb3VuZEZ1bmMoYmFzZUluZm8uYmFzZUJvdW5kLCBlbmRTaXplLCBlbmRQbHVzUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlbmRQbHVzUG9zaXRpb24gKz0gZW5kU2l6ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmRNaW51c1Bvc2l0aW9uIC09IGVuZFNpemU7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWFrZUJvdW5kRnVuYyhiYXNlSW5mby5iYXNlQm91bmQsIGVuZFNpemUsIGVuZE1pbnVzUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBib3VuZDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgbm9ybWFsIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFNlcmllc0xhYmVsQXJlYSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTm9ybWFsU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKGVsU2VyaWVzTGFiZWxBcmVhKSB7XG4gICAgICAgIHZhciBncm91cEJvdW5kcyA9IHRoaXMuc2VyaWVzRGF0YS5ncm91cEJvdW5kcyxcbiAgICAgICAgICAgIGZpcnN0Rm9ybWF0dGVkVmFsdWUgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rmlyc3RGb3JtYXR0ZWRWYWx1ZSh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICBsYWJlbEhlaWdodCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChmaXJzdEZvcm1hdHRlZFZhbHVlLCB0aGlzLnRoZW1lLmxhYmVsKSxcbiAgICAgICAgICAgIGh0bWw7XG5cbiAgICAgICAgaHRtbCA9IHR1aS51dGlsLm1hcCh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0R3JvdXBWYWx1ZXModGhpcy5jaGFydFR5cGUpLCBmdW5jdGlvbih2YWx1ZXMsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm91bmQsIGZvcm1hdHRlZFZhbHVlLCByZW5kZXJpbmdQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBib3VuZCA9IGdyb3VwQm91bmRzW2dyb3VwSW5kZXhdW2luZGV4XS5lbmQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0dGVkVmFsdWUoZ3JvdXBJbmRleCwgaW5kZXgsIHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgICAgICAgICByZW5kZXJpbmdQb3NpdGlvbiA9IHRoaXMubWFrZVNlcmllc1JlbmRlcmluZ1Bvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBib3VuZDogYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VTZXJpZXNMYWJlbEh0bWwocmVuZGVyaW5nUG9zaXRpb24sIGZvcm1hdHRlZFZhbHVlLCBncm91cEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcbiAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG5cbiAgICAgICAgZWxTZXJpZXNMYWJlbEFyZWEuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdW0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzdW0gcmVzdWx0LlxuICAgICAqL1xuICAgIF9tYWtlU3VtVmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgdmFyIHN1bSA9IHR1aS51dGlsLnN1bSh2YWx1ZXMpO1xuXG4gICAgICAgIHJldHVybiByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdGFja2VkIGxhYmVsIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYm91bmQgZWxlbWVudCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWRWYWx1ZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxIZWlnaHQgbGFiZWwgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZExhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGJvdW5kLCBmb3JtYXR0ZWRWYWx1ZSwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChmb3JtYXR0ZWRWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBsZWZ0ID0gYm91bmQubGVmdCArICgoYm91bmQud2lkdGggLSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMiksXG4gICAgICAgICAgICB0b3AgPSBib3VuZC50b3AgKyAoKGJvdW5kLmhlaWdodCAtIGxhYmVsSGVpZ2h0ICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN0YWNrZWQgbGFiZWxzIGh0bWwuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiAgICAgIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHBhcmFtcy5ib3VuZHMgYm91bmRzLFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBsYWJlbHMgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFja2VkTGFiZWxzSHRtbDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBwYXJhbXMudmFsdWVzLFxuICAgICAgICAgICAgbGFiZWxIZWlnaHQgPSBwYXJhbXMubGFiZWxIZWlnaHQsXG4gICAgICAgICAgICBodG1scywgcGx1c0JvdW5kLCBtaW51c0JvdW5kO1xuXG4gICAgICAgIGh0bWxzID0gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmRzW2luZGV4XSxcbiAgICAgICAgICAgICAgICBsYWJlbEh0bWwgPSAnJyxcbiAgICAgICAgICAgICAgICBib3VuZEVuZCwgZm9ybWF0dGVkVmFsdWUsIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAoYm91bmQgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBib3VuZEVuZCA9IGJvdW5kLmVuZDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXR0ZWRWYWx1ZShwYXJhbXMuZ3JvdXBJbmRleCwgaW5kZXgsIHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21ha2VTdGFja2VkTGFiZWxQb3NpdGlvbihib3VuZEVuZCwgZm9ybWF0dGVkVmFsdWUsIHBhcmFtcy5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgbGFiZWxIdG1sID0gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbChwb3NpdGlvbiwgZm9ybWF0dGVkVmFsdWUsIHBhcmFtcy5ncm91cEluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICBwbHVzQm91bmQgPSBib3VuZEVuZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWludXNCb3VuZCA9IGJvdW5kRW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxIdG1sO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrZWQgPT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMuX21ha2VQbHVzU3VtTGFiZWxIdG1sKHZhbHVlcywgcGx1c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICAgICAgaHRtbHMucHVzaCh0aGlzLl9tYWtlTWludXNTdW1MYWJlbEh0bWwodmFsdWVzLCBtaW51c0JvdW5kLCBsYWJlbEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc3RhY2tlZCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxTZXJpZXNMYWJlbEFyZWEgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclN0YWNrZWRTZXJpZXNMYWJlbDogZnVuY3Rpb24oZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIGdyb3VwQm91bmRzID0gdGhpcy5zZXJpZXNEYXRhLmdyb3VwQm91bmRzLFxuICAgICAgICAgICAgZ3JvdXBWYWx1ZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0R3JvdXBWYWx1ZXModGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgZmlyc3RGb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGaXJzdEZvcm1hdHRlZFZhbHVlKHRoaXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIGxhYmVsSGVpZ2h0ID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsSGVpZ2h0KGZpcnN0Rm9ybWF0dGVkVmFsdWUsIHRoaXMudGhlbWUubGFiZWwpLFxuICAgICAgICAgICAgaHRtbDtcblxuICAgICAgICBodG1sID0gdHVpLnV0aWwubWFwKGdyb3VwVmFsdWVzLCBmdW5jdGlvbih2YWx1ZXMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxzSHRtbCA9IHRoaXMuX21ha2VTdGFja2VkTGFiZWxzSHRtbCh7XG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYm91bmRzOiBncm91cEJvdW5kc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgbGFiZWxIZWlnaHQ6IGxhYmVsSGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNIdG1sO1xuICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICBlbFNlcmllc0xhYmVsQXJlYS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFja2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJTdGFja2VkU2VyaWVzTGFiZWwoZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTm9ybWFsU2VyaWVzTGFiZWwoZWxTZXJpZXNMYWJlbEFyZWEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkJhclR5cGVTZXJpZXNCYXNlLm1peGluID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgQmFyVHlwZVNlcmllc0Jhc2UucHJvdG90eXBlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFyVHlwZVNlcmllc0Jhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ29sdW1uIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIEJhclR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9iYXJUeXBlU2VyaWVzQmFzZScpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIGNhbGN1bGF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NhbGN1bGF0b3InKTtcblxudmFyIENvbHVtbkNoYXJ0U2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoU2VyaWVzLCAvKiogQGxlbmRzIENvbHVtbkNoYXJ0U2VyaWVzLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgQ29sdW1uQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFNlcmllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN0YXJ0IGVuZCB0b3BzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRUb3AgZW5kIHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRIZWlnaHQgZW5kIGhlaWdodFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNaW51cyB3aGV0aGVyIG1pbnVzIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7c3RhcnRUb3A6IG51bWJlciwgZW5kVG9wOiBudW1iZXJ9fSBzdGFydCBlbmQgdG9wc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTdGFydEVuZFRvcHM6IGZ1bmN0aW9uKGVuZFRvcCwgZW5kSGVpZ2h0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RhcnRUb3A7XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgc3RhcnRUb3AgPSBlbmRUb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFRvcCA9IGVuZFRvcDtcbiAgICAgICAgICAgIGVuZFRvcCAtPSBlbmRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRUb3A6IHN0YXJ0VG9wLFxuICAgICAgICAgICAgZW5kVG9wOiBlbmRUb3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBib3VuZCBvZiBjb2x1bW4gY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHdpZHRoOiBudW1iZXJ9fSBwYXJhbXMuYmFzZUJvdW5kIGJhc2UgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnRUb3Agc3RhcnQgdG9wXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZFRvcCBlbmQgdG9wXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZEhlaWdodCBlbmQgaGVpZ2h0XG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHN0YXJ0OiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgZW5kOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9XG4gICAgICogfX0gY29sdW1uIGNoYXJ0IGJvdW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNvbHVtbkNoYXJ0Qm91bmQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgdG9wOiBwYXJhbXMuc3RhcnRUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgICB9LCBwYXJhbXMuYmFzZUJvdW5kKSxcbiAgICAgICAgICAgIGVuZDogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICB0b3A6IHBhcmFtcy5lbmRUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJhbXMuZW5kSGVpZ2h0XG4gICAgICAgICAgICB9LCBwYXJhbXMuYmFzZUJvdW5kKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIG5vcm1hbCBjb2x1bW4gY2hhcnQgYm91bmQuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBncm91cFZhbHVlczogQXJyYXkuPEFycmF5LjxudW1iZXI+PixcbiAgICAgKiAgICAgIGdyb3VwU2l6ZTogbnVtYmVyLCBiYXJTaXplOiBudW1iZXIsIHN0ZXA6IG51bWJlcixcbiAgICAgKiAgICAgIGRpc3RhbmNlVG9NaW46IG51bWJlciwgaXNNaW51czogYm9vbGVhblxuICAgICAqIH19IGJhc2VJbmZvIGJhc2UgaW5mb1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nTGVmdCBwYWRkaW5nIGxlZnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgc3RhcnQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBlbmQ6IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn1cbiAgICAgKiB9fSBjb2x1bW4gY2hhcnQgYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlTm9ybWFsQ29sdW1uQ2hhcnRCb3VuZDogZnVuY3Rpb24oYmFzZUluZm8sIHZhbHVlLCBwYWRkaW5nTGVmdCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGVuZEhlaWdodCwgZW5kVG9wLCBzdGFydEVuZFRvcHMsIGJvdW5kO1xuXG4gICAgICAgIGVuZEhlaWdodCA9IE1hdGguYWJzKHZhbHVlICogYmFzZUluZm8uZGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIGVuZFRvcCA9IChiYXNlSW5mby5pc01pbnVzID8gMCA6IChiYXNlSW5mby5kaXN0YW5jZS50b01heCB8fCBiYXNlSW5mby5kaW1lbnNpb24uaGVpZ2h0KSkgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRTtcbiAgICAgICAgc3RhcnRFbmRUb3BzID0gdGhpcy5fbWFrZVN0YXJ0RW5kVG9wcyhlbmRUb3AsIGVuZEhlaWdodCwgdmFsdWUpO1xuICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VDb2x1bW5DaGFydEJvdW5kKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBiYXNlQm91bmQ6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBwYWRkaW5nTGVmdCArIChiYXNlSW5mby5zdGVwICogaW5kZXgpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkUsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJhc2VJbmZvLmJhclNpemVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmRIZWlnaHQ6IGVuZEhlaWdodFxuICAgICAgICB9LCBzdGFydEVuZFRvcHMpKTtcblxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIG9mIG5vcm1hbCBjb2x1bW4gY2hhcnQuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0Om51bWJlcn19IGRpbWVuc2lvbiBjb2x1bW4gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHJldHVybnMge0FycmF5LjxBcnJheS48b2JqZWN0Pj59IGJvdW5kc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VOb3JtYWxDb2x1bW5DaGFydEJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBiYXNlSW5mbyA9IHRoaXMuX21ha2VCYXNlSW5mb0Zvck5vcm1hbENoYXJ0Qm91bmRzKGRpbWVuc2lvbiwgJ2hlaWdodCcsICd3aWR0aCcpLFxuICAgICAgICAgICAgYm91bmRzID0gdGhpcy5fbWFrZU5vcm1hbEJvdW5kcyhiYXNlSW5mbywgdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlTm9ybWFsQ29sdW1uQ2hhcnRCb3VuZCwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIG9mIHN0YWNrZWQgY29sdW1uIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBkaW1lbnNpb24gY29sdW1uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fSBib3VuZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU3RhY2tlZENvbHVtbkNoYXJ0Qm91bmRzOiBmdW5jdGlvbihkaW1lbnNpb24pIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgYmFzZUluZm8gPSB0aGlzLl9tYWtlQmFzZUluZm9Gb3JTdGFja2VkQ2hhcnRCb3VuZHMoZGltZW5zaW9uLCAnaGVpZ2h0JyksXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLl9tYWtlU3RhY2tlZEJvdW5kcyhkaW1lbnNpb24sIGJhc2VJbmZvLCBmdW5jdGlvbihiYXNlQm91bmQsIGVuZFNpemUsIGVuZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX21ha2VDb2x1bW5DaGFydEJvdW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZUJvdW5kOiBiYXNlQm91bmQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VG9wOiBiYXNlSW5mby5kaXN0YW5jZS50b01heCArIGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICBlbmRUb3A6IGJhc2VJbmZvLmRpc3RhbmNlLnRvTWF4IC0gZW5kU2l6ZSAtIGVuZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlbmRIZWlnaHQ6IGVuZFNpemVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmRzIG9mIGNvbHVtbiBjaGFydC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX0gZGltZW5zaW9uIGNvbHVtbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJvdW5kczogZnVuY3Rpb24oZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBib3VuZHM7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc1ZhbGlkU3RhY2tlZE9wdGlvbih0aGlzLm9wdGlvbnMuc3RhY2tlZCkpIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX21ha2VTdGFja2VkQ29sdW1uQ2hhcnRCb3VuZHMoZGltZW5zaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuX21ha2VOb3JtYWxDb2x1bW5DaGFydEJvdW5kcyhkaW1lbnNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZXJpZXMgcmVuZGVyaW5nIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtvYmVqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy52YWx1ZSB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6bnVtYmVyLCB3aWR0aDpudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmJvdW5kIGJvdW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZvcm1hdHRlZFZhbHVlIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5sYWJlbEhlaWdodCBsYWJlbCBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSByZW5kZXJpbmcgcG9zaXRpb25cbiAgICAgKi9cbiAgICBtYWtlU2VyaWVzUmVuZGVyaW5nUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKHBhcmFtcy5mb3JtYXR0ZWRWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCksXG4gICAgICAgICAgICBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHRvcCA9IGJvdW5kLnRvcCxcbiAgICAgICAgICAgIGxlZnQgPSBib3VuZC5sZWZ0ICsgKGJvdW5kLndpZHRoIC0gbGFiZWxXaWR0aCkgLyAyO1xuXG4gICAgICAgIGlmIChwYXJhbXMudmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgdG9wIC09IHBhcmFtcy5sYWJlbEhlaWdodCArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgKz0gYm91bmQuaGVpZ2h0ICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHN1bSBsYWJlbCBsZWZ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWRTdW0gZm9ybWF0dGVkIHN1bS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBsZWZ0IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlU3VtTGFiZWxMZWZ0UG9zaXRpb246IGZ1bmN0aW9uKGJvdW5kLCBmb3JtYXR0ZWRTdW0pIHtcbiAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChmb3JtYXR0ZWRTdW0sIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICByZXR1cm4gYm91bmQubGVmdCArICgoYm91bmQud2lkdGggLSBsYWJlbFdpZHRoICsgY2hhcnRDb25zdC5URVhUX1BBRERJTkcpIC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcGx1cyBzdW0gbGFiZWwgaHRtbC5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2YWx1ZXMgdmFsdWVzXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGJvdW5kIGJvdW5kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgc3VtIGxhYmVsIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUGx1c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCwgbGFiZWxIZWlnaHQpIHtcbiAgICAgICAgdmFyIHN1bSwgZm9ybWF0dGVkU3VtLFxuICAgICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICAgIGlmIChib3VuZCkge1xuICAgICAgICAgICAgc3VtID0gY2FsY3VsYXRvci5zdW1QbHVzVmFsdWVzKHZhbHVlcyk7XG4gICAgICAgICAgICBmb3JtYXR0ZWRTdW0gPSByZW5kZXJVdGlsLmZvcm1hdFZhbHVlKHN1bSwgdGhpcy5kYXRhUHJvY2Vzc29yLmdldEZvcm1hdEZ1bmN0aW9ucygpKTtcbiAgICAgICAgICAgIGh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLl9jYWxjdWxhdGVTdW1MYWJlbExlZnRQb3NpdGlvbihib3VuZCwgZm9ybWF0dGVkU3VtKSxcbiAgICAgICAgICAgICAgICB0b3A6IGJvdW5kLnRvcCAtIGxhYmVsSGVpZ2h0IC0gY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElOR1xuICAgICAgICAgICAgfSwgZm9ybWF0dGVkU3VtLCAtMSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWludXMgc3VtIGxhYmVsIGh0bWwuXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmFsdWVzIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBib3VuZCBib3VuZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBsdXMgbWludXMgbGFiZWwgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VNaW51c1N1bUxhYmVsSHRtbDogZnVuY3Rpb24odmFsdWVzLCBib3VuZCkge1xuICAgICAgICB2YXIgc3VtLCBmb3JtYXR0ZWRTdW0sXG4gICAgICAgICAgICBodG1sID0gJyc7XG5cbiAgICAgICAgaWYgKGJvdW5kKSB7XG4gICAgICAgICAgICBzdW0gPSBjYWxjdWxhdG9yLnN1bU1pbnVzVmFsdWVzKHZhbHVlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGl2ZXJnaW5nKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gTWF0aC5hYnMoc3VtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0dGVkU3VtID0gcmVuZGVyVXRpbC5mb3JtYXRWYWx1ZShzdW0sIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXRGdW5jdGlvbnMoKSk7XG4gICAgICAgICAgICBodG1sID0gdGhpcy5fbWFrZVNlcmllc0xhYmVsSHRtbCh7XG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5fY2FsY3VsYXRlU3VtTGFiZWxMZWZ0UG9zaXRpb24oYm91bmQsIGZvcm1hdHRlZFN1bSksXG4gICAgICAgICAgICAgICAgdG9wOiBib3VuZC50b3AgKyBib3VuZC5oZWlnaHQgKyBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HXG4gICAgICAgICAgICB9LCBmb3JtYXR0ZWRTdW0sIC0xLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG59KTtcblxuQmFyVHlwZVNlcmllc0Jhc2UubWl4aW4oQ29sdW1uQ2hhcnRTZXJpZXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkNoYXJ0U2VyaWVzO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IExpbmUgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgTGluZVR5cGVTZXJpZXNCYXNlID0gcmVxdWlyZSgnLi9saW5lVHlwZVNlcmllc0Jhc2UnKTtcblxudmFyIExpbmVDaGFydFNlcmllcyA9IHR1aS51dGlsLmRlZmluZUNsYXNzKFNlcmllcywgLyoqIEBsZW5kcyBMaW5lQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTGluZUNoYXJ0U2VyaWVzXG4gICAgICogQGV4dGVuZHMgU2VyaWVzXG4gICAgICogQG1peGVzIExpbmVUeXBlU2VyaWVzQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5tb2RlbCBzZXJpZXMgbW9kZWxcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMub3B0aW9ucyBzZXJpZXMgb3B0aW9uc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy50aGVtZSBzZXJpZXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgcG9zaXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfT4+fSBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlUG9zaXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ha2VCYXNpY1Bvc2l0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbWFrZVNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JvdXBQb3NpdGlvbnM6IHRoaXMuX21ha2VQb3NpdGlvbnMoKVxuICAgICAgICB9O1xuICAgIH1cbn0pO1xuXG5MaW5lVHlwZVNlcmllc0Jhc2UubWl4aW4oTGluZUNoYXJ0U2VyaWVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTGluZVR5cGVTZXJpZXNCYXNlIGlzIGJhc2UgY2xhc3MgZm9yIGxpbmUgdHlwZSBzZXJpZXMuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG4vKipcbiAqIEBjbGFzc2Rlc2MgTGluZVR5cGVTZXJpZXNCYXNlIGlzIGJhc2UgY2xhc3MgZm9yIGxpbmUgdHlwZSBzZXJpZXMuXG4gKiBAY2xhc3MgTGluZVR5cGVTZXJpZXNCYXNlXG4gKiBAbWl4aW5cbiAqL1xudmFyIExpbmVUeXBlU2VyaWVzQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgTGluZVR5cGVTZXJpZXNCYXNlLnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbnMgb2YgbGluZSBjaGFydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxvYmplY3Q+Pn0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUJhc2ljUG9zaXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGdyb3VwVmFsdWVzID0gdGhpcy5fZ2V0UGVyY2VudFZhbHVlcygpLFxuICAgICAgICAgICAgd2lkdGggPSBkaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgbGVuID0gZ3JvdXBWYWx1ZXNbMF0ubGVuZ3RoLFxuICAgICAgICAgICAgc3RhcnQgPSBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgIHN0ZXA7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hbGlnbmVkKSB7XG4gICAgICAgICAgICBzdGVwID0gd2lkdGggLyAobGVuIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGVwID0gd2lkdGggLyBsZW47XG4gICAgICAgICAgICBzdGFydCArPSAoc3RlcCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc3RhcnQgKyAoc3RlcCAqIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBoZWlnaHQgLSAodmFsdWUgKiBoZWlnaHQpICsgY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGxhYmVsIHBvc2l0aW9uIHRvcC5cbiAgICAgKiBAcGFyYW0ge3t0b3A6IG51bWJlciwgc3RhcnRUb3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsSGVpZ2h0IGxhYmVsIGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHRvcFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VMYWJlbFBvc2l0aW9uVG9wOiBmdW5jdGlvbihwb3NpdGlvbiwgdmFsdWUsIGxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvblRvcDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWNrZWQgJiYgcG9zaXRpb24uc3RhcnRUb3ApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID0gKHBvc2l0aW9uLnN0YXJ0VG9wICsgcG9zaXRpb24udG9wIC0gbGFiZWxIZWlnaHQpIC8gMiArIDE7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPCAwICYmICF0dWkudXRpbC5pc1VuZGVmaW5lZChwb3NpdGlvbi5zdGFydFRvcCkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID0gcG9zaXRpb24udG9wICsgY2hhcnRDb25zdC5TRVJJRVNfTEFCRUxfUEFERElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVG9wID0gcG9zaXRpb24udG9wIC0gbGFiZWxIZWlnaHQgLSBjaGFydENvbnN0LlNFUklFU19MQUJFTF9QQURESU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uVG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsU2VyaWVzTGFiZWxBcmVhIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oZWxTZXJpZXNMYWJlbEFyZWEpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlcywgZmlyc3RGb3JtYXR0ZWRWYWx1ZSwgZ3JvdXBQb3NpdGlvbnMsIGxhYmVsSGVpZ2h0LCBodG1sO1xuXG4gICAgICAgIGdyb3VwUG9zaXRpb25zID0gdGhpcy5zZXJpZXNEYXRhLmdyb3VwUG9zaXRpb25zO1xuICAgICAgICBmb3JtYXR0ZWRWYWx1ZXMgPSB0dWkudXRpbC5waXZvdCh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Rm9ybWF0dGVkR3JvdXBWYWx1ZXModGhpcy5jaGFydFR5cGUpKTtcbiAgICAgICAgZmlyc3RGb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGaXJzdEZvcm1hdHRlZFZhbHVlKHRoaXMuY2hhcnRUeXBlKTtcbiAgICAgICAgbGFiZWxIZWlnaHQgPSByZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQoZmlyc3RGb3JtYXR0ZWRWYWx1ZSwgdGhpcy50aGVtZS5sYWJlbCk7XG5cbiAgICAgICAgaHRtbCA9IHR1aS51dGlsLm1hcChmb3JtYXR0ZWRWYWx1ZXMsIGZ1bmN0aW9uKHZhbHVlcywgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdyb3VwUG9zaXRpb25zW2dyb3VwSW5kZXhdW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxIdG1sID0gJycsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24udG9wICE9PSBwb3NpdGlvbi5zdGFydFRvcCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFdpZHRoID0gcmVuZGVyVXRpbC5nZXRSZW5kZXJlZExhYmVsV2lkdGgodmFsdWUsIHRoaXMudGhlbWUubGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSAobGFiZWxXaWR0aCAvIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0aGlzLl9tYWtlTGFiZWxQb3NpdGlvblRvcChwb3NpdGlvbiwgdmFsdWUsIGxhYmVsSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICB9LCB2YWx1ZSwgaW5kZXgsIGdyb3VwSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxIdG1sO1xuICAgICAgICAgICAgfSwgdGhpcykuam9pbignJyk7XG4gICAgICAgIH0sIHRoaXMpLmpvaW4oJycpO1xuXG4gICAgICAgIGVsU2VyaWVzTGFiZWxBcmVhLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2hhbmdlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBjaGFuZ2VkIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZDogZnVuY3Rpb24oZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByZXZJbmRleGVzID0gdGhpcy5wcmV2SW5kZXhlcztcblxuICAgICAgICB0aGlzLnByZXZJbmRleGVzID0ge1xuICAgICAgICAgICAgZ3JvdXBJbmRleDogZ3JvdXBJbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAhcHJldkluZGV4ZXMgfHwgKHByZXZJbmRleGVzLmdyb3VwSW5kZXggIT09IGdyb3VwSW5kZXgpIHx8IChwcmV2SW5kZXhlcy5pbmRleCAhPT0gaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNob3dHcm91cFRvb2x0aXBMaW5lIGZ1bmN0aW9uIG9mIGdyYXBoUmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYm91bmQgYm91bmRcbiAgICAgKi9cbiAgICBvblNob3dHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbihib3VuZCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBUb29sdGlwTGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBUb29sdGlwTGluZShib3VuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgaGlkZUdyb3VwVG9vbHRpcExpbmUgZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKi9cbiAgICBvbkhpZGVHcm91cFRvb2x0aXBMaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwVG9vbHRpcExpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwVG9vbHRpcExpbmUoKTtcbiAgICB9XG59KTtcblxuTGluZVR5cGVTZXJpZXNCYXNlLm1peGluID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgTGluZVR5cGVTZXJpZXNCYXNlLnByb3RvdHlwZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUeXBlU2VyaWVzQmFzZTtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBNYXAgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFNlcmllcyA9IHJlcXVpcmUoJy4vc2VyaWVzJyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgTWFwQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgTWFwQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQgc2VyaWVzIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBNYXBDaGFydFNlcmllc1xuICAgICAqIEBleHRlbmRzIFNlcmllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIHNlcmllcyBvcHRpb25zXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIHNlcmllcyB0aGVtZVxuICAgICAqICAgICAgQHBhcmFtIHtNYXBDaGFydERhdGFQcm9jZXNzb3J9IHBhcmFtcy5kYXRhUHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yIGZvciBtYXAgY2hhcnRcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2UgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogWm9vbSBtYWduaWZpY2F0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tTWFnbiA9IDE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCByYXRpby5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwUmF0aW8gPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCBkaW1lbnNpb24uXG4gICAgICAgICAqIEB0eXBlIHt7fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JhcGhEaW1lbnNpb24gPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGltaXQgcG9zaXRpb24uXG4gICAgICAgICAqIEB0eXBlIHt7fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGltaXRQb3NpdGlvbiA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgbW9kZWwuXG4gICAgICAgICAqIEB0eXBlIHtNYXBDaGFydE1hcE1vZGVsfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBNb2RlbCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZXZpb3VzIG1vdXNlIHBvc2l0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7P3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldlBvc2l0aW9uID0gbnVsbDtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmV2aW91cyBtb3ZlZCBpbmRleC5cbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZNb3ZlZEluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBkcmFnIG9yIG5vdC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuXG4gICAgICAgIFNlcmllcy5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBtYXAgcmF0aW8uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TWFwUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpLFxuICAgICAgICAgICAgbWFwRGltZW5zaW9uID0gdGhpcy5tYXBNb2RlbC5nZXRNYXBEaW1lbnNpb24oKSxcbiAgICAgICAgICAgIHdpZHRoUmF0aW8gPSBzZXJpZXNEaW1lbnNpb24ud2lkdGggLyBtYXBEaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRSYXRpbyA9IHNlcmllc0RpbWVuc2lvbi5oZWlnaHQgLyBtYXBEaW1lbnNpb24uaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMubWFwUmF0aW8gPSBNYXRoLm1pbih3aWR0aFJhdGlvLCBoZWlnaHRSYXRpbyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBncmFwaCBkaW1lbnNpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0R3JhcGhEaW1lbnNpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VyaWVzRGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ3NlcmllcycpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhEaW1lbnNpb24gPSB7XG4gICAgICAgICAgICB3aWR0aDogc2VyaWVzRGltZW5zaW9uLndpZHRoICogdGhpcy56b29tTWFnbixcbiAgICAgICAgICAgIGhlaWdodDogc2VyaWVzRGltZW5zaW9uLmhlaWdodCAqIHRoaXMuem9vbU1hZ25cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZXJpZXMgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMubWFwTW9kZWwgPSBkYXRhLm1hcE1vZGVsO1xuICAgICAgICB0aGlzLl9zZXRNYXBSYXRpbygpO1xuXG4gICAgICAgIGNvbnRhaW5lciA9IFNlcmllcy5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBsaW1pdCBwb3NpdGlvbiB0byBtb3ZlIG1hcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW1pdFBvc2l0aW9uVG9Nb3ZlTWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlcmllc0RpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdzZXJpZXMnKSxcbiAgICAgICAgICAgIGdyYXBoRGltZW5zaW9uID0gdGhpcy5ncmFwaERpbWVuc2lvbjtcblxuICAgICAgICB0aGlzLmxpbWl0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsZWZ0OiBzZXJpZXNEaW1lbnNpb24ud2lkdGggLSBncmFwaERpbWVuc2lvbi53aWR0aCxcbiAgICAgICAgICAgIHRvcDogc2VyaWVzRGltZW5zaW9uLmhlaWdodCAtIGdyYXBoRGltZW5zaW9uLmhlaWdodFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZW5kZXJHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ncmFwaENvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtc2VyaWVzLWdyYXBoLWFyZWEnKTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZ3JhcGhDb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0R3JhcGhEaW1lbnNpb24oKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24odGhpcy5ncmFwaENvbnRhaW5lciwgdGhpcy5ncmFwaERpbWVuc2lvbik7XG5cbiAgICAgICAgdGhpcy5fc2V0TGltaXRQb3NpdGlvblRvTW92ZU1hcCgpO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZW5kZXIodGhpcy5ncmFwaENvbnRhaW5lciwge1xuICAgICAgICAgICAgY29sb3JNb2RlbDogdGhpcy5kYXRhLmNvbG9yTW9kZWwsXG4gICAgICAgICAgICBtYXBNb2RlbDogdGhpcy5tYXBNb2RlbCxcbiAgICAgICAgICAgIGRpbWVuc2lvbjogdGhpcy5ncmFwaERpbWVuc2lvbixcbiAgICAgICAgICAgIHRoZW1lOiB0aGlzLnRoZW1lXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0xhYmVsQ29udGFpbmVyIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJTZXJpZXNMYWJlbDogZnVuY3Rpb24oc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIGh0bWwgPSB0dWkudXRpbC5tYXAodGhpcy5tYXBNb2RlbC5nZXRMYWJlbERhdGEodGhpcy56b29tTWFnbiAqIHRoaXMubWFwUmF0aW8pLCBmdW5jdGlvbihkYXR1bSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGRhdHVtLm5hbWUgfHwgZGF0dW0uY29kZSxcbiAgICAgICAgICAgICAgICBsZWZ0ID0gZGF0dW0ubGFiZWxQb3NpdGlvbi5sZWZ0IC0gKHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSAvIDIpLFxuICAgICAgICAgICAgICAgIHRvcCA9IGRhdHVtLmxhYmVsUG9zaXRpb24udG9wIC0gKHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbEhlaWdodChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCkgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgICAgICB9LCBkYXR1bS5uYW1lLCAwLCBpbmRleCk7XG4gICAgICAgIH0sIHRoaXMpLmpvaW4oJycpO1xuICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzQ29udGFpbmVyIHNlcmllcyBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVyR3JhcGggZnVuY3Rpb24gZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0FyZWE6IGZ1bmN0aW9uKHNlcmllc0NvbnRhaW5lciwgZGF0YSwgZnVuY1JlbmRlckdyYXBoKSB7XG4gICAgICAgIFNlcmllcy5wcm90b3R5cGUuX3JlbmRlclNlcmllc0FyZWEuY2FsbCh0aGlzLCBzZXJpZXNDb250YWluZXIsIGRhdGEsIGZ1bmNSZW5kZXJHcmFwaCk7XG4gICAgICAgIHRoaXMuZ3JhcGhDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBtYXAgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHRhcmdldFBvc2l0aW9uIHRhcmdldCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGFkanVzdGVkIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0TWFwUG9zaXRpb246IGZ1bmN0aW9uKHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBNYXRoLm1heChNYXRoLm1pbih0YXJnZXRQb3NpdGlvbi5sZWZ0LCAwKSwgdGhpcy5saW1pdFBvc2l0aW9uLmxlZnQpLFxuICAgICAgICAgICAgdG9wOiBNYXRoLm1heChNYXRoLm1pbih0YXJnZXRQb3NpdGlvbi50b3AsIDApLCB0aGlzLmxpbWl0UG9zaXRpb24udG9wKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYmFzZSBwb3NpdGlvbiBmb3Igem9vbS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHByZXZEaW1lbnNpb24gcHJldmlvdXMgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZMaW1pdFBvc2l0aW9uIHByZXZpb3VzIGxpbWl0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5nZWRSYXRpbyBjaGFuZ2VkIHJhdGlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQmFzZVBvc2l0aW9uRm9yWm9vbTogZnVuY3Rpb24ocHJldkRpbWVuc2lvbiwgcHJldkxpbWl0UG9zaXRpb24sIGNoYW5nZWRSYXRpbykge1xuICAgICAgICB2YXIgcHJldkJhc2VQb3NpdGlvbiA9IHRoaXMuYmFzZVBvc2l0aW9uLFxuICAgICAgICAgICAgcHJldkxlZnQgPSBwcmV2QmFzZVBvc2l0aW9uLmxlZnQgLSAocHJldkxpbWl0UG9zaXRpb24ubGVmdCAvIDIpLFxuICAgICAgICAgICAgcHJldlRvcCA9IHByZXZCYXNlUG9zaXRpb24udG9wIC0gKHByZXZMaW1pdFBvc2l0aW9uLnRvcCAvIDIpLFxuICAgICAgICAgICAgbmV3QmFzZVBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6IChwcmV2TGVmdCAqIGNoYW5nZWRSYXRpbykgKyAodGhpcy5saW1pdFBvc2l0aW9uLmxlZnQgLyAyKSxcbiAgICAgICAgICAgICAgICB0b3A6IChwcmV2VG9wICogY2hhbmdlZFJhdGlvKSArICh0aGlzLmxpbWl0UG9zaXRpb24udG9wIC8gMilcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5iYXNlUG9zaXRpb24gPSB0aGlzLl9hZGp1c3RNYXBQb3NpdGlvbihuZXdCYXNlUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBab29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFuZ2VkUmF0aW8gY2hhbmdlZCByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3pvb206IGZ1bmN0aW9uKGNoYW5nZWRSYXRpbykge1xuICAgICAgICB2YXIgcHJldkRpbWVuc2lvbiA9IHRoaXMuZ3JhcGhEaW1lbnNpb24sXG4gICAgICAgICAgICBwcmV2TGltaXRQb3NpdGlvbiA9IHRoaXMubGltaXRQb3NpdGlvbjtcblxuICAgICAgICB0aGlzLl9zZXRHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmdyYXBoRGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNldFNpemUodGhpcy5ncmFwaERpbWVuc2lvbik7XG5cbiAgICAgICAgdGhpcy5fc2V0TGltaXRQb3NpdGlvblRvTW92ZU1hcCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVCYXNlUG9zaXRpb25Gb3Jab29tKHByZXZEaW1lbnNpb24sIHByZXZMaW1pdFBvc2l0aW9uLCBjaGFuZ2VkUmF0aW8pO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKHRoaXMuZ3JhcGhDb250YWluZXIsIHRoaXMuYmFzZVBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJTZXJpZXNMYWJlbCh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHBvc2l0aW9ucyB0byByZXNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByZXZNYXBSYXRpbyBwcmV2aW91cyByYXRpb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVBvc2l0aW9uc1RvUmVzaXplOiBmdW5jdGlvbihwcmV2TWFwUmF0aW8pIHtcbiAgICAgICAgdmFyIGNoYW5nZWRSYXRpbyA9IHRoaXMubWFwUmF0aW8gLyBwcmV2TWFwUmF0aW87XG5cbiAgICAgICAgdGhpcy5iYXNlUG9zaXRpb24ubGVmdCAqPSBjaGFuZ2VkUmF0aW87XG4gICAgICAgIHRoaXMuYmFzZVBvc2l0aW9uLnRvcCAqPSBjaGFuZ2VkUmF0aW87XG5cbiAgICAgICAgdGhpcy5saW1pdFBvc2l0aW9uLmxlZnQgKj0gY2hhbmdlZFJhdGlvO1xuICAgICAgICB0aGlzLmxpbWl0UG9zaXRpb24udG9wICo9IGNoYW5nZWRSYXRpbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIGdyYXBoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2l6ZUdyYXBoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByZXZSYXRpbyA9IHRoaXMubWFwUmF0aW87XG5cbiAgICAgICAgdGhpcy5fc2V0TWFwUmF0aW8oKTtcblxuICAgICAgICB0aGlzLl9zZXRHcmFwaERpbWVuc2lvbigpO1xuICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmdyYXBoRGltZW5zaW9uKTtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnNldFNpemUodGhpcy5ncmFwaERpbWVuc2lvbik7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25zRm9yUmVzaXppbmcocHJldlJhdGlvKTtcbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJQb3NpdGlvbih0aGlzLmdyYXBoQ29udGFpbmVyLCB0aGlzLmJhc2VQb3NpdGlvbik7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzTGFiZWwodGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGNsaWNrIHNlcmllcy5cbiAgICAgKi9cbiAgICBvbkNsaWNrU2VyaWVzOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBjaGFuZ2VkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gez97bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2aW91cyBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXN1bHQgYm9vbGVhblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2hhbmdlZFBvc2l0aW9uOiBmdW5jdGlvbihwcmV2UG9zaXRpb24sIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAhcHJldlBvc2l0aW9uIHx8IHByZXZQb3NpdGlvbi5sZWZ0ICE9PSBwb3NpdGlvbi5sZWZ0IHx8IHByZXZQb3NpdGlvbi50b3AgIT09IHBvc2l0aW9uLnRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB3ZWRnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggbWFwIGRhdGEgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93V2VkZ2U6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBkYXR1bSA9IHRoaXMubWFwTW9kZWwuZ2V0RGF0dW0oaW5kZXgpO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQoZGF0dW0ucGVyY2VudFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdzaG93V2VkZ2UnLCBkYXR1bS5wZXJjZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdG9vbHRpcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBtYXAgZGF0YSBpbmRleFxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3VzZVBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4LCBtb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXAnLCB7XG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb246IG1vdXNlUG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBzZXJpZXMgY29udGFpbmVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IGNvbnRhaW5lciBib3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldENvbnRhaW5lckJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckJvdW5kID0gdGhpcy5zZXJpZXNDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQm91bmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIG1vdmUgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uTW92ZVNlcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ2ZpbmRTZWN0b3JJbmRleCcpLFxuICAgICAgICAgICAgY29udGFpbmVyQm91bmQ7XG5cbiAgICAgICAgaWYgKCF0dWkudXRpbC5pc051bGwoZm91bmRJbmRleCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZNb3ZlZEluZGV4ICE9PSBmb3VuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldk1vdmVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlc3RvcmVDb2xvcih0aGlzLnByZXZNb3ZlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlV2VkZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5jaGFuZ2VDb2xvcihmb3VuZEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ2hhbmdlZFBvc2l0aW9uKHRoaXMucHJldlBvc2l0aW9uLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJCb3VuZCA9IHRoaXMuX2dldENvbnRhaW5lckJvdW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvd1Rvb2x0aXAoZm91bmRJbmRleCwge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0IC0gY29udGFpbmVyQm91bmQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSBjb250YWluZXJCb3VuZC50b3BcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZNb3ZlZEluZGV4ID0gZm91bmRJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2hvd1dlZGdlKGZvdW5kSW5kZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0dWkudXRpbC5pc051bGwodGhpcy5wcmV2TW92ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZXN0b3JlQ29sb3IodGhpcy5wcmV2TW92ZWRJbmRleCk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVXZWRnZScpO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICAgICAgdGhpcy5wcmV2TW92ZWRJbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gZHJhZyBzdGFydCBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25EcmFnU3RhcnRTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgLSB0aGlzLmJhc2VQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSB0aGlzLmJhc2VQb3NpdGlvbi50b3BcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gZHJhZyBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25EcmFnU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB2YXIgbW92ZVBvc2l0aW9uID0gdGhpcy5fYWRqdXN0TWFwUG9zaXRpb24oe1xuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIHRoaXMuc3RhcnRQb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgLSB0aGlzLnN0YXJ0UG9zaXRpb24udG9wXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy5ncmFwaENvbnRhaW5lciwgbW92ZVBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5iYXNlUG9zaXRpb24gPSBtb3ZlUG9zaXRpb247XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZykge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIGRyYWcgZW5kIHNlcmllcy5cbiAgICAgKi9cbiAgICBvbkRyYWdFbmRTZXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiB6b29tLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdNYWduIG5ldyB6b29tIG1hZ25pZmljYXRpb25cbiAgICAgKi9cbiAgICBvblpvb206IGZ1bmN0aW9uKG5ld01hZ24pIHtcbiAgICAgICAgdmFyIGNoYW5nZWRSYXRpbyA9IG5ld01hZ24gLyB0aGlzLnpvb21NYWduO1xuXG4gICAgICAgIHRoaXMuem9vbU1hZ24gPSBuZXdNYWduO1xuXG4gICAgICAgIHRoaXMuX3pvb20oY2hhbmdlZFJhdGlvKTtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnem9vbScsIG5ld01hZ24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhbmltYXRlQ29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhKCk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihNYXBDaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgUGllIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTZXJpZXMgPSByZXF1aXJlKCcuL3NlcmllcycpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHByZWRpY2F0ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcHJlZGljYXRlJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpO1xuXG52YXIgUGllQ2hhcnRTZXJpZXMgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhTZXJpZXMsIC8qKiBAbGVuZHMgUGllQ2hhcnRTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBMaW5lIGNoYXJ0IHNlcmllcyBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgUGllQ2hhcnRTZXJpZXNcbiAgICAgKiBAZXh0ZW5kcyBTZXJpZXNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubW9kZWwgc2VyaWVzIG1vZGVsXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsZWdlbmQgYWxpZ24gb3B0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kQWxpZ24gPSBwYXJhbXMubGVnZW5kQWxpZ247XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYXJ0IGJhY2tncm91bmQuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYXJ0QmFja2dyb3VuZCA9IHBhcmFtcy5jaGFydEJhY2tncm91bmQ7XG5cbiAgICAgICAgU2VyaWVzLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzZWN0b3JzIGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHBlcmNlbnRWYWx1ZXMgcGVyY2VudCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9fSBjaXJjbGVCb3VuZCBjaXJjbGUgYm91bmRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHNlY3RvcnMgaW5mb3JtYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VjdG9yRGF0YTogZnVuY3Rpb24ocGVyY2VudFZhbHVlcywgY2lyY2xlQm91bmQpIHtcbiAgICAgICAgdmFyIGN4ID0gY2lyY2xlQm91bmQuY3gsXG4gICAgICAgICAgICBjeSA9IGNpcmNsZUJvdW5kLmN5LFxuICAgICAgICAgICAgciA9IGNpcmNsZUJvdW5kLnIsXG4gICAgICAgICAgICBhbmdsZSA9IDAsXG4gICAgICAgICAgICBkZWx0YSA9IDEwLFxuICAgICAgICAgICAgcGF0aHM7XG5cbiAgICAgICAgcGF0aHMgPSB0dWkudXRpbC5tYXAocGVyY2VudFZhbHVlcywgZnVuY3Rpb24ocGVyY2VudFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYWRkQW5nbGUgPSBjaGFydENvbnN0LkFOR0xFXzM2MCAqIHBlcmNlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IGFuZ2xlICsgYWRkQW5nbGUsXG4gICAgICAgICAgICAgICAgcG9wdXBBbmdsZSA9IGFuZ2xlICsgKGFkZEFuZ2xlIC8gMiksXG4gICAgICAgICAgICAgICAgYW5nbGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogYW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRBbmdsZTogYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGN4OiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICAgICAgICBhbmdsZTogcG9wdXBBbmdsZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudFZhbHVlOiBwZXJjZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgYW5nbGVzOiBhbmdsZXMsXG4gICAgICAgICAgICAgICAgY2VudGVyUG9zaXRpb246IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIHI6IChyIC8gMikgKyBkZWx0YVxuICAgICAgICAgICAgICAgIH0sIHBvc2l0aW9uRGF0YSkpLFxuICAgICAgICAgICAgICAgIG91dGVyUG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiByXG4gICAgICAgICAgICAgICAgICAgIH0sIHBvc2l0aW9uRGF0YSkpLFxuICAgICAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMuX2dldEFyY1Bvc2l0aW9uKHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiByICsgZGVsdGFcbiAgICAgICAgICAgICAgICAgICAgfSwgcG9zaXRpb25EYXRhKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc2VyaWVzIGRhdGEuXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIGNoYXJ0QmFja2dyb3VuZDogc3RyaW5nLFxuICAgICAqICAgICAgY2lyY2xlQm91bmQ6ICh7Y3g6IG51bWJlciwgY3k6IG51bWJlciwgcjogbnVtYmVyfSksXG4gICAgICogICAgICBzZWN0b3JEYXRhOiBBcnJheS48b2JqZWN0PlxuICAgICAqIH19IGFkZCBkYXRhIGZvciBncmFwaCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaXJjbGVCb3VuZCA9IHRoaXMuX21ha2VDaXJjbGVCb3VuZCh0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignc2VyaWVzJyksIHtcbiAgICAgICAgICAgICAgICBzaG93TGFiZWw6IHRoaXMub3B0aW9ucy5zaG93TGFiZWwsXG4gICAgICAgICAgICAgICAgbGVnZW5kQWxpZ246IHRoaXMubGVnZW5kQWxpZ25cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2VjdG9yRGF0YSA9IHRoaXMuX21ha2VTZWN0b3JEYXRhKHRoaXMuX2dldFBlcmNlbnRWYWx1ZXMoKVswXSwgY2lyY2xlQm91bmQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFydEJhY2tncm91bmQ6IHRoaXMuY2hhcnRCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY2lyY2xlQm91bmQ6IGNpcmNsZUJvdW5kLFxuICAgICAgICAgICAgc2VjdG9yRGF0YTogc2VjdG9yRGF0YVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGNpcmNsZSBib3VuZFxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDpudW1iZXJ9fSBkaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7c2hvd0xhYmVsOiBib29sZWFuLCBsZWdlbmRBbGlnbjogc3RyaW5nfX0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3tjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByOiBudW1iZXJ9fSBjaXJjbGUgYm91bmRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNpcmNsZUJvdW5kOiBmdW5jdGlvbihkaW1lbnNpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGlzU21hbGxQaWUgPSBwcmVkaWNhdGUuaXNPdXRlckxlZ2VuZEFsaWduKG9wdGlvbnMubGVnZW5kQWxpZ24pICYmIG9wdGlvbnMuc2hvd0xhYmVsLFxuICAgICAgICAgICAgcmFkaXVzUmF0ZSA9IGlzU21hbGxQaWUgPyBjaGFydENvbnN0LlBJRV9HUkFQSF9TTUFMTF9SQVRFIDogY2hhcnRDb25zdC5QSUVfR1JBUEhfREVGQVVMVF9SQVRFLFxuICAgICAgICAgICAgZGlhbWV0ZXIgPSB0dWkudXRpbC5tdWx0aXBsaWNhdGlvbih0dWkudXRpbC5taW4oW3dpZHRoLCBoZWlnaHRdKSwgcmFkaXVzUmF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiB0dWkudXRpbC5kaXZpc2lvbih3aWR0aCwgMiksXG4gICAgICAgICAgICBjeTogdHVpLnV0aWwuZGl2aXNpb24oaGVpZ2h0LCAyKSxcbiAgICAgICAgICAgIHI6IHR1aS51dGlsLmRpdmlzaW9uKGRpYW1ldGVyLCAyKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYXJjIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5jeCBjZW50ZXIgeFxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5jeSBjZW50ZXIgeVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5yIHJhZGl1c1xuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5hbmdsZSBhbmdsZShkZWdyZWUpXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYXJjIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0QXJjUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcGFyYW1zLmN4ICsgKHBhcmFtcy5yICogTWF0aC5zaW4ocGFyYW1zLmFuZ2xlICogY2hhcnRDb25zdC5SQUQpKSxcbiAgICAgICAgICAgIHRvcDogcGFyYW1zLmN5IC0gKHBhcmFtcy5yICogTWF0aC5jb3MocGFyYW1zLmFuZ2xlICogY2hhcnRDb25zdC5SQUQpKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgcmFwaGFlbCBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlbmRlckdyYXBoOiBmdW5jdGlvbihkaW1lbnNpb24sIHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIGZ1bmNTaG93VG9vbHRpcCA9IHR1aS51dGlsLmJpbmQodGhpcy5zaG93VG9vbHRpcCwgdGhpcywge1xuICAgICAgICAgICAgICAgIGFsbG93TmVnYXRpdmVUb29sdGlwOiAhIXRoaXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXAsXG4gICAgICAgICAgICAgICAgY2hhcnRUeXBlOiB0aGlzLmNoYXJ0VHlwZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAgICAgZnVuY1Nob3dUb29sdGlwOiBmdW5jU2hvd1Rvb2x0aXAsXG4gICAgICAgICAgICAgICAgZnVuY0hpZGVUb29sdGlwOiB0dWkudXRpbC5iaW5kKHRoaXMuaGlkZVRvb2x0aXAsIHRoaXMpLFxuICAgICAgICAgICAgICAgIGZ1bmNTZWxlY3RTZXJpZXM6IHR1aS51dGlsLmJpbmQodGhpcy5zZWxlY3RTZXJpZXMsIHRoaXMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5fbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlcih0aGlzLnNlcmllc0NvbnRhaW5lciwgcGFyYW1zLCBjYWxsYmFja3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgU2VyaWVzLnByb3RvdHlwZS5yZXNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fbW92ZUxlZ2VuZExpbmVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNob3dUb29sdGlwIGlzIG1vdXNlb3ZlciBldmVudCBjYWxsYmFjayBvbiBzZXJpZXMgZ3JhcGguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5hbGxvd05lZ2F0aXZlVG9vbHRpcCB3aGV0aGVyIGFsbG93IG5lZ2F0aXZlIHRvb2x0aXAgb3Igbm90XG4gICAgICogQHBhcmFtIHt7dG9wOm51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGJvdW5kIGdyYXBoIGJvdW5kIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gbW91c2VQb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbihwYXJhbXMsIGJvdW5kLCBncm91cEluZGV4LCBpbmRleCwgbW91c2VQb3NpdGlvbikge1xuICAgICAgICB0aGlzLmZpcmUoJ3Nob3dUb29sdGlwJywgdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGluZGV4ZXM6IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb246IG1vdXNlUG9zaXRpb25cbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhpZGVUb29sdGlwIGlzIG1vdXNlb3V0IGV2ZW50IGNhbGxiYWNrIG9uIHNlcmllcyBncmFwaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdG9vbHRpcCBpZFxuICAgICAqL1xuICAgIGhpZGVUb29sdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhIGJ5IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7e2luZGV4ZXM6IHtpbmRleDogbnVtYmVyLCBncm91cEluZGV4OiBudW1iZXJ9fX0gc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2VyaWVzRGF0YUJ5U2VsZWN0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXhlczoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBpbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3RTZXJpZXMgaXMgY2xpY2sgZXZlbnQgY2FsbGJhY2sgb24gc2VyaWVzIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIHNlbGVjdFNlcmllczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlcmllc0RhdGEgPSB0aGlzLl9tYWtlU2VyaWVzRGF0YUJ5U2VsZWN0aW9uKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMub25VbnNlbGVjdFNlcmllcyhzZXJpZXNEYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXR1aS51dGlsLmlzVW5kZWZpbmVkKHRoaXMuc2VsZWN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVW5zZWxlY3RTZXJpZXModGhpcy5fbWFrZVNlcmllc0RhdGFCeVNlbGVjdGlvbih0aGlzLnNlbGVjdGVkSW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RTZXJpZXMoc2VyaWVzRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5sZWdlbmQgbGVnZW5kXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmxhYmVsIGxhYmVsXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNlcGFyYXRvciBzZXBhcmF0b3JcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZ2VuZEFsaWduOiA/c3RyaW5nLCBzaG93TGFiZWw6IGJvb2xlYW59fSBwYXJhbXMub3B0aW9ucyBvcHRpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ30gc2VyaWVzIGxhYmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgc2VyaWVzTGFiZWwgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5sZWdlbmRBbGlnbikge1xuICAgICAgICAgICAgc2VyaWVzTGFiZWwgPSAnPHNwYW4gY2xhc3M9XCJ0dWktY2hhcnQtc2VyaWVzLWxlZ2VuZFwiPicgKyBwYXJhbXMubGVnZW5kICsgJzwvc3Bhbj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGFiZWwpIHtcbiAgICAgICAgICAgIHNlcmllc0xhYmVsICs9IChzZXJpZXNMYWJlbCA/IHBhcmFtcy5zZXBhcmF0b3IgOiAnJykgKyBwYXJhbXMubGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VyaWVzTGFiZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48b2JqZWN0Pn0gcGFyYW1zLnBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc2VwYXJhdG9yIHNlcGFyYXRvclxuICAgICAqICAgICAgQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5vcHRpb25zIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHBhcmFtcy5mdW5jTW92ZVRvUG9zaXRpb24gZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyTGVnZW5kTGFiZWw6IGZ1bmN0aW9uKHBhcmFtcywgc2VyaWVzTGFiZWxDb250YWluZXIpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHBhcmFtcy5wb3NpdGlvbnMsXG4gICAgICAgICAgICBodG1scztcblxuICAgICAgICBodG1scyA9IHR1aS51dGlsLm1hcCh0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0TGVnZW5kTGFiZWxzKCksIGZ1bmN0aW9uKGxlZ2VuZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgbGFiZWwsIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gdGhpcy5fZ2V0U2VyaWVzTGFiZWwoe1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZCxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXR0ZWRWYWx1ZSgwLCBpbmRleCwgdGhpcy5jaGFydFR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3I6IHBhcmFtcy5zZXBhcmF0b3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBhcmFtcy5mdW5jTW92ZVRvUG9zaXRpb24ocG9zaXRpb25zW2luZGV4XSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIGh0bWwgPSB0aGlzLl9tYWtlU2VyaWVzTGFiZWxIdG1sKHBvc2l0aW9uLCBsYWJlbCwgMCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHNlcmllc0xhYmVsQ29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxzLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRvIGNlbnRlciBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBjZW50ZXIgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3ZlVG9DZW50ZXJQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGxhYmVsKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxXaWR0aChsYWJlbCwgdGhpcy50aGVtZS5sYWJlbCkgLyAyKSxcbiAgICAgICAgICAgIHRvcCA9IHBvc2l0aW9uLnRvcCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIHBvaXN0aW9ucyBmcm9tIHNlY3RvciBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblR5cGUgcG9zaXRpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gcG9zaXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGlja1Bvc2l0aW9uc0Zyb21TZWN0b3JEYXRhOiBmdW5jdGlvbihwb3NpdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh0aGlzLnNlcmllc0RhdGEuc2VjdG9yRGF0YSwgZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXR1bS5wZXJjZW50VmFsdWUgPyBkYXR1bVtwb3NpdGlvblR5cGVdIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBjZW50ZXIgbGVnZW5kLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNlcmllc0xhYmVsQ29udGFpbmVyIHNlcmllcyBsYWJlbCBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJDZW50ZXJMZWdlbmQ6IGZ1bmN0aW9uKHNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZExhYmVsKHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogdGhpcy5fcGlja1Bvc2l0aW9uc0Zyb21TZWN0b3JEYXRhKCdjZW50ZXJQb3NpdGlvbicpLFxuICAgICAgICAgICAgZnVuY01vdmVUb1Bvc2l0aW9uOiB0dWkudXRpbC5iaW5kKHRoaXMuX21vdmVUb0NlbnRlclBvc2l0aW9uLCB0aGlzKSxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogJzxicj4nXG4gICAgICAgIH0sIHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VudGVyTGVmdCBjZW50ZXIgbGVmdFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG9iamVjdD59IHBvc2l0aW9ucyBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRFbmRQb3NpdGlvbjogZnVuY3Rpb24oY2VudGVyTGVmdCwgcG9zaXRpb25zKSB7XG4gICAgICAgIHR1aS51dGlsLmZvckVhY2hBcnJheShwb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZW5kO1xuXG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmQgPSB0dWkudXRpbC5leHRlbmQoe30sIHBvc2l0aW9uLm1pZGRsZSk7XG4gICAgICAgICAgICBpZiAoZW5kLmxlZnQgPCBjZW50ZXJMZWZ0KSB7XG4gICAgICAgICAgICAgICAgZW5kLmxlZnQgLT0gY2hhcnRDb25zdC5TRVJJRVNfT1VURVJfTEFCRUxfUEFERElORztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kLmxlZnQgKz0gY2hhcnRDb25zdC5TRVJJRVNfT1VURVJfTEFCRUxfUEFERElORztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IGVuZDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmUgdG8gb3V0ZXIgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbnRlckxlZnQgY2VudGVyIGxlZnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBvdXRlciBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb091dGVyUG9zaXRpb246IGZ1bmN0aW9uKGNlbnRlckxlZnQsIHBvc2l0aW9uLCBsYWJlbCkge1xuICAgICAgICB2YXIgcG9zaXRpb25FbmQgPSBwb3NpdGlvbi5lbmQsXG4gICAgICAgICAgICBsZWZ0ID0gcG9zaXRpb25FbmQubGVmdCxcbiAgICAgICAgICAgIHRvcCA9IHBvc2l0aW9uRW5kLnRvcCAtIChyZW5kZXJVdGlsLmdldFJlbmRlcmVkTGFiZWxIZWlnaHQobGFiZWwsIHRoaXMudGhlbWUubGFiZWwpIC8gMik7XG5cbiAgICAgICAgaWYgKGxlZnQgPCBjZW50ZXJMZWZ0KSB7XG4gICAgICAgICAgICBsZWZ0IC09IHJlbmRlclV0aWwuZ2V0UmVuZGVyZWRMYWJlbFdpZHRoKGxhYmVsLCB0aGlzLnRoZW1lLmxhYmVsKSArIGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ICs9IGNoYXJ0Q29uc3QuU0VSSUVTX0xBQkVMX1BBRERJTkc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvdXRlciBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzTGFiZWxDb250YWluZXIgc2VyaWVzIGxhYmVsIGFyZWEgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlck91dGVyTGVnZW5kOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICB2YXIgY2VudGVyTGVmdCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpLndpZHRoIC8gMixcbiAgICAgICAgICAgIG91dGVyUG9zaXRpb25zID0gdGhpcy5fcGlja1Bvc2l0aW9uc0Zyb21TZWN0b3JEYXRhKCdvdXRlclBvc2l0aW9uJyksXG4gICAgICAgICAgICBmaWx0ZXJlZFBvc2l0aW9ucyA9IHR1aS51dGlsLmZpbHRlcihvdXRlclBvc2l0aW9ucywgZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9hZGRFbmRQb3NpdGlvbihjZW50ZXJMZWZ0LCBmaWx0ZXJlZFBvc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuX3JlbmRlckxlZ2VuZExhYmVsKHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogb3V0ZXJQb3NpdGlvbnMsXG4gICAgICAgICAgICBmdW5jTW92ZVRvUG9zaXRpb246IHR1aS51dGlsLmJpbmQodGhpcy5fbW92ZVRvT3V0ZXJQb3NpdGlvbiwgdGhpcywgY2VudGVyTGVmdCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6ICc6Jm5ic3A7J1xuICAgICAgICB9LCBzZXJpZXNMYWJlbENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLnJlbmRlckxlZ2VuZExpbmVzKGZpbHRlcmVkUG9zaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIHNlcmllcyBsYWJlbC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWw6IGZ1bmN0aW9uKHNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsZWdlbmRBbGlnbiA9IHRoaXMubGVnZW5kQWxpZ247XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZS5pc091dGVyTGVnZW5kQWxpZ24obGVnZW5kQWxpZ24pKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJPdXRlckxlZ2VuZChzZXJpZXNMYWJlbENvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDZW50ZXJMZWdlbmQoc2VyaWVzTGFiZWxDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2hvd2luZyBhYm91dCBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGVMZWdlbmRMaW5lcygpO1xuICAgICAgICBTZXJpZXMucHJvdG90eXBlLmFuaW1hdGVTaG93aW5nQWJvdXRTZXJpZXNMYWJlbEFyZWEuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBsZWdlbmQgbGluZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfbW92ZUxlZ2VuZExpbmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbnRlckxlZnQgPSB0aGlzLmJvdW5kc01ha2VyLmdldERpbWVuc2lvbignY2hhcnQnKS53aWR0aCAvIDIsXG4gICAgICAgICAgICBvdXRlclBvc2l0aW9ucyA9IHRoaXMuX3BpY2tQb3NpdGlvbnNGcm9tU2VjdG9yRGF0YSgnb3V0ZXJQb3NpdGlvbicpLFxuICAgICAgICAgICAgZmlsdGVyZWRQb3NpdGlvbnMgPSB0dWkudXRpbC5maWx0ZXIob3V0ZXJQb3NpdGlvbnMsIGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYWRkRW5kUG9zaXRpb24oY2VudGVyTGVmdCwgZmlsdGVyZWRQb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIubW92ZUxlZ2VuZExpbmVzKGZpbHRlcmVkUG9zaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gY2xpY2sgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqL1xuICAgIG9uQ2xpY2tTZXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX2V4ZWN1dGVHcmFwaFJlbmRlcmVyKHBvc2l0aW9uLCAnY2xpY2tTZXJpZXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW92ZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIG1vdXNlIHBvc2l0aW9uXG4gICAgICovXG4gICAgb25Nb3ZlU2VyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLl9leGVjdXRlR3JhcGhSZW5kZXJlcihwb3NpdGlvbiwgJ21vdmVNb3VzZU9uU2VyaWVzJyk7XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihQaWVDaGFydFNlcmllcyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGllQ2hhcnRTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2VyaWVzIGJhc2UgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VyaWVzVGVtcGxhdGUgPSByZXF1aXJlKCcuL3Nlcmllc1RlbXBsYXRlJyksXG4gICAgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcmVuZGVyVXRpbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVuZGVyVXRpbCcpLFxuICAgIHBsdWdpbkZhY3RvcnkgPSByZXF1aXJlKCcuLi9mYWN0b3JpZXMvcGx1Z2luRmFjdG9yeScpO1xuXG52YXIgU2VyaWVzID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoLyoqIEBsZW5kcyBTZXJpZXMucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBTZXJpZXMgYmFzZSBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgU2VyaWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm9wdGlvbnMgc2VyaWVzIG9wdGlvbnNcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgc2VyaWVzIHRoZW1lXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsaWJUeXBlID0gcGFyYW1zLmxpYlR5cGUgfHwgY2hhcnRDb25zdC5ERUZBVUxUX1BMVUdJTjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhcnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydFR5cGUgPSBwYXJhbXMuY2hhcnRUeXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnQgdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gcGFyYW1zLmNvbXBvbmVudFR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgcHJvY2Vzc29yXG4gICAgICAgICAqIEB0eXBlIHtEYXRhUHJvY2Vzc29yfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhUHJvY2Vzc29yID0gcGFyYW1zLmRhdGFQcm9jZXNzb3I7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kcyBtYWtlclxuICAgICAgICAgKiBAdHlwZSB7Qm91bmRzTWFrZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc01ha2VyID0gcGFyYW1zLmJvdW5kc01ha2VyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VyIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAqIEB0eXBlIHtVc2VyRXZlbnRMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlckV2ZW50ID0gcGFyYW1zLnVzZXJFdmVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uc1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZW1lXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yZ1RoZW1lID0gdGhpcy50aGVtZSA9IHBhcmFtcy50aGVtZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hldGhlciBjaGFydCBoYXMgYXhlcyBvciBub3RcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0F4ZXMgPSAhIXBhcmFtcy5oYXNBeGVzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaCByZW5kZXJlclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyID0gcGx1Z2luRmFjdG9yeS5nZXQobGliVHlwZSwgcGFyYW1zLmNoYXJ0VHlwZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlcmllcyB2aWV3IGNsYXNzTmFtZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSAndHVpLWNoYXJ0LXNlcmllcy1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2VyaWVzIGNvbnRhaW5lclxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllcyBsYWJlbCBjb250YWluZXJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNlcmllcyBkYXRhXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48b2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzRGF0YSA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RlZCBsZWdlbmQgaW5kZXhcbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkTGVnZW5kSW5kZXggPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNlcmllcyBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX21ha2VTZXJpZXNEYXRhOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlcmllc0RhdGFcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZXJpZXMgZGF0YVxuICAgICAqL1xuICAgIGdldFNlcmllc0RhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXNEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGxhYmVsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0xhYmVsOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHBlcmNlbnQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBwZXJjZW50IHZhbHVlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRQZXJjZW50VmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRQZXJjZW50VmFsdWVzKHRoaXMuY2hhcnRUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgbGFiZWwgYXJlYVxuICAgICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSBzZXJpZXNMYWJlbENvbnRhaW5lciBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZXJpZXMgbGFiZWwgYXJlYSBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyU2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbihzZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICBpZiAoIXNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzZXJpZXNMYWJlbENvbnRhaW5lciA9IGRvbS5jcmVhdGUoJ2RpdicsICd0dWktY2hhcnQtc2VyaWVzLWxhYmVsLWFyZWEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0xhYmVsKHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIHNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgc2VyaWVzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2VyaWVzQ29udGFpbmVyIHNlcmllcyBhcmVhIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhIGZvciByZW5kZXJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmVuZGVyR3JhcGggZnVuY3Rpb24gZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclNlcmllc0FyZWE6IGZ1bmN0aW9uKHNlcmllc0NvbnRhaW5lciwgZGF0YSwgZnVuY1JlbmRlckdyYXBoKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ3NlcmllcycpLFxuICAgICAgICAgICAgZXhwYW5kZWRCb3VuZCwgc2VyaWVzRGF0YSwgc2VyaWVzTGFiZWxDb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgICAgICBleHBhbmRlZEJvdW5kID0gdGhpcy5oYXNBeGVzID8gcmVuZGVyVXRpbC5leHBhbmRCb3VuZChib3VuZCkgOiBib3VuZDtcbiAgICAgICAgdGhpcy5zZXJpZXNEYXRhID0gc2VyaWVzRGF0YSA9IHRoaXMuX21ha2VTZXJpZXNEYXRhKCk7XG5cbiAgICAgICAgcmVuZGVyVXRpbC5yZW5kZXJEaW1lbnNpb24oc2VyaWVzQ29udGFpbmVyLCBleHBhbmRlZEJvdW5kLmRpbWVuc2lvbik7XG4gICAgICAgIHRoaXMuX3JlbmRlclBvc2l0aW9uKHNlcmllc0NvbnRhaW5lciwgZXhwYW5kZWRCb3VuZC5wb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGZ1bmNSZW5kZXJHcmFwaCkge1xuICAgICAgICAgICAgZnVuY1JlbmRlckdyYXBoKGV4cGFuZGVkQm91bmQuZGltZW5zaW9uLCBzZXJpZXNEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcmllc0xhYmVsQ29udGFpbmVyID0gdGhpcy5fcmVuZGVyU2VyaWVzTGFiZWxBcmVhKHRoaXMuc2VyaWVzTGFiZWxDb250YWluZXIpO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciA9IHNlcmllc0xhYmVsQ29udGFpbmVyO1xuICAgICAgICAgICAgZG9tLmFwcGVuZChzZXJpZXNDb250YWluZXIsIHNlcmllc0xhYmVsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBhcmFtZXRlcnMgZm9yIGdyYXBoIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGRpbWVuc2lvbiBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBhcmFtZXRlcnMgZm9yIGdyYXBoIHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQYXJhbXNGb3JHcmFwaFJlbmRlcmluZzogZnVuY3Rpb24oZGltZW5zaW9uLCBzZXJpZXNEYXRhKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgZGltZW5zaW9uOiBkaW1lbnNpb24sXG4gICAgICAgICAgICBjaGFydFR5cGU6IHRoaXMuY2hhcnRUeXBlLFxuICAgICAgICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSwgc2VyaWVzRGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciByYXBoYWVsIGdyYXBoLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gZGltZW5zaW9uIGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVuZGVyR3JhcGg6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5fbWFrZVBhcmFtc0ZvckdyYXBoUmVuZGVyaW5nKGRpbWVuc2lvbiwgc2VyaWVzRGF0YSk7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZW5kZXIodGhpcy5zZXJpZXNDb250YWluZXIsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBzZXJpZXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gc2VyaWVzIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGVsID0gZG9tLmNyZWF0ZSgnRElWJywgdGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICAgIHRoaXMuc2VyaWVzQ29udGFpbmVyID0gZWw7XG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEoZWwsIGRhdGEsIHR1aS51dGlsLmJpbmQodGhpcy5fcmVuZGVyR3JhcGgsIHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGVtZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdGhlbWUgbGVnZW5kIHRoZW1lXG4gICAgICogQHBhcmFtIHs/QXJyYXkuPD9ib29sZWFuPn0gY2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHJldHVybnMge29iamVjdH0gdXBkYXRlZCB0aGVtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRoZW1lOiBmdW5jdGlvbih0aGVtZSwgY2hlY2tlZExlZ2VuZHMpIHtcbiAgICAgICAgdmFyIGNsb25lVGhlbWU7XG5cbiAgICAgICAgaWYgKCFjaGVja2VkTGVnZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGVtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lVGhlbWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoZW1lKSk7XG4gICAgICAgIGNsb25lVGhlbWUuY29sb3JzID0gdHVpLnV0aWwuZmlsdGVyKGNsb25lVGhlbWUuY29sb3JzLCBmdW5jdGlvbihjb2xvciwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VkTGVnZW5kc1tpbmRleF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjbG9uZVRoZW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXJlbmRlclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGEgZm9yIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBncm91cFZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRHcm91cFZhbHVlcyh0aGlzLmNoYXJ0VHlwZSksXG4gICAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5ncmFwaFJlbmRlcmVyLmNsZWFyKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcmllc0NvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VyaWVzRGF0YSA9IFtdO1xuXG4gICAgICAgIGlmIChncm91cFZhbHVlcyAmJiBncm91cFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGhlbWUgPSB0aGlzLl91cGRhdGVUaGVtZSh0aGlzLm9yZ1RoZW1lLCBkYXRhLmNoZWNrZWRMZWdlbmRzKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIGRhdGEsIHR1aS51dGlsLmJpbmQodGhhdC5fcmVuZGVyR3JhcGgsIHRoaXMpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsU2hvd2VyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmxhYmVsU2hvd2VyLnRpbWVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltYXRlQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHJhcGhhZWwgZ3JhcGguXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBkaW1lbnNpb24gZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNpemVHcmFwaDogZnVuY3Rpb24oZGltZW5zaW9uLCBzZXJpZXNEYXRhKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5yZXNpemUodHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uXG4gICAgICAgIH0sIHNlcmllc0RhdGEpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHNlcmllcyBjb21wb25lbnQuXG4gICAgICogfX0gYm91bmQgc2VyaWVzIGJvdW5kXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclNlcmllc0FyZWEodGhpcy5zZXJpZXNDb250YWluZXIsIGRhdGEsIHR1aS51dGlsLmJpbmQodGhpcy5fcmVzaXplR3JhcGgsIHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGJvdW5kc1xuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIHNlcmllcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uIHNlcmllcyBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclBvc2l0aW9uOiBmdW5jdGlvbihlbCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGhpZGRlbldpZHRoID0gcmVuZGVyVXRpbC5pc09sZEJyb3dzZXIoKSA/IGNoYXJ0Q29uc3QuSElEREVOX1dJRFRIIDogMDtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGVsLCB7XG4gICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCAtIChoaWRkZW5XaWR0aCAqIDIpLFxuICAgICAgICAgICAgbGVmdDogcG9zaXRpb24ubGVmdCAtIGhpZGRlbldpZHRoXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbGltaXQgZGlzdGFuY2UgZnJvbSB6ZXJvIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fSBsaW1pdCBsaW1pdFxuICAgICAqIEByZXR1cm5zIHt7dG9NYXg6IG51bWJlciwgdG9NaW46IG51bWJlcn19IHBpeGVsIGRpc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGltaXREaXN0YW5jZUZyb21aZXJvUG9pbnQ6IGZ1bmN0aW9uKHNpemUsIGxpbWl0KSB7XG4gICAgICAgIHZhciBtaW4gPSBsaW1pdC5taW4sXG4gICAgICAgICAgICBtYXggPSBsaW1pdC5tYXgsXG4gICAgICAgICAgICBkaXN0YW5jZSA9IG1heCAtIG1pbixcbiAgICAgICAgICAgIHRvTWF4ID0gMCxcbiAgICAgICAgICAgIHRvTWluID0gMDtcblxuICAgICAgICBpZiAobWluIDw9IDAgJiYgbWF4ID49IDApIHtcbiAgICAgICAgICAgIHRvTWF4ID0gKGRpc3RhbmNlICsgbWluKSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgICAgIHRvTWluID0gKGRpc3RhbmNlIC0gbWF4KSAvIGRpc3RhbmNlICogc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b01heDogdG9NYXgsXG4gICAgICAgICAgICB0b01pbjogdG9NaW5cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBsYWJlbCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVGFyZ2V0IHRhcmdldCBlbGVtZW50XG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBsYWJlbCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZExhYmVsRWxlbWVudDogZnVuY3Rpb24oZWxUYXJnZXQpIHtcbiAgICAgICAgdmFyIGVsTGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3MoZWxUYXJnZXQsIGNoYXJ0Q29uc3QuQ0xBU1NfTkFNRV9TRVJJRVNfTEFCRUwpKSB7XG4gICAgICAgICAgICBlbExhYmVsID0gZWxUYXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbExhYmVsID0gZG9tLmZpbmRQYXJlbnRCeUNsYXNzKGVsVGFyZ2V0LCBjaGFydENvbnN0LkNMQVNTX05BTUVfU0VSSUVTX0xBQkVMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbExhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNob3dBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBkYXRhIGRhdGFcbiAgICAgKi9cbiAgICBvblNob3dBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0FuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zaG93QW5pbWF0aW9uKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGhpZGVBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBkYXRhIGRhdGFcbiAgICAgKi9cbiAgICBvbkhpZGVBbmltYXRpb246IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5oaWRlQW5pbWF0aW9uKGRhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNob3dHcm91cEFuaW1hdGlvbiBmdW5jdGlvbiBvZiBncmFwaFJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIG9uU2hvd0dyb3VwQW5pbWF0aW9uOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhSZW5kZXJlci5zaG93R3JvdXBBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIuc2hvd0dyb3VwQW5pbWF0aW9uKGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVG8gY2FsbCBoaWRlR3JvdXBBbmltYXRpb24gZnVuY3Rpb24gb2YgZ3JhcGhSZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBvbkhpZGVHcm91cEFuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoUmVuZGVyZXIuaGlkZUdyb3VwQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncmFwaFJlbmRlcmVyLmhpZGVHcm91cEFuaW1hdGlvbihpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGFuaW1hdGVDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmFwaFJlbmRlcmVyLmFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5hbmltYXRlKHR1aS51dGlsLmJpbmQodGhpcy5hbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBvcGFjaXR5IGNzc1RleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGNzc1RleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlT3BhY2l0eUNzc1RleHQ6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZ1bmNNYWtlT3BhY2l0eUNzc1RleHQ7XG4gICAgICAgIGlmIChyZW5kZXJVdGlsLmlzT2xkQnJvd3NlcigpKSB7XG4gICAgICAgICAgICBmdW5jTWFrZU9wYWNpdHlDc3NUZXh0ID0gZnVuY3Rpb24ob3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnO2ZpbHRlcjogYWxwaGEob3BhY2l0eT0nICsgKG9wYWNpdHkgKiAxMDApICsgJyknO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNNYWtlT3BhY2l0eUNzc1RleHQgPSBmdW5jdGlvbihfb3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnO29wYWNpdHk6ICcgKyBfb3BhY2l0eTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmNNYWtlT3BhY2l0eUNzc1RleHQ7XG4gICAgfSkoKSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaHRtbCBhYm91dCBzZXJpZXMgbGFiZWwuXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdyb3VwSW5kZXggZ3JvdXAgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sIHN0cmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTZXJpZXNMYWJlbEh0bWw6IGZ1bmN0aW9uKHBvc2l0aW9uLCB2YWx1ZSwgZ3JvdXBJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNzc09iaiA9IHR1aS51dGlsLmV4dGVuZChwb3NpdGlvbiwgdGhpcy50aGVtZS5sYWJlbCk7XG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNOdWxsKHRoaXMuc2VsZWN0ZWRMZWdlbmRJbmRleCkgJiYgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgY3NzT2JqLm9wYWNpdHkgPSB0aGlzLl9tYWtlT3BhY2l0eUNzc1RleHQoMC4zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzc09iai5vcGFjaXR5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmllc1RlbXBsYXRlLnRwbFNlcmllc0xhYmVsKHtcbiAgICAgICAgICAgIGNzc1RleHQ6IHNlcmllc1RlbXBsYXRlLnRwbENzc1RleHQoY3NzT2JqKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGdyb3VwSW5kZXg6IGdyb3VwSW5kZXgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgc2hvd2luZyBhYm91dCBzZXJpZXMgbGFiZWwgYXJlYS5cbiAgICAgKi9cbiAgICBhbmltYXRlU2hvd2luZ0Fib3V0U2VyaWVzTGFiZWxBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGlmICgoIXRoaXMub3B0aW9ucy5zaG93TGFiZWwgJiYgIXRoaXMubGVnZW5kQWxpZ24pIHx8ICF0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcblxuICAgICAgICBpZiAocmVuZGVyVXRpbC5pc0lFNygpKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyLnN0eWxlLmZpbHRlciA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYWJlbFNob3dlciA9IG5ldyB0dWkuY29tcG9uZW50LkVmZmVjdHMuRmFkZSh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMzAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGFiZWxTaG93ZXIuYWN0aW9uKHtcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBlbmQ6IDEsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoYXQubGFiZWxTaG93ZXIudGltZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmxhYmVsU2hvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgZXhwb3J0YXRpb24gZGF0YSBmb3Igc2VyaWVzIHR5cGUgdXNlckV2ZW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXJpZXNEYXRhIHNlcmllcyBkYXRhXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBleHBvcnQgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VFeHBvcnRhdGlvblNlcmllc0RhdGE6IGZ1bmN0aW9uKHNlcmllc0RhdGEpIHtcbiAgICAgICAgdmFyIGxlZ2VuZEluZGV4ID0gc2VyaWVzRGF0YS5pbmRleGVzLmluZGV4LFxuICAgICAgICAgICAgbGVnZW5kRGF0YSA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmREYXRhKGxlZ2VuZEluZGV4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhcnRUeXBlOiBsZWdlbmREYXRhLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgIGxlZ2VuZDogbGVnZW5kRGF0YS5sYWJlbCxcbiAgICAgICAgICAgIGxlZ2VuZEluZGV4OiBsZWdlbmRJbmRleCxcbiAgICAgICAgICAgIGluZGV4OiBzZXJpZXNEYXRhLmluZGV4ZXMuZ3JvdXBJbmRleFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGdyYXBoIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jTmFtZSBmdW5jdGlvbiBuYW1lXG4gICAgICogQHJldHVybnMgeyp9IHJlc3VsdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leGVjdXRlR3JhcGhSZW5kZXJlcjogZnVuY3Rpb24ocG9zaXRpb24sIGZ1bmNOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGhpcy5maXJlKCdoaWRlVG9vbHRpcENvbnRhaW5lcicpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZ3JhcGhSZW5kZXJlcltmdW5jTmFtZV0ocG9zaXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xhYmVsKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd1Rvb2x0aXBDb250YWluZXInKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHNlbGVjdFNlcmllcyBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNlcmllc0RhdGEgc2VyaWVzIGRhdGFcbiAgICAgKi9cbiAgICBvblNlbGVjdFNlcmllczogZnVuY3Rpb24oc2VyaWVzRGF0YSkge1xuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdzZWxlY3RTZXJpZXMnLCB0aGlzLl9tYWtlRXhwb3J0YXRpb25TZXJpZXNEYXRhKHNlcmllc0RhdGEpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZWxlY3RTZXJpZXMoc2VyaWVzRGF0YS5pbmRleGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIHVuc2VsZWN0U2VyaWVzIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWVzRGF0YSBzZXJpZXMgZGF0YS5cbiAgICAgKi9cbiAgICBvblVuc2VsZWN0U2VyaWVzOiBmdW5jdGlvbihzZXJpZXNEYXRhKSB7XG4gICAgICAgIHRoaXMudXNlckV2ZW50LmZpcmUoJ3Vuc2VsZWN0U2VyaWVzJywgdGhpcy5fbWFrZUV4cG9ydGF0aW9uU2VyaWVzRGF0YShzZXJpZXNEYXRhKSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUmVuZGVyZXIudW5zZWxlY3RTZXJpZXMoc2VyaWVzRGF0YS5pbmRleGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKk9uIHNlbGVjdCBsZWdlbmQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSBsZWdlbmRJbmRleCBsZWdlbmQgaW5kZXhcbiAgICAgKi9cbiAgICBvblNlbGVjdExlZ2VuZDogZnVuY3Rpb24oY2hhcnRUeXBlLCBsZWdlbmRJbmRleCkge1xuICAgICAgICB2YXIgZ3JvdXBWYWx1ZXMgPSB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0R3JvdXBWYWx1ZXModGhpcy5jaGFydFR5cGUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNoYXJ0VHlwZSAhPT0gY2hhcnRUeXBlICYmICF0dWkudXRpbC5pc051bGwobGVnZW5kSW5kZXgpKSB7XG4gICAgICAgICAgICBsZWdlbmRJbmRleCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZExlZ2VuZEluZGV4ID0gbGVnZW5kSW5kZXg7XG5cbiAgICAgICAgaWYgKGdyb3VwVmFsdWVzICYmIGdyb3VwVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyU2VyaWVzQXJlYSh0aGlzLnNlcmllc0NvbnRhaW5lciwgdGhpcy5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhSZW5kZXJlci5zZWxlY3RMZWdlbmQobGVnZW5kSW5kZXgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgbGFiZWwuXG4gICAgICovXG4gICAgc2hvd0xhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dMYWJlbCA9IHRydWU7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLnNlcmllc0xhYmVsQ29udGFpbmVyLCAnc2hvdyBvcGFjaXR5Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgbGFiZWwuXG4gICAgICovXG4gICAgaGlkZUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dMYWJlbCA9IGZhbHNlO1xuICAgICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5zZXJpZXNMYWJlbENvbnRhaW5lciwgJ3Nob3cnKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJpZXM7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2Ygc2VyaWVzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGVtcGxhdGVNYWtlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdGVtcGxhdGVNYWtlcicpO1xuXG52YXIgaHRtbHMgPSB7XG4gICAgSFRNTF9TRVJJRVNfTEFCRUw6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LXNlcmllcy1sYWJlbFwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiIGRhdGEtZ3JvdXAtaW5kZXg9XCJ7eyBncm91cEluZGV4IH19XCIgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCI+e3sgdmFsdWUgfX08L2Rpdj4nLFxuICAgIFRFWFRfQ1NTX1RFWFQ6ICdsZWZ0Ont7IGxlZnQgfX1weDt0b3A6e3sgdG9wIH19cHg7Zm9udC1mYW1pbHk6e3sgZm9udEZhbWlseSB9fTtmb250LXNpemU6e3sgZm9udFNpemUgfX1weHt7b3BhY2l0eX19JyxcbiAgICBIVE1MX1pPT01fQlVUVE9OUzogJzxhIGNsYXNzPVwidHVpLWNoYXJ0LXpvb20tYnRuXCIgaHJlZj1cIiNcIiBkYXRhLW1hZ249XCIyXCI+PGRpdiBjbGFzcz1cImhvcml6b250YWwtbGluZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJ2ZXJ0aWNhbC1saW5lXCI+PC9kaXY+PC9hPicgK1xuICAgICAgICAgICAgJzxhIGNsYXNzPVwidHVpLWNoYXJ0LXpvb20tYnRuXCIgaHJlZj1cIiNcIiBkYXRhLW1hZ249XCIwLjVcIj48ZGl2IGNsYXNzPVwiaG9yaXpvbnRhbC1saW5lXCI+PC9kaXY+PC9hPidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRwbFNlcmllc0xhYmVsOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfU0VSSUVTX0xBQkVMKSxcbiAgICB0cGxDc3NUZXh0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLlRFWFRfQ1NTX1RFWFQpLFxuICAgIFpPT01fQlVUVE9OUzogaHRtbHMuSFRNTF9aT09NX0JVVFRPTlNcbn07XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgWm9vbSBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZXJpZXNUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vc2VyaWVzVGVtcGxhdGUnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyksXG4gICAgZXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXZlbnRMaXN0ZW5lcicpO1xuXG52YXIgWm9vbSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgWm9vbS5wcm90b3R5cGUgKi97XG4gICAgLyoqXG4gICAgICogWm9vbSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogQGNvbnN0cnVjdHMgWm9vbVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9ICd0dWktY2hhcnQtem9vbS1hcmVhJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQm91bmRzIG1ha2VyXG4gICAgICAgICAqIEB0eXBlIHtCb3VuZHNNYWtlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYm91bmRzTWFrZXIgPSBwYXJhbXMuYm91bmRzTWFrZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hZ25pZmljYXRpb24uXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hZ24gPSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB6b29tIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb20uY3JlYXRlKCdESVYnLCB0aGlzLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCArPSBzZXJpZXNUZW1wbGF0ZS5aT09NX0JVVFRPTlM7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24oY29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCdzZXJpZXMnKSk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV2ZW50KGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBidXR0b24gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgez9IVE1MRWxlbWVudH0gYnV0dG9uIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kQnRuRWxlbWVudDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHZhciBidG5DbGFzc05hbWUgPSAndHVpLWNoYXJ0LXpvb20tYnRuJyxcbiAgICAgICAgICAgIGJ0bkVsZW1lbnQgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKCFkb20uaGFzQ2xhc3ModGFyZ2V0LCBidG5DbGFzc05hbWUpKSB7XG4gICAgICAgICAgICBidG5FbGVtZW50ID0gZG9tLmZpbmRQYXJlbnRCeUNsYXNzKHRhcmdldCwgYnRuQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBidG5FbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBjbGljay5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7P2Jvb2xlYW59IHByZXZlbnQgZGVmYXVsdCBmb3IgaWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICBidG5FbGVtZW50ID0gdGhpcy5fZmluZEJ0bkVsZW1lbnQodGFyZ2V0KSxcbiAgICAgICAgICAgIGNoYW5nZWRNYWduID0gMCxcbiAgICAgICAgICAgIG1hZ247XG5cbiAgICAgICAgaWYgKGJ0bkVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1hZ24gPSBwYXJzZUZsb2F0KGJ0bkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1hZ24nKSk7XG4gICAgICAgICAgICBjaGFuZ2VkTWFnbiA9IHRoaXMubWFnbiAqIG1hZ247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZE1hZ24gPj0gMSkge1xuICAgICAgICAgICAgdGhpcy5tYWduID0gY2hhbmdlZE1hZ247XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb20nLCB0aGlzLm1hZ24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggZXZlbnQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2F0dGFjaEV2ZW50OiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lci5iaW5kRXZlbnQoJ2NsaWNrJywgY29udGFpbmVyLCB0dWkudXRpbC5iaW5kKHRoaXMuX29uQ2xpY2ssIHRoaXMpKTtcbiAgICB9XG59KTtcblxudHVpLnV0aWwuQ3VzdG9tRXZlbnRzLm1peGluKFpvb20pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFpvb207XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX0NPTE9SID0gJyMwMDAwMDAnLFxuICAgIERFRkFVTFRfQkFDS0dST1VORCA9ICcjZmZmZmZmJyxcbiAgICBFTVBUWSA9ICcnLFxuICAgIERFRkFVTFRfQVhJUyA9IHtcbiAgICAgICAgdGlja0NvbG9yOiBERUZBVUxUX0NPTE9SLFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9XG4gICAgfTtcblxudmFyIGRlZmF1bHRUaGVtZSA9IHtcbiAgICBjaGFydDoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBERUZBVUxUX0JBQ0tHUk9VTkQsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdWZXJkYW5hJ1xuICAgIH0sXG4gICAgdGl0bGU6IHtcbiAgICAgICAgZm9udFNpemU6IDE4LFxuICAgICAgICBmb250RmFtaWx5OiBFTVBUWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICB9LFxuICAgIHlBeGlzOiBERUZBVUxUX0FYSVMsXG4gICAgeEF4aXM6IERFRkFVTFRfQVhJUyxcbiAgICBwbG90OiB7XG4gICAgICAgIGxpbmVDb2xvcjogJyNkZGRkZGQnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnI2ZmZmZmZidcbiAgICB9LFxuICAgIHNlcmllczoge1xuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICAgICAgZm9udEZhbWlseTogRU1QVFksXG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBjb2xvcnM6IFsnI2FjNDE0MicsICcjZDI4NDQ1JywgJyNmNGJmNzUnLCAnIzkwYTk1OScsICcjNzViNWFhJywgJyM2YTlmYjUnLCAnI2FhNzU5ZicsICcjOGY1NTM2J10sXG4gICAgICAgIGJvcmRlckNvbG9yOiBFTVBUWSxcbiAgICAgICAgc2VsZWN0aW9uQ29sb3I6IEVNUFRZLFxuICAgICAgICBzdGFydENvbG9yOiAnI0Y0RjRGNCcsXG4gICAgICAgIGVuZENvbG9yOiAnIzM0NTM5MScsXG4gICAgICAgIG92ZXJDb2xvcjogJyNGMEM5NTInXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IEVNUFRZLFxuICAgICAgICAgICAgY29sb3I6IERFRkFVTFRfQ09MT1JcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdFRoZW1lO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdyb3VwIHRvb2x0aXAgY29tcG9uZW50LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9vbHRpcEJhc2UgPSByZXF1aXJlKCcuL3Rvb2x0aXBCYXNlJyksXG4gICAgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCA9IHJlcXVpcmUoJy4vZ3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCcpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIGRvbSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9tSGFuZGxlcicpLFxuICAgIHJlbmRlclV0aWwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3JlbmRlclV0aWwnKSxcbiAgICBkZWZhdWx0VGhlbWUgPSByZXF1aXJlKCcuLi90aGVtZXMvZGVmYXVsdFRoZW1lJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIEdyb3VwVG9vbHRpcCBjb21wb25lbnQuXG4gKiBAY2xhc3MgR3JvdXBUb29sdGlwXG4gKi9cbnZhciBHcm91cFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBHcm91cFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cCB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAY29uc3RydWN0cyBHcm91cFRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBUb29sdGlwQmFzZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHt2YWx1ZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgY2hhcnRUeXBlOiBzdHJpbmcsIHN1ZmZpeDogP3N0cmluZ30+fSBpdGVtcyBpdGVtcyBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9vbHRpcCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBIdG1sOiBmdW5jdGlvbihjYXRlZ29yeSwgaXRlbXMpIHtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdG9vbHRpcFRlbXBsYXRlLnRwbEdyb3VwSXRlbSxcbiAgICAgICAgICAgIGNzc1RleHRUZW1wbGF0ZSA9IHRvb2x0aXBUZW1wbGF0ZS50cGxHcm91cENzc1RleHQsXG4gICAgICAgICAgICBjb2xvcnMgPSB0aGlzLl9tYWtlQ29sb3JzKHRoaXMudGhlbWUpLFxuICAgICAgICAgICAgaXRlbXNIdG1sID0gdHVpLnV0aWwubWFwKGl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBjc3NUZXh0VGVtcGxhdGUoe2NvbG9yOiBjb2xvcnNbaW5kZXhdfSlcbiAgICAgICAgICAgICAgICB9LCBpdGVtKSk7XG4gICAgICAgICAgICB9LCB0aGlzKS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdG9vbHRpcFRlbXBsYXRlLnRwbEdyb3VwKHtcbiAgICAgICAgICAgIGNhdGVnb3J5OiBjYXRlZ29yeSxcbiAgICAgICAgICAgIGl0ZW1zOiBpdGVtc0h0bWxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9BTElHTl9PUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9HUk9VUF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyksXG4gICAgICAgICAgICBjaGFydERpbWVuc2lvbiA9IHRoaXMuYm91bmRzTWFrZXIuZ2V0RGltZW5zaW9uKCdjaGFydCcpLFxuICAgICAgICAgICAgYm91bmQgPSB0aGlzLmJvdW5kc01ha2VyLmdldEJvdW5kKCd0b29sdGlwJyk7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsID0gbmV3IEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwoY2hhcnREaW1lbnNpb24sIGJvdW5kLCB0aGlzLmlzVmVydGljYWwsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3JnV2hvbGVMZWdlbmREYXRhID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFdob2xlTGVnZW5kRGF0YSgpO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICogQHBhcmFtIHt7Y2hlY2tlZExlZ2VuZHM6IEFycmF5Ljxib29sZWFuPn19IGRhdGEgcmVuZGVyaW5nIGRhdGFcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZXJlbmRlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBUb29sdGlwQmFzZS5wcm90b3R5cGUucmVyZW5kZXIuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgICAgICB0aGlzLnRoZW1lID0gdGhpcy5fdXBkYXRlTGVnZW5kVGhlbWUoZGF0YS5jaGVja2VkTGVnZW5kcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBsZWdlbmQgdGhlbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBBcnJheS48Ym9vbGVhbj59Y2hlY2tlZExlZ2VuZHMgY2hlY2tlZCBsZWdlbmRzXG4gICAgICogQHJldHVybnMge3tjb2xvcnM6IEFycmF5LjxzdHJpbmc+fX0gbGVnZW5kIHRoZW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlTGVnZW5kVGhlbWU6IGZ1bmN0aW9uKGNoZWNrZWRMZWdlbmRzKSB7XG4gICAgICAgIHZhciBjb2xvcnMgPSBbXTtcblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoQXJyYXkodGhpcy5vcmdXaG9sZUxlZ2VuZERhdGEsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBfY2hlY2tlZExlZ2VuZHMgPSBjaGVja2VkTGVnZW5kc1tpdGVtLmNoYXJ0VHlwZV0gfHwgY2hlY2tlZExlZ2VuZHM7XG4gICAgICAgICAgICBpZiAoX2NoZWNrZWRMZWdlbmRzW2l0ZW0uaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goaXRlbS50aGVtZS5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcnM6IGNvbG9yc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHRvb2x0aXAgZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPG9iamVjdD59IHRvb2x0aXAgZGF0YVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHVpLnV0aWwubWFwKHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRXaG9sZUZvcm1hdHRlZFZhbHVlcygpLCBmdW5jdGlvbih2YWx1ZXMsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiB0aGlzLmRhdGFQcm9jZXNzb3IuZ2V0Q2F0ZWdvcnkoaW5kZXgpLFxuICAgICAgICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjb2xvcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZW1lIHRvb2x0aXAgdGhlbWVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IGNvbG9yc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VDb2xvcnM6IGZ1bmN0aW9uKHRoZW1lKSB7XG4gICAgICAgIHZhciBjb2xvckluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlZ2VuZExhYmVscyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRXaG9sZUxlZ2VuZERhdGEoKSxcbiAgICAgICAgICAgIGRlZmF1bHRDb2xvcnMsIGNvbG9ycywgcHJldkNoYXJ0VHlwZTtcblxuICAgICAgICBpZiAodGhlbWUuY29sb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdENvbG9ycyA9IGRlZmF1bHRUaGVtZS5zZXJpZXMuY29sb3JzLnNsaWNlKDAsIGxlZ2VuZExhYmVscy5sZW5ndGgpO1xuXG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodHVpLnV0aWwucGx1Y2sobGVnZW5kTGFiZWxzLCAnY2hhcnRUeXBlJyksIGZ1bmN0aW9uKGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICAgICAgaWYgKHByZXZDaGFydFR5cGUgIT09IGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbG9ycyA9IHRoZW1lW2NoYXJ0VHlwZV0gPyB0aGVtZVtjaGFydFR5cGVdLmNvbG9ycyA6IGRlZmF1bHRDb2xvcnM7XG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2Q2hhcnRUeXBlID0gY2hhcnRUeXBlO1xuICAgICAgICAgICAgY29sb3IgPSBjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgICAgICBjb2xvckluZGV4ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHJlbmRlcmluZyBkYXRhIGFib3V0IGxlZ2VuZCBpdGVtLlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHZhbHVlcyB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHt2YWx1ZTogc3RyaW5nLCBsZWdlbmQ6IHN0cmluZywgY2hhcnRUeXBlOiBzdHJpbmcsIHN1ZmZpeDogP3N0cmluZ30+fSBsZWdlbmQgaXRlbSBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VJdGVtUmVuZGVyaW5nRGF0YTogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0dWkudXRpbC5tYXAodmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsZWdlbmRMYWJlbCA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRMZWdlbmREYXRhKGluZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmRMYWJlbC5sYWJlbCxcbiAgICAgICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZExhYmVsLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICBzdWZmaXg6IHRoaXMuc3VmZml4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cEluZGV4IGdyb3VwIGluZGV4XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9vbHRpcCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUdyb3VwVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGdyb3VwSW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFbZ3JvdXBJbmRleF0sXG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuX21ha2VJdGVtUmVuZGVyaW5nRGF0YShkYXRhLnZhbHVlcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVGdW5jKGRhdGEuY2F0ZWdvcnksIGl0ZW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRvb2x0aXAgc2VjdG9yIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSBzZWN0b3IgZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFRvb2x0aXBTZWN0b3JFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwVG9vbHRpcFNlY3RvcjtcblxuICAgICAgICBpZiAoIXRoaXMuZ3JvdXBUb29sdGlwU2VjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwVG9vbHRpcFNlY3RvciA9IGdyb3VwVG9vbHRpcFNlY3RvciA9IGRvbS5jcmVhdGUoJ0RJVicsICd0dWktY2hhcnQtZ3JvdXAtdG9vbHRpcC1zZWN0b3InKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy50b29sdGlwQ29udGFpbmVyLCBncm91cFRvb2x0aXBTZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBUb29sdGlwU2VjdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yIG9mIHZlcnRpY2FsIHR5cGUgY2hhcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xpbmUgd2hldGhlciBsaW5lIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVmVydGljYWxUb29sdGlwU2VjdG9yQm91bmQ6IGZ1bmN0aW9uKGhlaWdodCwgcmFuZ2UsIGlzTGluZSkge1xuICAgICAgICB2YXIgd2lkdGg7XG5cbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgd2lkdGggPSAxO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcmFuZ2Uuc3RhcnQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSxcbiAgICAgICAgICAgICAgICB0b3A6IGNoYXJ0Q29uc3QuU0VSSUVTX0VYUEFORF9TSVpFXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYm91bmQgYWJvdXQgdG9vbHRpcCBzZWN0b3Igb2YgaG9yaXpvbnRhbCB0eXBlIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aFxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDpudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlSG9yaXpvbnRhbFRvb2x0aXBTZWN0b3JCb3VuZDogZnVuY3Rpb24od2lkdGgsIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaW1lbnNpb246IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByYW5nZS5lbmQgLSByYW5nZS5zdGFydCArIGNoYXJ0Q29uc3QuSElEREVOX1dJRFRIXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRSAtIGNoYXJ0Q29uc3QuSElEREVOX1dJRFRILFxuICAgICAgICAgICAgICAgIHRvcDogcmFuZ2Uuc3RhcnQgKyBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGJvdW5kIGFib3V0IHRvb2x0aXAgc2VjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHdpZHRoIG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDpudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWZXJ0aWNhbCB3aGV0aGVyIHZlcnRpY2FsIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5lIHdoZXRoZXIgbGluZSB0eXBlIG9yIG5vdFxuICAgICAqIEByZXR1cm5zIHt7ZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gYm91bmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcFNlY3RvckJvdW5kOiBmdW5jdGlvbihzaXplLCByYW5nZSwgaXNWZXJ0aWNhbCwgaXNMaW5lKSB7XG4gICAgICAgIHZhciBib3VuZDtcblxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlVmVydGljYWxUb29sdGlwU2VjdG9yQm91bmQoc2l6ZSwgcmFuZ2UsIGlzTGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3VuZCA9IHRoaXMuX21ha2VIb3Jpem9udGFsVG9vbHRpcFNlY3RvckJvdW5kKHNpemUsIHJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwIHNlY3Rvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6bnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG93VG9vbHRpcFNlY3RvcjogZnVuY3Rpb24oc2l6ZSwgcmFuZ2UsIGlzVmVydGljYWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBncm91cFRvb2x0aXBTZWN0b3IgPSB0aGlzLl9nZXRUb29sdGlwU2VjdG9yRWxlbWVudCgpLFxuICAgICAgICAgICAgaXNMaW5lID0gKHJhbmdlLnN0YXJ0ID09PSByYW5nZS5lbmQpLFxuICAgICAgICAgICAgYm91bmQgPSB0aGlzLl9tYWtlVG9vbHRpcFNlY3RvckJvdW5kKHNpemUsIHJhbmdlLCBpc1ZlcnRpY2FsLCBpc0xpbmUpO1xuXG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnc2hvd0dyb3VwVG9vbHRpcExpbmUnLCBib3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlckRpbWVuc2lvbihncm91cFRvb2x0aXBTZWN0b3IsIGJvdW5kLmRpbWVuc2lvbik7XG4gICAgICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGdyb3VwVG9vbHRpcFNlY3RvciwgYm91bmQucG9zaXRpb24pO1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGdyb3VwVG9vbHRpcFNlY3RvciwgJ3Nob3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnc2hvd0dyb3VwQW5pbWF0aW9uJywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRvb2x0aXAgc2VjdG9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hpZGVUb29sdGlwU2VjdG9yOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgZ3JvdXBUb29sdGlwU2VjdG9yID0gdGhpcy5fZ2V0VG9vbHRpcFNlY3RvckVsZW1lbnQoKTtcblxuICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZ3JvdXBUb29sdGlwU2VjdG9yLCAnc2hvdycpO1xuICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cEFuaW1hdGlvbicsIGluZGV4KTtcbiAgICAgICAgdGhpcy5maXJlKCdoaWRlR3JvdXBUb29sdGlwTGluZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRvb2x0aXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2luZGV4OiBudW1iZXIsIHJhbmdlOiB7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9LFxuICAgICAqICAgICAgICAgIHNpemU6IG51bWJlciwgZGlyZWN0aW9uOiBzdHJpbmcsIGlzVmVydGljYWw6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgfX0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwcmV2UG9zaXRpb24gcHJldiBwb3NpdGlvblxuICAgICAqL1xuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbihlbFRvb2x0aXAsIHBhcmFtcywgcHJldlBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24sIHBvc2l0aW9uO1xuXG4gICAgICAgIGlmICghdHVpLnV0aWwuaXNVbmRlZmluZWQodGhpcy5wcmV2SW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2hpZGVHcm91cEFuaW1hdGlvbicsIHRoaXMucHJldkluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVG9vbHRpcC5pbm5lckhUTUwgPSB0aGlzLl9tYWtlR3JvdXBUb29sdGlwSHRtbChwYXJhbXMuaW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVCZWZvcmVTaG93VG9vbHRpcChwYXJhbXMuaW5kZXgsIHBhcmFtcy5yYW5nZSk7XG5cbiAgICAgICAgZG9tLmFkZENsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcblxuICAgICAgICB0aGlzLl9zaG93VG9vbHRpcFNlY3RvcihwYXJhbXMuc2l6ZSwgcGFyYW1zLnJhbmdlLCBwYXJhbXMuaXNWZXJ0aWNhbCwgcGFyYW1zLmluZGV4KTtcblxuICAgICAgICBkaW1lbnNpb24gPSB0aGlzLmdldFRvb2x0aXBEaW1lbnNpb24oZWxUb29sdGlwKTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uTW9kZWwuY2FsY3VsYXRlUG9zaXRpb24oZGltZW5zaW9uLCBwYXJhbXMucmFuZ2UpO1xuXG4gICAgICAgIHRoaXMubW92ZVRvUG9zaXRpb24oZWxUb29sdGlwLCBwb3NpdGlvbiwgcHJldlBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLl9maXJlQWZ0ZXJTaG93VG9vbHRpcChwYXJhbXMuaW5kZXgsIHBhcmFtcy5yYW5nZSwge1xuICAgICAgICAgICAgZWxlbWVudDogZWxUb29sdGlwLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJldkluZGV4ID0gcGFyYW1zLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGJlZm9yZVNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUJlZm9yZVNob3dUb29sdGlwOiBmdW5jdGlvbihpbmRleCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYmVmb3JlU2hvd1Rvb2x0aXAnLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgYWZ0ZXJTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IGluZGV4XG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZUFmdGVyU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4LCByYW5nZSwgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYWZ0ZXJTaG93VG9vbHRpcCcsIHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogcmFuZ2VcbiAgICAgICAgfSwgYWRkaXRpb25QYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggaW5kZXhcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwLCBpbmRleCkge1xuICAgICAgICBkZWxldGUgdGhpcy5wcmV2SW5kZXg7XG4gICAgICAgIHRoaXMuX2hpZGVUb29sdGlwU2VjdG9yKGluZGV4KTtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcbiAgICAgICAgZWxUb29sdGlwLnN0eWxlLmNzc1RleHQgPSAnJztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cFRvb2x0aXA7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgR3JvdXBUb29sdGlwUG9zaXRpb25Nb2RlbCBpcyBwb3NpdGlvbiBtb2RlbCBmb3IgZ3JvdXAgdG9vbHRpcC4uXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGFydENvbnN0ID0gcmVxdWlyZSgnLi4vY29uc3QnKTtcblxudmFyIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwgPSB0dWkudXRpbC5kZWZpbmVDbGFzcygvKiogQGxlbmRzIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWwucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBHcm91cFRvb2x0aXBQb3NpdGlvbk1vZGVsIGlzIHBvc2l0aW9uIG1vZGVsIGZvciBncm91cCB0b29sdGlwLlxuICAgICAqIEBjb25zdHJ1Y3RzIEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWxcbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IGNoYXJ0RGltZW5zaW9uIGNoYXJ0IGRpbWVuc2lvblxuICAgICAqIEBwYXJhbSB7e1xuICAgICAqICAgICAgZGltZW5zaW9uOiB7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9LFxuICAgICAqICAgICAgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfVxuICAgICAqIH19IGFyZWFCb3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmVydGljYWwgd2hldGhlciB2ZXJ0aWNhbCBvciBub3RcbiAgICAgKiBAcGFyYW0ge3thbGlnbjogP3N0cmluZywgcG9zaXRpb246IHtsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX19IG9wdGlvbnMgdG9vbHRpcCBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgaXNWZXJ0aWNhbCwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2hhcnQgZGltZW5zaW9uXG4gICAgICAgICAqIEB0eXBlIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFydERpbWVuc2lvbiA9IGNoYXJ0RGltZW5zaW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgICAgICogQHR5cGUge3tkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcmVhQm91bmQgPSBhcmVhQm91bmQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gaXNWZXJ0aWNhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdG9vbHRpcCBvcHRpb25zXG4gICAgICAgICAqIEB0eXBlIHt7YWxpZ246ID9zdHJpbmcsIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGNhY2hpbmdcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0ge307XG5cbiAgICAgICAgdGhpcy5fc2V0RGF0YShjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBpc1ZlcnRpY2FsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGhvcml6b250YWwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0SG9yaXpvbnRhbERpcmVjdGlvbjogZnVuY3Rpb24oYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbjtcblxuICAgICAgICBhbGlnbk9wdGlvbiA9IGFsaWduT3B0aW9uIHx8ICcnO1xuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbGVmdCcpID4gLTEpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignY2VudGVyJykgPiAtMSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9DRU5URVI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHZlcnRpY2FsIGRhdGEuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydERpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBhcmVhQm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBhbGlnbk9wdGlvbiBhbGlnbiBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7e1xuICAgICAqICAgICAgcG9zaXRpb25UeXBlOiBzdHJpbmcsIHNpemVUeXBlOiBzdHJpbmcsIGRpcmVjdGlvbjogKHN0cmluZyksXG4gICAgICogICAgICBhcmVhUG9zaXRpb246IG51bWJlciwgYXJlYVNpemU6IG51bWJlciwgY2hhcnRTaXplOiBudW1iZXIsXG4gICAgICogICAgICBiYXNlUG9zaXRpb246IChudW1iZXIpXG4gICAgICogfX0gdmVydGljYWwgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VWZXJ0aWNhbERhdGE6IGZ1bmN0aW9uKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIGFsaWduT3B0aW9uKSB7XG4gICAgICAgIHZhciBoRGlyZWN0aW9uID0gdGhpcy5fZ2V0SG9yaXpvbnRhbERpcmVjdGlvbihhbGlnbk9wdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ2xlZnQnLFxuICAgICAgICAgICAgc2l6ZVR5cGU6ICd3aWR0aCcsXG4gICAgICAgICAgICBkaXJlY3Rpb246IGhEaXJlY3Rpb24sXG4gICAgICAgICAgICBhcmVhUG9zaXRpb246IGFyZWFCb3VuZC5wb3NpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgYXJlYVNpemU6IGFyZWFCb3VuZC5kaW1lbnNpb24ud2lkdGgsXG4gICAgICAgICAgICBjaGFydFNpemU6IGNoYXJ0RGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBjaGFydENvbnN0LlNFUklFU19FWFBBTkRfU0laRVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdmVydGljYWwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VmVydGljYWxEaXJlY3Rpb246IGZ1bmN0aW9uKGFsaWduT3B0aW9uKSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgYWxpZ25PcHRpb24gPSBhbGlnbk9wdGlvbiB8fCAnJztcblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZigndG9wJykgPiAtMSkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdib3R0b20nKSA+IC0xKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0NFTlRFUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgaG9yaXpvbnRhbCBkYXRhLlxuICAgICAqIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gY2hhcnREaW1lbnNpb24gY2hhcnQgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBkaW1lbnNpb246IHt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sXG4gICAgICogICAgICBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9XG4gICAgICogfX0gYXJlYUJvdW5kIHRvb2x0aXAgYXJlYSBib3VuZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gYWxpZ25PcHRpb24gYWxpZ24gb3B0aW9uXG4gICAgICogQHJldHVybnMge3tcbiAgICAgKiAgICAgIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBzaXplVHlwZTogc3RyaW5nLCBkaXJlY3Rpb246IChzdHJpbmcpLFxuICAgICAqICAgICAgYXJlYVBvc2l0aW9uOiBudW1iZXIsIGFyZWFTaXplOiBudW1iZXIsIGNoYXJ0U2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgYmFzZVBvc2l0aW9uOiAobnVtYmVyKVxuICAgICAqIH19IGhvcml6b250YWwgZGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VIb3Jpem9udGFsRGF0YTogZnVuY3Rpb24oY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgYWxpZ25PcHRpb24pIHtcbiAgICAgICAgdmFyIHZEaXJlY3Rpb24gPSB0aGlzLl9nZXRWZXJ0aWNhbERpcmVjdGlvbihhbGlnbk9wdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVHlwZTogJ3RvcCcsXG4gICAgICAgICAgICBzaXplVHlwZTogJ2hlaWdodCcsXG4gICAgICAgICAgICBkaXJlY3Rpb246IHZEaXJlY3Rpb24sXG4gICAgICAgICAgICBhcmVhUG9zaXRpb246IGFyZWFCb3VuZC5wb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBhcmVhU2l6ZTogYXJlYUJvdW5kLmRpbWVuc2lvbi5oZWlnaHQsXG4gICAgICAgICAgICBjaGFydFNpemU6IGNoYXJ0RGltZW5zaW9uLmhlaWdodCxcbiAgICAgICAgICAgIGJhc2VQb3NpdGlvbjogY2hhcnRDb25zdC5TRVJJRVNfRVhQQU5EX1NJWkVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRhdGEuXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBjaGFydERpbWVuc2lvbiBjaGFydCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBhcmVhQm91bmQgdG9vbHRpcCBhcmVhIGJvdW5kXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRpY2FsIHdoZXRoZXIgdmVydGljYWwgb3Igbm90XG4gICAgICogQHBhcmFtIHt7YWxpZ246ID9zdHJpbmcsIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19fSBvcHRpb25zIHRvb2x0aXAgb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldERhdGE6IGZ1bmN0aW9uKGNoYXJ0RGltZW5zaW9uLCBhcmVhQm91bmQsIGlzVmVydGljYWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsRGF0YSA9IHRoaXMuX21ha2VWZXJ0aWNhbERhdGEoY2hhcnREaW1lbnNpb24sIGFyZWFCb3VuZCwgb3B0aW9ucy5hbGlnbiksXG4gICAgICAgICAgICBob3Jpem9udGFsRGF0YSA9IHRoaXMuX21ha2VIb3Jpem9udGFsRGF0YShjaGFydERpbWVuc2lvbiwgYXJlYUJvdW5kLCBvcHRpb25zLmFsaWduKTtcblxuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgdGhpcy5tYWluRGF0YSA9IHZlcnRpY2FsRGF0YTtcbiAgICAgICAgICAgIHRoaXMuc3ViRGF0YSA9IGhvcml6b250YWxEYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluRGF0YSA9IGhvcml6b250YWxEYXRhO1xuICAgICAgICAgICAgdGhpcy5zdWJEYXRhID0gdmVydGljYWxEYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbk9wdGlvbiA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgIH0sIG9wdGlvbnMucG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25zID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBtYWluIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuZGlyZWN0aW9uIGRpcmVjdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlTWFpblBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHRvb2x0aXBTaXplLCByYW5nZSwgZGF0YSkge1xuICAgICAgICB2YXIgaXNMaW5lID0gKHJhbmdlLnN0YXJ0ID09PSByYW5nZS5lbmQpLFxuICAgICAgICAgICAgcGFkZGluZyA9IGlzTGluZSA/IDkgOiA1LFxuICAgICAgICAgICAgdmFsdWUgPSBkYXRhLmJhc2VQb3NpdGlvbjtcblxuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2UuZW5kICsgcGFkZGluZztcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9CQUNLV0FSRCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gcmFuZ2Uuc3RhcnQgLSB0b29sdGlwU2l6ZSAtIHBhZGRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSByYW5nZS5zdGFydCAtIHRvb2x0aXBTaXplIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHJhbmdlLnN0YXJ0ICsgKChyYW5nZS5lbmQgLSByYW5nZS5zdGFydCAtIHRvb2x0aXBTaXplKSAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgc3ViIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhU2l6ZSB0b29sdGlwIGFyZWEgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IGRhdGEuZGlyZWN0aW9uIGRpcmVjdGlvblxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlU3ViUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odG9vbHRpcFNpemUsIGRhdGEpIHtcbiAgICAgICAgdmFyIG1pZGRsZSA9IGRhdGEuYXJlYVNpemUgLyAyLFxuICAgICAgICAgICAgdmFsdWU7XG5cbiAgICAgICAgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWlkZGxlICsgZGF0YS5iYXNlUG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWlkZGxlIC0gdG9vbHRpcFNpemUgKyBkYXRhLmJhc2VQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWlkZGxlIC0gKHRvb2x0aXBTaXplIC8gMikgKyBkYXRhLmJhc2VQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBwb3NpdGlvbiB2YWx1ZSBkaWZmLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdG9pbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogQHJldHVybnMge251bWJlcn0gZGlmZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VQb3NpdGlvblZhbHVlRGlmZjogZnVuY3Rpb24odmFsdWUsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIGRhdGEuYXJlYVBvc2l0aW9uICsgdG9vbHRpcFNpemUgLSBkYXRhLmNoYXJ0U2l6ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IGJhY2t3YXJkIHBvc2l0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gcmFuZ2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0QmFja3dhcmRQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkVmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgLWRhdGEuYXJlYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZSh0b29sdGlwU2l6ZSwgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fRk9SV0FSRCxcbiAgICAgICAgICAgICAgICBiYXNlUG9zaXRpb246IGRhdGEuYmFzZVBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYWtlUG9zaXRpb25WYWx1ZURpZmYoY2hhbmdlZFZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAtZGF0YS5hcmVhUG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhbmdlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgZm9yd2FyZCBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvb2x0aXBTaXplIHRvb2x0aXAgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIGRhdGFcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmNoYXJ0U2l6ZSBjaGFydCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5hcmVhUG9zaXRpb24gdG9vbHRpcCBhcmVhIHBvc2l0aW9uIChsZWZ0IG9yIHRvcClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmJhc2VQb3NpdGlvbiBiYXNlUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBwb3NpdGlvbiB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkanVzdEZvcndhcmRQb3NpdGlvblZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgcmFuZ2UsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIHZhciBkaWZmID0gdGhpcy5fbWFrZVBvc2l0aW9uVmFsdWVEaWZmKHZhbHVlLCB0b29sdGlwU2l6ZSwgZGF0YSksXG4gICAgICAgICAgICBjaGFuZ2VkVmFsdWU7XG5cbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZSh0b29sdGlwU2l6ZSwgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQsXG4gICAgICAgICAgICAgICAgYmFzZVBvc2l0aW9uOiBkYXRhLmJhc2VQb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFZhbHVlIDwgLWRhdGEuYXJlYVBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgLT0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFuZ2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkanVzdCBtYWluIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHBhcmFtIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXJ9fSByYW5nZSByYW5nZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b29sdGlwU2l6ZSB0b29sdGlwIHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSBkYXRhXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gZGF0YS5jaGFydFNpemUgY2hhcnQgc2l6ZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYXJlYVBvc2l0aW9uIHRvb2x0aXAgYXJlYSBwb3NpdGlvbiAobGVmdCBvciB0b3ApXG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RNYWluUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5kaXJlY3Rpb24gPT09IGNoYXJ0Q29uc3QuVE9PTFRJUF9ESVJFQ1RJT05fQkFDS1dBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0QmFja3dhcmRQb3NpdGlvblZhbHVlKHZhbHVlLCByYW5nZSwgdG9vbHRpcFNpemUsIGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZGlyZWN0aW9uID09PSBjaGFydENvbnN0LlRPT0xUSVBfRElSRUNUSU9OX0ZPUldBUkQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0Rm9yd2FyZFBvc2l0aW9uVmFsdWUodmFsdWUsIHJhbmdlLCB0b29sdGlwU2l6ZSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHR1aS51dGlsLm1heChbdmFsdWUsIC1kYXRhLmFyZWFQb3NpdGlvbl0pO1xuICAgICAgICAgICAgdmFsdWUgPSB0dWkudXRpbC5taW4oW3ZhbHVlLCBkYXRhLmNoYXJ0U2l6ZSAtIGRhdGEuYXJlYVBvc2l0aW9uIC0gdG9vbHRpcFNpemVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHN1YiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgcG9zaXRpb24gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9vbHRpcFNpemUgdG9vbHRpcCBzaXplICh3aWR0aCBvciBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgZGF0YVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuY2hhcnRTaXplIGNoYXJ0IHNpemUgKHdpZHRoIG9yIGhlaWdodClcbiAgICAgKiAgICAgIEBwYXJhbSB7bnVtYmVyfSBkYXRhLmFyZWFQb3NpdGlvbiB0b29sdGlwIGFyZWEgcG9zaXRpb24gKGxlZnQgb3IgdG9wKVxuICAgICAqICAgICAgQHBhcmFtIHtudW1iZXJ9IGRhdGEuYmFzZVBvc2l0aW9uIGJhc2VQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRqdXN0U3ViUG9zaXRpb25WYWx1ZTogZnVuY3Rpb24odmFsdWUsIHRvb2x0aXBTaXplLCBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmRpcmVjdGlvbiA9PT0gY2hhcnRDb25zdC5UT09MVElQX0RJUkVDVElPTl9GT1JXQVJEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHR1aS51dGlsLm1pbihbdmFsdWUsIGRhdGEuY2hhcnRTaXplIC0gZGF0YS5hcmVhUG9zaXRpb24gLSB0b29sdGlwU2l6ZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0dWkudXRpbC5tYXgoW3ZhbHVlLCAtZGF0YS5hcmVhUG9zaXRpb25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBjYWNoaW5nIGtleS5cbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHJhbmdlXG4gICAgICogQHJldHVybnMge3N0cmluZ30ga2V5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZUNhY2hpbmdLZXk6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydCArICctJyArIHJhbmdlLmVuZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIHBvc2l0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9zaXRpb25UeXBlIHBvc2l0aW9uIHR5cGUgKGxlZnQgb3IgdG9wKVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkUG9zaXRpb25PcHRpb25WYWx1ZTogZnVuY3Rpb24ocG9zaXRpb24sIHBvc2l0aW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gKyB0aGlzLnBvc2l0aW9uT3B0aW9uW3Bvc2l0aW9uVHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgbWFpbiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHRvb2x0aXBEaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHRvb2x0aXAgc2VjdG9yIHJhbmdlXG4gICAgICogQHBhcmFtIHt7XG4gICAgICogICAgICBwb3NpdGlvblR5cGU6IHN0cmluZywgc2l6ZVR5cGU6IHN0cmluZywgZGlyZWN0aW9uOiAoc3RyaW5nKSxcbiAgICAgKiAgICAgIGFyZWFQb3NpdGlvbjogbnVtYmVyLCBhcmVhU2l6ZTogbnVtYmVyLCBjaGFydFNpemU6IG51bWJlcixcbiAgICAgKiAgICAgIGJhc2VQb3NpdGlvbjogKG51bWJlcilcbiAgICAgKiB9fSBtYWluIG1haW4gZGF0YVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZU1haW5Qb3NpdGlvblZhbHVlOiBmdW5jdGlvbih0b29sdGlwRGltZW5zaW9uLCByYW5nZSwgbWFpbikge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVNYWluUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uW21haW4uc2l6ZVR5cGVdLCByYW5nZSwgbWFpbik7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fYWRkUG9zaXRpb25PcHRpb25WYWx1ZSh2YWx1ZSwgbWFpbi5wb3NpdGlvblR5cGUpO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdE1haW5Qb3NpdGlvblZhbHVlKHZhbHVlLCByYW5nZSwgdG9vbHRpcERpbWVuc2lvblttYWluLnNpemVUeXBlXSwgbWFpbik7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1YiBwb3NpdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHRvb2x0aXBEaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIHBvc2l0aW9uVHlwZTogc3RyaW5nLCBzaXplVHlwZTogc3RyaW5nLCBkaXJlY3Rpb246IChzdHJpbmcpLFxuICAgICAqICAgICAgYXJlYVBvc2l0aW9uOiBudW1iZXIsIGFyZWFTaXplOiBudW1iZXIsIGNoYXJ0U2l6ZTogbnVtYmVyLFxuICAgICAqICAgICAgYmFzZVBvc2l0aW9uOiAobnVtYmVyKVxuICAgICAqIH19IHN1YiBzdWIgZGF0YVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvc2l0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVN1YlBvc2l0aW9uVmFsdWU6IGZ1bmN0aW9uKHRvb2x0aXBEaW1lbnNpb24sIHN1Yikge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVTdWJQb3NpdGlvblZhbHVlKHRvb2x0aXBEaW1lbnNpb25bc3ViLnNpemVUeXBlXSwgc3ViKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGRQb3NpdGlvbk9wdGlvblZhbHVlKHZhbHVlLCBzdWIucG9zaXRpb25UeXBlKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9hZGp1c3RTdWJQb3NpdGlvblZhbHVlKHZhbHVlLCB0b29sdGlwRGltZW5zaW9uW3N1Yi5zaXplVHlwZV0sIHN1Yik7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZ3JvdXAgdG9vbHRpcCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHRvb2x0aXBEaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcn19IHJhbmdlIHRvb2x0aXAgc2VjdG9yIHJhbmdlXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gZ3JvdXAgdG9vbHRpcCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwRGltZW5zaW9uLCByYW5nZSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5fbWFrZUNhY2hpbmdLZXkocmFuZ2UpLFxuICAgICAgICAgICAgbWFpbiA9IHRoaXMubWFpbkRhdGEsXG4gICAgICAgICAgICBzdWIgPSB0aGlzLnN1YkRhdGEsXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb25zW2tleV07XG5cbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgICAgIHBvc2l0aW9uW21haW4ucG9zaXRpb25UeXBlXSA9IHRoaXMuX21ha2VNYWluUG9zaXRpb25WYWx1ZSh0b29sdGlwRGltZW5zaW9uLCByYW5nZSwgbWFpbik7XG4gICAgICAgICAgICBwb3NpdGlvbltzdWIucG9zaXRpb25UeXBlXSA9IHRoaXMuX21ha2VTdWJQb3NpdGlvblZhbHVlKHRvb2x0aXBEaW1lbnNpb24sIHN1Yik7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uc1trZXldID0gcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0b29sdGlwIG9wdGlvbnMgZm9yIHBvc2l0aW9uIGNhbGN1bGF0aW9uLlxuICAgICAqIEBwYXJhbSB7e2FsaWduOiA/c3RyaW5nLCBwb3NpdGlvbjoge2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fX0gb3B0aW9ucyB0b29sdGlwIG9wdGlvbnNcbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX3NldERhdGEodGhpcy5jaGFydERpbWVuc2lvbiwgdGhpcy5hcmVhQm91bmQsIHRoaXMuaXNWZXJ0aWNhbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0b29sdGlwIGJvdW5kIGZvciBwb3NpdGlvbiBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tcbiAgICAgKiAgICAgIGRpbWVuc2lvbjoge3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSxcbiAgICAgKiAgICAgIHBvc2l0aW9uOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn1cbiAgICAgKiB9fSBib3VuZCB0b29sdGlwIGFyZWEgYm91bmRcbiAgICAgKi9cbiAgICB1cGRhdGVCb3VuZDogZnVuY3Rpb24oYm91bmQpIHtcbiAgICAgICAgdGhpcy5hcmVhQm91bmQgPSBib3VuZDtcbiAgICAgICAgdGhpcy5fc2V0RGF0YSh0aGlzLmNoYXJ0RGltZW5zaW9uLCBib3VuZCwgdGhpcy5pc1ZlcnRpY2FsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwVG9vbHRpcFBvc2l0aW9uTW9kZWw7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVG9vbHRpcCBjb21wb25lbnQgZm9yIG1hcCBjaGFydC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIFRvb2x0aXBCYXNlID0gcmVxdWlyZSgnLi90b29sdGlwQmFzZScpLFxuICAgIHNpbmdsZVRvb2x0aXBNaXhlciA9IHJlcXVpcmUoJy4vc2luZ2xlVG9vbHRpcE1peGVyJyksXG4gICAgdG9vbHRpcFRlbXBsYXRlID0gcmVxdWlyZSgnLi90b29sdGlwVGVtcGxhdGUnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIE1hcENoYXJ0VG9vbHRpcCBjb21wb25lbnQuXG4gKiBAY2xhc3MgTWFwQ2hhcnRUb29sdGlwXG4gKi9cbnZhciBNYXBDaGFydFRvb2x0aXAgPSB0dWkudXRpbC5kZWZpbmVDbGFzcyhUb29sdGlwQmFzZSwgLyoqIEBsZW5kcyBNYXBDaGFydFRvb2x0aXAucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBNYXAgY2hhcnQgdG9vbHRpcCBjb21wb25lbnQuXG4gICAgICogQGNvbnN0cnVjdHMgTWFwQ2hhcnRUb29sdGlwXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBtb2RlbFxuICAgICAgICAgKiBAdHlwZSB7TWFwQ2hhcnRNYXBNb2RlbH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFwTW9kZWwgPSBudWxsO1xuXG4gICAgICAgIFRvb2x0aXBCYXNlLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHBhcmFtIHt7bmFtZTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyfX0gZGF0dW0gdG9vbHRpcCBkYXR1bVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwSHRtbDogZnVuY3Rpb24oZGF0dW0pIHtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBUZW1wbGF0ZS50cGxNYXBDaGFydERlZmF1bHQoZGF0dW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHNpbmdsZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJ0VHlwZSBjaGFydCB0eXBlXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdG9vbHRpcCBodG1sXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWFrZVNpbmdsZVRvb2x0aXBIdG1sOiBmdW5jdGlvbihjaGFydFR5cGUsIGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIGRhdHVtID0gdGhpcy5tYXBNb2RlbC5nZXREYXR1bShpbmRleGVzLmluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUZ1bmMoe1xuICAgICAgICAgICAgbmFtZTogZGF0dW0ubmFtZSB8fCBkYXR1bS5jb2RlLFxuICAgICAgICAgICAgdmFsdWU6IGRhdHVtLmZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcCB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwYXJhbWV0ZXJzIGZvciBzaG93IHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2hvd1Rvb2x0aXBQYXJhbXM6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBkYXR1bSA9IHRoaXMubWFwTW9kZWwuZ2V0RGF0dW0oaW5kZXhlcy5pbmRleCksXG4gICAgICAgICAgICBwYXJhbXM7XG5cbiAgICAgICAgcGFyYW1zID0gdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGNoYXJ0VHlwZTogdGhpcy5jaGFydFR5cGUsXG4gICAgICAgICAgICBjb2RlOiBkYXR1bS5jb2RlLFxuICAgICAgICAgICAgbmFtZTogZGF0dW0ubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXR1bS5mb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleGVzLmluZGV4XG4gICAgICAgIH0sIGFkZGl0aW9uUGFyYW1zKTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gY2hhcnRDb25zdC5UT09MVElQX0RFRkFVTFRfQUxJR05fT1BUSU9OO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlci5cbiAgICAgKiBAcGFyYW0ge3ttYXBNb2RlbDogTWFwQ2hhcnRNYXBNb2RlbH19IGRhdGEgZGF0YSBmb3IgcmVuZGVyaW5nXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0b29sdGlwIGVsZW1lbnRcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5tYXBNb2RlbCA9IGRhdGEubWFwTW9kZWw7XG5cbiAgICAgICAgcmV0dXJuIFRvb2x0aXBCYXNlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzKTtcbiAgICB9XG59KTtcblxuc2luZ2xlVG9vbHRpcE1peGVyLm1peGluKE1hcENoYXJ0VG9vbHRpcCk7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcENoYXJ0VG9vbHRpcDtcbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBzaW5nbGVUb29sdGlwTWl4ZXIgaXMgc2luZ2xlIHRvb2x0aXAgbWl4ZXIgb2YgbWFwIGNoYXJ0LlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICBkb20gPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvbUhhbmRsZXInKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbi8qKlxuICogc2luZ2xlVG9vbHRpcE1peGVyIGlzIHNpbmdsZSB0b29sdGlwIG1peGVyIG9mIG1hcCBjaGFydC5cbiAqIEBtaXhpblxuICovXG52YXIgc2luZ2xlVG9vbHRpcE1peGVyID0ge1xuXG4gICAgLyoqXG4gICAgICogRmlyZSBjdXN0b20gZXZlbnQgc2hvd0FuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlU2hvd0FuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXhlcywgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ3Nob3cnLCBjaGFydFR5cGUsICdhbmltYXRpb24nKTtcblxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCBpbmRleGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZSBjdXN0b20gZXZlbnQgaGlkZUFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcnRUeXBlIGNoYXJ0IHR5cGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlSGlkZUFuaW1hdGlvbjogZnVuY3Rpb24oaW5kZXhlcywgY2hhcnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSByZW5kZXJVdGlsLm1ha2VDdXN0b21FdmVudE5hbWUoJ2hpZGUnLCBjaGFydFR5cGUsICdhbmltYXRpb24nKTtcblxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCBpbmRleGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRhdGEgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDpudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXAsIGluZGV4ZXMpIHtcbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1ncm91cEluZGV4JywgaW5kZXhlcy5ncm91cEluZGV4KTtcbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcsIGluZGV4ZXMuaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgZGF0YSBpbmRleGVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxUb29sdGlwIHRvb2x0aXAgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IGVsVG9vbHRpcC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXBJbmRleCcpLFxuICAgICAgICAgICAgaW5kZXggPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4JyksXG4gICAgICAgICAgICBpbmRleGVzID0gbnVsbDtcblxuICAgICAgICBpZiAoIXR1aS51dGlsLmlzTnVsbChncm91cEluZGV4KSAmJiAhdHVpLnV0aWwuaXNOdWxsKGluZGV4KSkge1xuICAgICAgICAgICAgaW5kZXhlcyA9IHtcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBwYXJzZUludChncm91cEluZGV4LCAxMCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcnNlSW50KGluZGV4LCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBzaG93ZWQgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGF0dXMgd2hldGhlciBzaG93ZWQgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U2hvd2VkQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihlbFRvb2x0aXAsIHN0YXR1cykge1xuICAgICAgICBlbFRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcsIHN0YXR1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgc2hvd2VkIHRvb2x0aXAgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBzaG93ZWQgdG9vbHRpcCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1Nob3dlZFRvb2x0aXA6IGZ1bmN0aW9uKGVsVG9vbHRpcCkge1xuICAgICAgICB2YXIgaXNTaG93ZWQgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLXNob3dlZCcpO1xuXG4gICAgICAgIHJldHVybiBpc1Nob3dlZCA9PT0gJ3RydWUnIHx8IGlzU2hvd2VkID09PSB0cnVlOyAvLyBpZTfsl5DshJzripQgYm9vbGVhbu2Yle2DnOydmCB0cnVl66W8IOuwmO2ZmO2VqFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdG9vbHRpcCBwb3NpdGlvbiB0byBldmVudCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBwYXJhbXMubW91c2VQb3NpdGlvbiBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uVG9Nb3VzZVBvc2l0aW9uOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zLmJvdW5kID0gcGFyYW1zLmJvdW5kIHx8IHt9O1xuICAgICAgICB0dWkudXRpbC5leHRlbmQocGFyYW1zLmJvdW5kLCBwYXJhbXMubW91c2VQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb25BYm91dE5vdEJhckNoYXJ0KHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0b29sdGlwIHBvc2l0aW9uIGFib3V0IG5vdCBiYXIgY2hhcnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tib3VuZDogb2JqZWN0fX0gcGFyYW1zLmRhdGEgZ3JhcGggaW5mb3JtYXRpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcGFyYW1zLmRpbWVuc2lvbiB0b29sdGlwIGRpbWVuc2lvblxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hbGlnbk9wdGlvbiBwb3NpdGlvbiBvcHRpb24gKGV4OiAnbGVmdCB0b3AnKVxuICAgICAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlVG9vbHRpcFBvc2l0aW9uQWJvdXROb3RCYXJDaGFydDogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uID0gcGFyYW1zLnBvc2l0aW9uT3B0aW9uLFxuICAgICAgICAgICAgbWludXNXaWR0aCA9IHBhcmFtcy5kaW1lbnNpb24ud2lkdGggLSAoYm91bmQud2lkdGggfHwgMCksXG4gICAgICAgICAgICBsaW5lR2FwID0gYm91bmQud2lkdGggPyAwIDogY2hhcnRDb25zdC5UT09MVElQX0dBUCxcbiAgICAgICAgICAgIGFsaWduT3B0aW9uID0gcGFyYW1zLmFsaWduT3B0aW9uIHx8ICcnLFxuICAgICAgICAgICAgdG9vbHRpcEhlaWdodCA9IHBhcmFtcy5kaW1lbnNpb24uaGVpZ2h0LFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgcmVzdWx0LmxlZnQgPSBib3VuZC5sZWZ0ICsgcG9zaXRpb25PcHRpb24ubGVmdDtcbiAgICAgICAgcmVzdWx0LnRvcCA9IGJvdW5kLnRvcCAtIHRvb2x0aXBIZWlnaHQgKyBwb3NpdGlvbk9wdGlvbi50b3A7XG5cbiAgICAgICAgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2xlZnQnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQubGVmdCAtPSBtaW51c1dpZHRoICsgbGluZUdhcDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdjZW50ZXInKSA+IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQubGVmdCAtPSBtaW51c1dpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0ICs9IGxpbmVHYXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignYm90dG9tJykgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnRvcCArPSB0b29sdGlwSGVpZ2h0ICsgbGluZUdhcDtcbiAgICAgICAgfSBlbHNlIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdtaWRkbGUnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQudG9wICs9IHRvb2x0aXBIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnRvcCAtPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvb2x0aXAgcG9zaXRpb24gYWJvdXQgYmFyIGNoYXJ0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7Ym91bmQ6IG9iamVjdH19IHBhcmFtcy5kYXRhIGdyYXBoIGluZm9ybWF0aW9uXG4gICAgICogICAgICBAcGFyYW0ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5kaW1lbnNpb24gdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWxpZ25PcHRpb24gcG9zaXRpb24gb3B0aW9uIChleDogJ2xlZnQgdG9wJylcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZVRvb2x0aXBQb3NpdGlvbkFib3V0QmFyQ2hhcnQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgYm91bmQgPSBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbiA9IHBhcmFtcy5wb3NpdGlvbk9wdGlvbixcbiAgICAgICAgICAgIG1pbnVzSGVpZ2h0ID0gcGFyYW1zLmRpbWVuc2lvbi5oZWlnaHQgLSAoYm91bmQuaGVpZ2h0IHx8IDApLFxuICAgICAgICAgICAgYWxpZ25PcHRpb24gPSBwYXJhbXMuYWxpZ25PcHRpb24gfHwgJycsXG4gICAgICAgICAgICB0b29sdGlwV2lkdGggPSBwYXJhbXMuZGltZW5zaW9uLndpZHRoLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgcmVzdWx0LmxlZnQgPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGggKyBwb3NpdGlvbk9wdGlvbi5sZWZ0O1xuICAgICAgICByZXN1bHQudG9wID0gYm91bmQudG9wICsgcG9zaXRpb25PcHRpb24udG9wO1xuXG4gICAgICAgIGlmIChhbGlnbk9wdGlvbi5pbmRleE9mKCdsZWZ0JykgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmxlZnQgLT0gdG9vbHRpcFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ2NlbnRlcicpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sZWZ0IC09IHRvb2x0aXBXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQubGVmdCArPSBjaGFydENvbnN0LlRPT0xUSVBfR0FQO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduT3B0aW9uLmluZGV4T2YoJ3RvcCcpID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC50b3AgLT0gbWludXNIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ25PcHRpb24uaW5kZXhPZignbWlkZGxlJykgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnRvcCAtPSBtaW51c0hlaWdodCAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSB0b29sdGlwRGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gYWRqdXN0ZWQgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcERpbWVuc2lvbiwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGNoYXJ0RGltZW5zaW9uID0gdGhpcy5ib3VuZHNNYWtlci5nZXREaW1lbnNpb24oJ2NoYXJ0JyksXG4gICAgICAgICAgICBhcmVhUG9zaXRpb24gPSB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJyk7XG5cbiAgICAgICAgcG9zaXRpb24ubGVmdCA9IE1hdGgubWF4KHBvc2l0aW9uLmxlZnQsIC1hcmVhUG9zaXRpb24ubGVmdCk7XG4gICAgICAgIHBvc2l0aW9uLmxlZnQgPSBNYXRoLm1pbihwb3NpdGlvbi5sZWZ0LCBjaGFydERpbWVuc2lvbi53aWR0aCAtIGFyZWFQb3NpdGlvbi5sZWZ0IC0gdG9vbHRpcERpbWVuc2lvbi53aWR0aCk7XG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IE1hdGgubWF4KHBvc2l0aW9uLnRvcCwgLWFyZWFQb3NpdGlvbi50b3ApO1xuICAgICAgICBwb3NpdGlvbi50b3AgPSBNYXRoLm1pbihwb3NpdGlvbi50b3AsIGNoYXJ0RGltZW5zaW9uLmhlaWdodCAtIGFyZWFQb3NpdGlvbi50b3AgLSB0b29sdGlwRGltZW5zaW9uLmhlaWdodCk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRvb2x0aXAgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBwYXJhbWV0ZXJzXG4gICAgICogICAgICBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19IHBhcmFtcy5ib3VuZCBncmFwaCBib3VuZFxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqICAgICAgQHBhcmFtIHtib29sZWFufSBwYXJhbXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXAgd2hldGhlciBhbGxvdyBuZWdhdGl2ZSB0b29sdGlwIG9yIG5vdFxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFsaWduT3B0aW9uIHBvc2l0aW9uIG9wdGlvbiAoZXg6ICdsZWZ0IHRvcCcpXG4gICAgICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX0gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb246IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB7fSxcbiAgICAgICAgICAgIHNpemVUeXBlLCBwb3NpdGlvblR5cGUsIGFkZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5tb3VzZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZVRvb2x0aXBQb3NpdGlvblRvTW91c2VQb3NpdGlvbihwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5pc0JhckNoYXJ0KHBhcmFtcy5jaGFydFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb25BYm91dEJhckNoYXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2l6ZVR5cGUgPSAnd2lkdGgnO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uVHlwZSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBhZGRQYWRkaW5nID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb25BYm91dE5vdEJhckNoYXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2l6ZVR5cGUgPSAnaGVpZ2h0JztcbiAgICAgICAgICAgICAgICBwb3NpdGlvblR5cGUgPSAndG9wJztcbiAgICAgICAgICAgICAgICBhZGRQYWRkaW5nID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYWxsb3dOZWdhdGl2ZVRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX21vdmVUb1N5bW1ldHJ5KHBvc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kOiBwYXJhbXMuYm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXM6IHBhcmFtcy5pbmRleGVzLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb246IHBhcmFtcy5kaW1lbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0VHlwZTogcGFyYW1zLmNoYXJ0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZVR5cGU6IHNpemVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblR5cGU6IHBvc2l0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgYWRkUGFkZGluZzogYWRkUGFkZGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2FkanVzdFBvc2l0aW9uKHBhcmFtcy5kaW1lbnNpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBzeW1tZXRyeS5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gdG9vbHRpcCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuYm91bmQgZ3JhcGggYm91bmRcbiAgICAgKiAgICAgIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuaWQgdG9vbHRpcCBpZFxuICAgICAqICAgICAgQHBhcmFtIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fSBwYXJhbXMuZGltZW5zaW9uIHRvb2x0aXAgZGltZW5zaW9uXG4gICAgICogICAgICBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNpemVUeXBlIHNpemUgdHlwZSAod2lkdGggb3IgaGVpZ2h0KVxuICAgICAqICAgICAgQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wb3NpdGlvblR5cGUgcG9zaXRpb24gdHlwZSAobGVmdCBvciB0b3ApXG4gICAgICogICAgICBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmFkZFBhZGRpbmcgYWRkIHBhZGRpbmdcbiAgICAgKiBAcmV0dXJucyB7e2xlZnQ6IG51bWJlciwgdG9wOiBudW1iZXJ9fSBtb3ZlZCBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdmVUb1N5bW1ldHJ5OiBmdW5jdGlvbihwb3NpdGlvbiwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHBhcmFtcy5ib3VuZCxcbiAgICAgICAgICAgIHNpemVUeXBlID0gcGFyYW1zLnNpemVUeXBlLFxuICAgICAgICAgICAgcG9zaXRpb25UeXBlID0gcGFyYW1zLnBvc2l0aW9uVHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldFZhbHVlKHBhcmFtcy5pbmRleGVzLmdyb3VwSW5kZXgsIHBhcmFtcy5pbmRleGVzLmluZGV4LCBwYXJhbXMuY2hhcnRUeXBlKSxcbiAgICAgICAgICAgIHRvb2x0aXBTaXplSGFsZiwgYmFyUG9zaXRpb24sIGJhclNpemVIYWxmLCBtb3ZlZFBvc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdG9vbHRpcFNpemVIYWxmID0gcGFyYW1zLmRpbWVuc2lvbltzaXplVHlwZV0gLyAyO1xuICAgICAgICAgICAgYmFyUG9zaXRpb24gPSBib3VuZFtwb3NpdGlvblR5cGVdO1xuICAgICAgICAgICAgYmFyU2l6ZUhhbGYgPSBib3VuZFtzaXplVHlwZV0gLyAyO1xuICAgICAgICAgICAgbW92ZWRQb3NpdGlvblZhbHVlID0gKGJhclBvc2l0aW9uICsgYmFyU2l6ZUhhbGYgLSB0b29sdGlwU2l6ZUhhbGYpICogMiAtIHBvc2l0aW9uW3Bvc2l0aW9uVHlwZV07XG4gICAgICAgICAgICBwb3NpdGlvbltwb3NpdGlvblR5cGVdID0gbW92ZWRQb3NpdGlvblZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNoYW5nZWQgaW5kZXhlcyBvciBub3QuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gcHJldkluZGV4ZXMgcHJldiBpbmRleGVzXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgY2hhbmdlZCBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc0NoYW5nZWRJbmRleGVzOiBmdW5jdGlvbihwcmV2SW5kZXhlcywgaW5kZXhlcykge1xuICAgICAgICByZXR1cm4gISFwcmV2SW5kZXhlcyAmJiAocHJldkluZGV4ZXMuZ3JvdXBJbmRleCAhPT0gaW5kZXhlcy5ncm91cEluZGV4IHx8IHByZXZJbmRleGVzLmluZGV4ICE9PSBpbmRleGVzLmluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0b29sdGlwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVG9vbHRpcCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tpbmRleGVzOiB7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfSwgYm91bmQ6IG9iamVjdH19IHBhcmFtcyB0b29sdGlwIGRhdGFcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcHJldlBvc2l0aW9uIHByZXYgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzaG93VG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwLCBwYXJhbXMsIHByZXZQb3NpdGlvbikge1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcmFtcy5pbmRleGVzLFxuICAgICAgICAgICAgcHJldkluZGV4ZXMgPSB0aGlzLl9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBwcmV2Q2hhcnRUeXBlLCBwb3NpdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkSW5kZXhlcyhwcmV2SW5kZXhlcywgaW5kZXhlcykpIHtcbiAgICAgICAgICAgIHByZXZDaGFydFR5cGUgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVIaWRlQW5pbWF0aW9uKHByZXZJbmRleGVzLCBwcmV2Q2hhcnRUeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsVG9vbHRpcC5pbm5lckhUTUwgPSB0aGlzLl9tYWtlU2luZ2xlVG9vbHRpcEh0bWwocGFyYW1zLmNoYXJ0VHlwZSwgaW5kZXhlcyk7XG5cbiAgICAgICAgZWxUb29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1jaGFydC10eXBlJywgcGFyYW1zLmNoYXJ0VHlwZSk7XG4gICAgICAgIHRoaXMuX3NldEluZGV4ZXNDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCBpbmRleGVzKTtcbiAgICAgICAgdGhpcy5fc2V0U2hvd2VkQ3VzdG9tQXR0cmlidXRlKGVsVG9vbHRpcCwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fZmlyZUJlZm9yZVNob3dUb29sdGlwKGluZGV4ZXMpO1xuXG4gICAgICAgIGRvbS5hZGRDbGFzcyhlbFRvb2x0aXAsICdzaG93Jyk7XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9jYWxjdWxhdGVUb29sdGlwUG9zaXRpb24odHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXRUb29sdGlwRGltZW5zaW9uKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBwb3NpdGlvbk9wdGlvbjogdHVpLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGFsaWduT3B0aW9uOiB0aGlzLm9wdGlvbnMuYWxpZ24gfHwgJydcbiAgICAgICAgfSwgcGFyYW1zKSk7XG5cbiAgICAgICAgdGhpcy5tb3ZlVG9Qb3NpdGlvbihlbFRvb2x0aXAsIHBvc2l0aW9uLCBwcmV2UG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9maXJlU2hvd0FuaW1hdGlvbihpbmRleGVzLCBwYXJhbXMuY2hhcnRUeXBlKTtcbiAgICAgICAgdGhpcy5fZmlyZUFmdGVyU2hvd1Rvb2x0aXAoaW5kZXhlcywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxUb29sdGlwLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUbyBjYWxsIGJlZm9yZVNob3dUb29sdGlwIGNhbGxiYWNrIG9mIHVzZXJFdmVudC5cbiAgICAgKiBAcGFyYW0ge3tncm91cEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBpbmRleGVzIGluZGV4ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlQmVmb3JlU2hvd1Rvb2x0aXA6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VTaG93VG9vbHRpcFBhcmFtcyhpbmRleGVzKTtcblxuICAgICAgICB0aGlzLnVzZXJFdmVudC5maXJlKCdiZWZvcmVTaG93VG9vbHRpcCcsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRvIGNhbGwgYWZ0ZXJTaG93VG9vbHRpcCBjYWxsYmFjayBvZiB1c2VyRXZlbnQuXG4gICAgICogQHBhcmFtIHt7Z3JvdXBJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyfX0gaW5kZXhlcyBpbmRleGVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFkZGl0aW9uUGFyYW1zIGFkZGl0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlQWZ0ZXJTaG93VG9vbHRpcDogZnVuY3Rpb24oaW5kZXhlcywgYWRkaXRpb25QYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX21ha2VTaG93VG9vbHRpcFBhcmFtcyhpbmRleGVzLCBhZGRpdGlvblBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy51c2VyRXZlbnQuZmlyZSgnYWZ0ZXJTaG93VG9vbHRpcCcsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFRvb2x0aXAgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBoaWRlVG9vbHRpcDogZnVuY3Rpb24oZWxUb29sdGlwKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgIGluZGV4ZXMgPSB0aGlzLl9nZXRJbmRleGVzQ3VzdG9tQXR0cmlidXRlKGVsVG9vbHRpcCksXG4gICAgICAgICAgICBjaGFydFR5cGUgPSBlbFRvb2x0aXAuZ2V0QXR0cmlidXRlKCdkYXRhLWNoYXJ0LXR5cGUnKTtcblxuICAgICAgICBpZiAoY2hhcnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTaG93ZWRDdXN0b21BdHRyaWJ1dGUoZWxUb29sdGlwLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9maXJlSGlkZUFuaW1hdGlvbihpbmRleGVzLCBjaGFydFR5cGUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNDaGFuZ2VkSW5kZXhlcyh0aGlzLnByZXZJbmRleGVzLCBpbmRleGVzKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZJbmRleGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9pc1Nob3dlZFRvb2x0aXAoZWxUb29sdGlwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsVG9vbHRpcCwgJ3Nob3cnKTtcbiAgICAgICAgICAgICAgICBlbFRvb2x0aXAuc3R5bGUuY3NzVGV4dCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgdGhhdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5kZXhlcyA9IG51bGw7XG4gICAgICAgICAgICB9LCBjaGFydENvbnN0LkhJREVfREVMQVkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uIHNob3cgdG9vbHRpcCBjb250YWluZXIuXG4gICAgICovXG4gICAgb25TaG93VG9vbHRpcENvbnRhaW5lcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lci5zdHlsZS56SW5kZXggPSBjaGFydENvbnN0LlRPT0xUSVBfWklOREVYO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBoaWRlIHRvb2x0aXAgY29udGFpbmVyLlxuICAgICAqL1xuICAgIG9uSGlkZVRvb2x0aXBDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250YWluZXIuc3R5bGUuekluZGV4ID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWl4IGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgdGFyZ2V0IGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIG1peGluOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIHR1aS51dGlsLmV4dGVuZChmdW5jLnByb3RvdHlwZSwgdGhpcyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzaW5nbGVUb29sdGlwTWl4ZXI7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVG9vbHRpcCBjb21wb25lbnQuXG4gKiBAYXV0aG9yIE5ITiBFbnQuXG4gKiAgICAgICAgIEZFIERldmVsb3BtZW50IFRlYW0gPGRsX2phdmFzY3JpcHRAbmhuZW50LmNvbT5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb29sdGlwQmFzZSA9IHJlcXVpcmUoJy4vdG9vbHRpcEJhc2UnKSxcbiAgICBzaW5nbGVUb29sdGlwTWl4ZXIgPSByZXF1aXJlKCcuL3NpbmdsZVRvb2x0aXBNaXhlcicpLFxuICAgIGNoYXJ0Q29uc3QgPSByZXF1aXJlKCcuLi9jb25zdCcpLFxuICAgIHRvb2x0aXBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdG9vbHRpcFRlbXBsYXRlJyk7XG5cbi8qKlxuICogQGNsYXNzZGVzYyBUb29sdGlwIGNvbXBvbmVudC5cbiAqIEBjbGFzcyBUb29sdGlwXG4gKi9cbnZhciBUb29sdGlwID0gdHVpLnV0aWwuZGVmaW5lQ2xhc3MoVG9vbHRpcEJhc2UsIC8qKiBAbGVuZHMgVG9vbHRpcC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBjb25zdHJ1Y3RzIFRvb2x0aXBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIHBhcmFtZXRlcnNcbiAgICAgKiAgICAgIEBwYXJhbSB7Qm91bmRzTWFrZXJ9IHBhcmFtcy5ib3VuZHNNYWtlciBib3VuZHMgbWFrZXJcbiAgICAgKiAgICAgIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMudGhlbWUgYXhpcyB0aGVtZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBUb29sdGlwQmFzZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeVxuICAgICAqIEBwYXJhbSB7e3ZhbHVlOiBzdHJpbmcsIGxlZ2VuZDogc3RyaW5nLCBjaGFydFR5cGU6IHN0cmluZywgc3VmZml4OiA/c3RyaW5nfX0gaXRlbSBpdGVtIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0b29sdGlwIGh0bWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlVG9vbHRpcEh0bWw6IGZ1bmN0aW9uKGNhdGVnb3J5LCBpdGVtKSB7XG4gICAgICAgIHJldHVybiB0b29sdGlwVGVtcGxhdGUudHBsRGVmYXVsdCh0dWkudXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5IHx8ICcnXG4gICAgICAgIH0sIGl0ZW0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzaW5nbGUgdG9vbHRpcCBodG1sLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFydFR5cGUgY2hhcnQgdHlwZVxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRvb2x0aXAgaHRtbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21ha2VTaW5nbGVUb29sdGlwSHRtbDogZnVuY3Rpb24oY2hhcnRUeXBlLCBpbmRleGVzKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHVpLnV0aWwucGljayh0aGlzLmRhdGEsIGNoYXJ0VHlwZSwgaW5kZXhlcy5ncm91cEluZGV4LCBpbmRleGVzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVGdW5jKGRhdGEuY2F0ZWdvcnksIHtcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhLnZhbHVlLFxuICAgICAgICAgICAgbGVnZW5kOiBkYXRhLmxlZ2VuZCxcbiAgICAgICAgICAgIHN1ZmZpeDogdGhpcy5zdWZmaXhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IGFsaWduIG9wdGlvbiBvZiB0b29sdGlwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldERlZmF1bHRUb29sdGlwUG9zaXRpb25PcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9BTElHTl9PUFRJT047XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ24gPSBjaGFydENvbnN0LlRPT0xUSVBfREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOX09QVElPTjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHBhcmFtZXRlcnMgZm9yIHNob3cgdG9vbHRpcCB1c2VyIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7e2dyb3VwSW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcn19IGluZGV4ZXMgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhZGRpdGlvblBhcmFtcyBhZGRpdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMge3tjaGFydFR5cGU6IHN0cmluZywgbGVnZW5kOiBzdHJpbmcsIGxlZ2VuZEluZGV4OiBudW1iZXIsIGluZGV4OiBudW1iZXJ9fSBwYXJhbWV0ZXJzIGZvciBzaG93IHRvb2x0aXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYWtlU2hvd1Rvb2x0aXBQYXJhbXM6IGZ1bmN0aW9uKGluZGV4ZXMsIGFkZGl0aW9uUGFyYW1zKSB7XG4gICAgICAgIHZhciBsZWdlbmRJbmRleCA9IGluZGV4ZXMuaW5kZXgsXG4gICAgICAgICAgICBsZWdlbmREYXRhID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZERhdGEobGVnZW5kSW5kZXgpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgIHBhcmFtcyA9IHR1aS51dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjaGFydFR5cGU6IGxlZ2VuZERhdGEuY2hhcnRUeXBlLFxuICAgICAgICAgICAgbGVnZW5kOiBsZWdlbmREYXRhLmxhYmVsLFxuICAgICAgICAgICAgbGVnZW5kSW5kZXg6IGxlZ2VuZEluZGV4LFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4ZXMuZ3JvdXBJbmRleFxuICAgICAgICB9LCBhZGRpdGlvblBhcmFtcyk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48b2JqZWN0Pn0gdG9vbHRpcCBkYXRhXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldENhdGVnb3JpZXMoKSxcbiAgICAgICAgICAgIG9yZ0Zvcm1hdHRlZFZhbHVlcyA9IHRoaXMuZGF0YVByb2Nlc3Nvci5nZXRGb3JtYXR0ZWRHcm91cFZhbHVlcygpLFxuICAgICAgICAgICAgb3JnTGVnZW5kTGFiZWxzID0gdGhpcy5kYXRhUHJvY2Vzc29yLmdldExlZ2VuZExhYmVscygpLFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzID0ge30sXG4gICAgICAgICAgICBsZWdlbmRMYWJlbHMgPSB7fSxcbiAgICAgICAgICAgIHRvb2x0aXBEYXRhID0ge307XG5cbiAgICAgICAgaWYgKHR1aS51dGlsLmlzQXJyYXkob3JnRm9ybWF0dGVkVmFsdWVzKSkge1xuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVzW3RoaXMuY2hhcnRUeXBlXSA9IG9yZ0Zvcm1hdHRlZFZhbHVlcztcbiAgICAgICAgICAgIGxlZ2VuZExhYmVsc1t0aGlzLmNoYXJ0VHlwZV0gPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZXMgPSBvcmdGb3JtYXR0ZWRWYWx1ZXM7XG4gICAgICAgICAgICBsZWdlbmRMYWJlbHMgPSBvcmdMZWdlbmRMYWJlbHM7XG4gICAgICAgIH1cblxuICAgICAgICB0dWkudXRpbC5mb3JFYWNoKGZvcm1hdHRlZFZhbHVlcywgZnVuY3Rpb24oZ3JvdXBWYWx1ZXMsIGNoYXJ0VHlwZSkge1xuICAgICAgICAgICAgdG9vbHRpcERhdGFbY2hhcnRUeXBlXSA9IHR1aS51dGlsLm1hcChncm91cFZhbHVlcywgZnVuY3Rpb24odmFsdWVzLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1aS51dGlsLm1hcCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3JpZXMgPyBjYXRlZ29yaWVzW2dyb3VwSW5kZXhdIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IGxlZ2VuZExhYmVsc1tjaGFydFR5cGVdW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0b29sdGlwRGF0YTtcbiAgICB9XG59KTtcblxuc2luZ2xlVG9vbHRpcE1peGVyLm1peGluKFRvb2x0aXApO1xubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwO1xuIiwiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRvb2x0aXBCYXNlIGlzIGJhc2UgY2xhc3Mgb2YgdG9vbHRpcCBjb21wb25lbnRzLlxuICogQGF1dGhvciBOSE4gRW50LlxuICogICAgICAgICBGRSBEZXZlbG9wbWVudCBUZWFtIDxkbF9qYXZhc2NyaXB0QG5obmVudC5jb20+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hhcnRDb25zdCA9IHJlcXVpcmUoJy4uL2NvbnN0JyksXG4gICAgZG9tID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb21IYW5kbGVyJyksXG4gICAgcHJlZGljYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcmVkaWNhdGUnKSxcbiAgICByZW5kZXJVdGlsID0gcmVxdWlyZSgnLi4vaGVscGVycy9yZW5kZXJVdGlsJyk7XG5cbnZhciBUb29sdGlwQmFzZSA9IHR1aS51dGlsLmRlZmluZUNsYXNzKC8qKiBAbGVuZHMgVG9vbHRpcEJhc2UucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBUb29sdGlwQmFzZSBpcyBiYXNlIGNsYXNzIG9mIHRvb2x0aXAgY29tcG9uZW50cy5cbiAgICAgKiBAY29uc3RydWN0cyBUb29sdGlwQmFzZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuICAgICAqICAgICAgQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcGFyYW1zLnZhbHVlcyBjb252ZXJ0ZWQgdmFsdWVzXG4gICAgICogICAgICBAcGFyYW0ge0JvdW5kc01ha2VyfSBwYXJhbXMuYm91bmRzTWFrZXIgYm91bmRzIG1ha2VyXG4gICAgICogICAgICBAcGFyYW0ge29iamVjdH0gcGFyYW1zLnRoZW1lIGF4aXMgdGhlbWVcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdHVpLnV0aWwuZXh0ZW5kKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjbGFzc05hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ3R1aS1jaGFydC10b29sdGlwLWFyZWEnO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGNvbnRhaW5lci5cbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b29sdGlwQ29udGFpbmVyID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCBzdWZmaXguXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHRoaXMub3B0aW9ucy5zdWZmaXggPyAnJm5ic3A7JyArIHRoaXMub3B0aW9ucy5zdWZmaXggOiAnJztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9vbHRpcCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wbGF0ZUZ1bmMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgfHwgdHVpLnV0aWwuYmluZCh0aGlzLl9tYWtlVG9vbHRpcEh0bWwsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwIGFuaW1hdGlvbiB0aW1lLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25UaW1lID0gcHJlZGljYXRlLmlzUGllQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSkgPyBjaGFydENvbnN0LlRPT0xUSVBfUElFX0FOSU1BVElPTl9USU1FIDogY2hhcnRDb25zdC5UT09MVElQX0FOSU1BVElPTl9USU1FO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb29sdGlwQmFzZSBiYXNlIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPG9iamVjdD4+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gW107XG5cbiAgICAgICAgdGhpcy5fc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbigpO1xuICAgICAgICB0aGlzLl9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZSB0b29sdGlwIGh0bWwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfbWFrZVRvb2x0aXBIdG1sOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IGRlZmF1bHQgYWxpZ24gb3B0aW9uIG9mIHRvb2x0aXAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfc2V0RGVmYXVsdFRvb2x0aXBQb3NpdGlvbk9wdGlvbjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFNhdmUgcG9zaXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlT3JpZ2luYWxQb3NpdGlvbk9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm9yZ1Bvc2l0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsaWduOiB0aGlzLm9wdGlvbnMuYWxpZ24sXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2UgdG9vbHRpcCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX21ha2VUb29sdGlwRGF0YTogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0b29sdGlwIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRvb2x0aXAgZWxlbWVudFxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IGRvbS5jcmVhdGUoJ0RJVicsIHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKTtcblxuICAgICAgICByZW5kZXJVdGlsLnJlbmRlclBvc2l0aW9uKGVsLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJykpO1xuXG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRhaW5lciA9IGVsO1xuXG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVyZW5kZXIuXG4gICAgICovXG4gICAgcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLl9tYWtlVG9vbHRpcERhdGEoKTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25Nb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbk1vZGVsLnVwZGF0ZUJvdW5kKHRoaXMuYm91bmRzTWFrZXIuZ2V0Qm91bmQoJ3Rvb2x0aXAnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRvb2x0aXAgY29tcG9uZW50LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odGhpcy50b29sdGlwQ29udGFpbmVyLCB0aGlzLmJvdW5kc01ha2VyLmdldFBvc2l0aW9uKCd0b29sdGlwJykpO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uTW9kZWwudXBkYXRlQm91bmQodGhpcy5ib3VuZHNNYWtlci5nZXRCb3VuZCgndG9vbHRpcCcpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdG9vbHRpcCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0VG9vbHRpcEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9vbHRpcEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBFbGVtZW50ID0gdG9vbHRpcEVsZW1lbnQgPSBkb20uY3JlYXRlKCdESVYnLCAndHVpLWNoYXJ0LXRvb2x0aXAnKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmQodGhpcy50b29sdGlwQ29udGFpbmVyLCB0b29sdGlwRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25TaG93IGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBzaG93VG9vbHRpcCBmb3IgU2VyaWVzVmlldy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGNvb3JkaW5hdGUgZXZlbnQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIG9uU2hvdzogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMuX2dldFRvb2x0aXBFbGVtZW50KCksXG4gICAgICAgICAgICBwcmV2UG9zaXRpb247XG5cbiAgICAgICAgaWYgKCFwcmVkaWNhdGUuaXNNb3VzZVBvc2l0aW9uQ2hhcnQocGFyYW1zLmNoYXJ0VHlwZSkgJiYgdG9vbHRpcEVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgIHByZXZQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0b29sdGlwRWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogdG9vbHRpcEVsZW1lbnQub2Zmc2V0VG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zaG93VG9vbHRpcCh0b29sdGlwRWxlbWVudCwgcGFyYW1zLCBwcmV2UG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b29sdGlwRWxlbWVudCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gcmVuZGVyZWQgdG9vbHRpcCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBnZXRUb29sdGlwRGltZW5zaW9uOiBmdW5jdGlvbih0b29sdGlwRWxlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHRvb2x0aXBFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0b29sdGlwRWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZSB0byBQb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b29sdGlwRWxlbWVudCB0b29sdGlwIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcHJldlBvc2l0aW9uIHByZXYgcG9zaXRpb25cbiAgICAgKi9cbiAgICBtb3ZlVG9Qb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcEVsZW1lbnQsIHBvc2l0aW9uLCBwcmV2UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHByZXZQb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGVUb29sdGlwKHRvb2x0aXBFbGVtZW50LCBwcmV2UG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclV0aWwucmVuZGVyUG9zaXRpb24odG9vbHRpcEVsZW1lbnQsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTbGlkZSB0b29sdGlwXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcEVsZW1lbnQgdG9vbHRpcCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHByZXZQb3NpdGlvbiBwcmV2IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHt7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn19IHBvc2l0aW9uIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2xpZGVUb29sdGlwOiBmdW5jdGlvbih0b29sdGlwRWxlbWVudCwgcHJldlBvc2l0aW9uLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgbW92ZVRvcCA9IHBvc2l0aW9uLnRvcCAtIHByZXZQb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBtb3ZlTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBwcmV2UG9zaXRpb24ubGVmdDtcblxuICAgICAgICByZW5kZXJVdGlsLmNhbmNlbEFuaW1hdGlvbih0aGlzLnNsaWRpbmdBbmltYXRpb24pO1xuXG4gICAgICAgIHRoaXMuc2xpZGluZ0FuaW1hdGlvbiA9IHJlbmRlclV0aWwuc3RhcnRBbmltYXRpb24odGhpcy5hbmltYXRpb25UaW1lLCBmdW5jdGlvbihyYXRpbykge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBtb3ZlTGVmdCAqIHJhdGlvLFxuICAgICAgICAgICAgICAgIHRvcCA9IG1vdmVUb3AgKiByYXRpbztcbiAgICAgICAgICAgIHRvb2x0aXBFbGVtZW50LnN0eWxlLmxlZnQgPSAocHJldlBvc2l0aW9uLmxlZnQgKyBsZWZ0KSArICdweCc7XG4gICAgICAgICAgICB0b29sdGlwRWxlbWVudC5zdHlsZS50b3AgPSAocHJldlBvc2l0aW9uLnRvcCArIHRvcCkgKyAncHgnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogb25IaWRlIGlzIGNhbGxiYWNrIG9mIGN1c3RvbSBldmVudCBoaWRlVG9vbHRpcCBmb3IgU2VyaWVzVmlld1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBpbmRleFxuICAgICAqL1xuICAgIG9uSGlkZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHRvb2x0aXBFbGVtZW50ID0gdGhpcy5fZ2V0VG9vbHRpcEVsZW1lbnQoKTtcblxuICAgICAgICB0aGlzLmhpZGVUb29sdGlwKHRvb2x0aXBFbGVtZW50LCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0b29sdGlwIGFsaWduIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpZ24gYWxpZ25cbiAgICAgKi9cbiAgICBzZXRBbGlnbjogZnVuY3Rpb24oYWxpZ24pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmFsaWduID0gYWxpZ247XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHBvc2l0aW9uIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyfX0gcG9zaXRpb24gbW92aW5nIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHR1aS51dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25Nb2RlbC51cGRhdGVPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdG9vbHRpcCBhbGlnbiBvcHRpb24uXG4gICAgICovXG4gICAgcmVzZXRBbGlnbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IHRoaXMub3JnUG9zaXRpb25PcHRpb25zLmFsaWduO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbiA9IGFsaWduO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uTW9kZWwudXBkYXRlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRvb2x0aXAgcG9zaXRpb24uXG4gICAgICovXG4gICAgcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMub3JnUG9zaXRpb25PcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uTW9kZWwudXBkYXRlT3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnR1aS51dGlsLkN1c3RvbUV2ZW50cy5taXhpbihUb29sdGlwQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9vbHRpcEJhc2U7XG4iLCIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhpcyBpcyB0ZW1wbGF0ZXMgb2YgdG9vbHRpcC5cbiAqIEBhdXRob3IgTkhOIEVudC5cbiAqICAgICAgICAgRkUgRGV2ZWxvcG1lbnQgVGVhbSA8ZGxfamF2YXNjcmlwdEBuaG5lbnQuY29tPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsYXRlTWFrZXIgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RlbXBsYXRlTWFrZXInKTtcblxudmFyIGh0bWxzID0ge1xuICAgIEhUTUxfREVGQVVMVF9URU1QTEFURTogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtZGVmYXVsdC10b29sdGlwXCI+JyArXG4gICAgICAgICc8ZGl2Pnt7IGNhdGVnb3J5IH19PC9kaXY+JyArXG4gICAgICAgICc8ZGl2PicgK1xuICAgICAgICAgICAgJzxzcGFuPnt7IGxlZ2VuZCB9fTwvc3Bhbj46JyArXG4gICAgICAgICAgICAnJm5ic3A7PHNwYW4+e3sgdmFsdWUgfX08L3NwYW4+JyArXG4gICAgICAgICAgICAnPHNwYW4+e3sgc3VmZml4IH19PC9zcGFuPicgK1xuICAgICAgICAnPC9kaXY+JyArXG4gICAgJzwvZGl2PicsXG4gICAgSFRNTF9HUk9VUDogJzxkaXYgY2xhc3M9XCJ0dWktY2hhcnQtZGVmYXVsdC10b29sdGlwIHR1aS1jaGFydC1ncm91cC10b29sdGlwXCI+JyArXG4gICAgICAgICc8ZGl2Pnt7IGNhdGVnb3J5IH19PC9kaXY+JyArXG4gICAgICAgICd7eyBpdGVtcyB9fScgK1xuICAgICc8L2Rpdj4nLFxuICAgIEhUTUxfR1JPVVBfSVRFTTogJzxkaXY+JyArXG4gICAgICAgICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWxlZ2VuZC1yZWN0IHt7IGNoYXJ0VHlwZSB9fVwiIHN0eWxlPVwie3sgY3NzVGV4dCB9fVwiPjwvZGl2PiZuYnNwOzxzcGFuPnt7IGxlZ2VuZCB9fTwvc3Bhbj46JyArXG4gICAgICAgICcmbmJzcDs8c3Bhbj57eyB2YWx1ZSB9fTwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuPnt7IHN1ZmZpeCB9fTwvc3Bhbj4nICtcbiAgICAnPC9kaXY+JyxcbiAgICBHUk9VUF9DU1NfVEVYVDogJ2JhY2tncm91bmQtY29sb3I6e3sgY29sb3IgfX0nLFxuICAgIEhUTUxfTUFQX0NIQVJUX0RFRkFVTFRfVEVNUExBVEU6ICc8ZGl2IGNsYXNzPVwidHVpLWNoYXJ0LWRlZmF1bHQtdG9vbHRpcFwiPicgK1xuICAgICAgICAnPGRpdj57eyBuYW1lIH19OiB7eyB2YWx1ZSB9fTwvZGl2PicgK1xuICAgICc8L2Rpdj4nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0cGxEZWZhdWx0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfREVGQVVMVF9URU1QTEFURSksXG4gICAgdHBsR3JvdXA6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9HUk9VUCksXG4gICAgdHBsR3JvdXBJdGVtOiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkhUTUxfR1JPVVBfSVRFTSksXG4gICAgdHBsR3JvdXBDc3NUZXh0OiB0ZW1wbGF0ZU1ha2VyLnRlbXBsYXRlKGh0bWxzLkdST1VQX0NTU19URVhUKSxcbiAgICB0cGxNYXBDaGFydERlZmF1bHQ6IHRlbXBsYXRlTWFrZXIudGVtcGxhdGUoaHRtbHMuSFRNTF9NQVBfQ0hBUlRfREVGQVVMVF9URU1QTEFURSlcbn07XG4iXX0=
